Topic: Study Angular.
Date : 2022-01-04.

===================================================================================================
# MyFirstApp

This project was generated with [Angular CLI](https://github.com/angular/angular-cli) version 6.0.0.

## Development server

Run `ng serve` for a dev server. Navigate to `http://localhost:4200/`. The app will automatically reload if you change any of the source files.

## Code scaffolding

Run `ng generate component component-name` to generate a new component. You can also use `ng generate directive|pipe|service|class|guard|interface|enum|module`.

## Build

Run `ng build` to build the project. The build artifacts will be stored in the `dist/` directory. Use the `--prod` flag for a production build.

## Running unit tests

Run `ng test` to execute the unit tests via [Karma](https://karma-runner.github.io).

## Running end-to-end tests

Run `ng e2e` to execute the end-to-end tests via [Protractor](http://www.protractortest.org/).

## Further help

To get more help on the Angular CLI use `ng help` or go check out the [Angular CLI README](https://github.com/angular/angular-cli/blob/master/README.md).

------------------------------------------------------------------------------------
How to use the course apps
----------

Run "npm install" inside this project folder to install all dependencies.

Make sure you use the latest version of the CLI (upgrade guide below)

Run "ng serve" to see the app in action (try "npm start" in case "ng serve" fails).

Feel free to compare it with your project code to spot any errors you might have.


How to upgrade the CLI
-----------------------

Run the below commands - only use "sudo" on Mac/ Linux.

$ sudo npm uninstall -g angular-cli @angular/cli
$ npm cache clean --force
$ sudo npm install -g @angular/cli

$ ng update @angular/core @angular/cli

$ ng version

     _                      _                 ____ _     ___
    / \   _ __   __ _ _   _| | __ _ _ __     / ___| |   |_ _|
   / △ \ | '_ \ / _` | | | | |/ _` | '__|   | |   | |    | |
  / ___ \| | | | (_| | |_| | | (_| | |      | |___| |___ | |
 /_/   \_\_| |_|\__, |\__,_|_|\__,_|_|       \____|_____|___|
                |___/
    

Angular CLI: 13.3.3
Node: 16.13.1
Package Manager: npm 8.1.2
OS: darwin x64

Angular: 13.3.3
... animations, cli, common, compiler, compiler-cli, core, forms
... platform-browser, platform-browser-dynamic, router

Package                         Version
---------------------------------------------------------
@angular-devkit/architect       0.1303.3
@angular-devkit/build-angular   13.3.3
@angular-devkit/core            13.3.3
@angular-devkit/schematics      13.3.3
@schematics/angular             13.3.3
rxjs                            7.5.5
typescript                      4.6.3



------------------------------------------------------------------------------------

A normal start of a new app:

$ ng new shopping-app --no-strict
  ? Would you like to add Angular routing?  N
  Choose CSS styling

$ ng new routing-app --routing --no-strict

Alternatively, explicitly adding routing:
$ ng new routing-app --routing --defaults

Go to the root directory of the application:
$ ng serve

--> look at http://localhost:4200/

I have created: my-second-app

How to install:

$ cd /Users/rkremers/Development/workspaceJS/Angular/shopping-app
$ npm install --save bootstrap@3

Now make Angular aware of this styling package.
- angular.json file.

            "styles": [
              "node_modules/bootstrap/dist/css/bootstrap.min.css", !! bootstrap.min.css has been added here.
              "src/styles.css"
            ],

Template Driven: Add FormsModule to app.module.ts
Reactive Forms Driven: Add ReactiveFormsModule to app.module.ts
(sometimes it can be handy to use both).

$ npm install --save rxjs-compat

In case the Redux design pattern is to be installed (Section 24)

$ npm install --save @ngrx/effects @ngrx/store rxjs
$ npm install --save @ngrx/router-store

$ npm install --save-dev @ngrx/store-devtools
  - Use '--save-dev' because it is only intended for development.

Go to the root directory of the application:
$ ng serve
--> This shows the normal page: http://localhost:4200/

Section 26: Bonus: Angular Universal:
- In order to show the search engine what to look for instead of a very straight-forward one-page website.
$ ng add @nguniversal/express-engine

$ npm run build:ssr
$ npm run serve:ssr
--> http://localhost:4000/

When running

Create a new component:

In a second terminal:
$ ng generate component recipes --spec false
--> the option --spec false is outdated.

Instead:

$ ng generate component recipes --skip-tests

Create a new directive:

$ ng generate directive <name>

Create a new service:

$ ng generate service user --skip-tests

Create a new Pipe with name filter in subdirectory ./pipes:

$ ng generate pipe pipes/filter --skip-tests


366. Exploring NgRx Effects.

  What are side effects?
  - Parts in the code where some logic is executed that is of course important for the application but not so important for the immediate update of the current state.

  NgRx has a special package that will help dealing with the side effects.
  Install as follows:

  https://blog.logrocket.com/handling-side-effects-angular-redux-application/

  $ npm install --save @ngrx/effects @ngrx/store rxjs

  After this if necessary:

  $ npm start

  388. Using the Store Devtools.

  Adding some logging using NgRx tools.

  Google: redux devtools extension

  --> https://github.com/zalmoxisus/redux-devtools-extension
    --> Moved to:  https://github.com/reduxjs/redux-devtools

  Redux DevTools

  Developer Tools to power-up Redux development workflow or any other architecture which handles the state change (see integrations).

  It can be used as a browser extension (for Chrome, Edge and Firefox), as a standalone app or as a React component integrated in the client app.

  https://github.com/reduxjs/redux-devtools/tree/main/extension#installation
  - When using Chrome:
    - From Chrome Web Store:
      - Redux DevTools

  Once installed as Chrome Extension you can install a special package in the project.

  Stop ng serve.

  $ npm install --save-dev @ngrx/store-devtools
  - Use '--save-dev' because it is only intended for development.

  Restart ng serve
  $ ng serve --port 4202 

  Add to app.module.ts:

  import { StoreDevtoolsModule} from '@ngrx/store-devtools';
  import {environment} from "../environments/environment"; // Note: in production it would be a different environment file: environment.prod.ts.

  imports: [
  ..
      // Here logging is restricted to only production.
      StoreDevtoolsModule.instrument({logOnly: environment.production}),
  ..
  ]

  After Chrome restart you should find under Development Tools the Redux tab.

  Now you have a detailed log of what's happening in your application.

  You'll get a detailed overview of what NgRx is doing behind the scenes.


389. The Router Store.

  Another package that may come in handy:

  Stop ng serve

  $ npm install --save @ngrx/router-store

  This is also an official package, part of the NgRx suite.
  Helps with reacting to routing actions.
  It dispatches some actions automatically based on the Angular router. That would allow to write specific code in the reducer or NgRx effects
  that runs when such a routing occurs.

  Now in Development Tool | Redux more detailed content will be visible.




===================================================================================================

2022_01_04_study_angular

Course: https://www.udemy.com/course/the-complete-guide-to-angular-2
- In the meantime it has been upgraded to angular vs. 13.

unix:
- /Users/rkremers/Development/workspaceJS

This course also comes with free access to our “Academind Community” on Discord: “Academind Community”.
- https://academind.com/community
	- https://discord.com/channels/622033978047725582/622034266506657792
		--> Angular community.

Documentation:
- https://github.com/angular/angular-cli

A lot of problems are solved by making sure you're using the latest version of NodeJS, npm and the CLI itself.

Compatibility of angular with nodejs, TypeScript, RxJS:
- https://gist.github.com/LayZeeDK/c822cc812f75bb07b7c55d07ba2719b3
	- For the latest version of Angular: 
		- nodejs: 2.20.x/14.15.x/16.10.x or later minor version
		- Typescript: 4.4.x/4.5.x

$ npm i -g @angular/cli

$ sudo npm install -g typescript

Or:
npm install typescript@3.4.* --save-dev --save-exact

$ node -v
v17.3.0

$ npm -v
8.3.0

$ tsc -v
Version 4.5.4

--> Have to go back to node v16.

brew install node@16


node@16 is keg-only, which means it was not symlinked into /usr/local,
because this is an alternate version of another formula.

If you need to have node@16 first in your PATH, run:
  echo 'export PATH="/usr/local/opt/node@16/bin:$PATH"' >> ~/.zshrc ==> must be ~/.bash_profile

Now:

$ node -v
v16.13.1
rkremers@BKWI_C02ZX41RMD6R:~$ npm -v
8.1.2

$ ng --version

     _                      _                 ____ _     ___
    / \   _ __   __ _ _   _| | __ _ _ __     / ___| |   |_ _|
   / △ \ | '_ \ / _` | | | | |/ _` | '__|   | |   | |    | |
  / ___ \| | | | (_| | |_| | | (_| | |      | |___| |___ | |
 /_/   \_\_| |_|\__, |\__,_|_|\__,_|_|       \____|_____|___|
                |___/
    

Angular CLI: 13.1.2
Node: 16.13.1
Package Manager: npm 8.1.2
OS: darwin x64

Angular: 
... 

Package                      Version
------------------------------------------------------
@angular-devkit/architect    0.1301.2 (cli-only)
@angular-devkit/core         13.1.2 (cli-only)
@angular-devkit/schematics   13.1.2 (cli-only)
@schematics/angular          13.1.2 (cli-only)

2022-01-17:

After executing: 
$ npm install -g npm@8.3.1  
The whole application crashed.

After 
$ npm install -g npm
The application functioned again.

Version:
$ npm version                   
{
  'shopping-app': '0.0.0',
  npm: '8.1.2',
..
}

The reason for the update was that I received a warning about vulnerabilities.
For the future: 
- don't fix anything during the course.
- vulnerabilities and continuing adaptation of the various tools etc. will be an item.

-----------------------------
Default port for an Angular application: 4200

In order run the application on a different port:
$ $ ng serve --port 4201

---------------------------------------------------------------------------------------------------
2022-01-04:

7. Project Setup and First App.

> npm install -g @angular/cli
> ng new my-first-app --no-strict
  ? Would you like to add Angular routing?  N
  Choose CSS styling
> cd my-dream-app
> ng serve


npm = Node Package Member


$ ng new my-first-app --no-strict

I have added the App 'Angular Documentation' to Applications.

Go to the root directory of the application:
$ ng serve
✔ Browser application bundle generation complete.

Initial Chunk Files   | Names         |  Raw Size
vendor.js             | vendor        |   1.73 MB | 
polyfills.js          | polyfills     | 339.20 kB | 
styles.css, styles.js | styles        | 212.51 kB | 
main.js               | main          |  51.08 kB | 
runtime.js            | runtime       |   6.86 kB | 

                      | Initial Total |   2.32 MB

Build at: 2022-01-04T13:37:38.682Z - Hash: a669b6924dbf4d0a - Time: 8371ms

** Angular Live Development Server is listening on localhost:4200, open your browser on http://localhost:4200/ **


✔ Compiled successfully.
✔ Browser application bundle generation complete.

Initial Chunk Files | Names   | Raw Size
main.js             | main    |  8.82 kB | 
runtime.js          | runtime |  6.86 kB | 

3 unchanged chunks

Build at: 2022-01-04T13:40:36.428Z - Hash: d19e784955254c47 - Time: 322ms

✔ Compiled successfully.


--> look at http://localhost:4200/

- Replace the app.component.html with the resource file.


---------------------------------------------------------------------------------------------------
2022-01-04:

8. Editing the First App

Note:
- VSC is set to Autosave.
  - As soon as something has been written the file is saved.
- $ ng serve
  - As soon as something has been saved the application is rebuilt and the website http://localhost:4200/ is refreshed.


Edit app.component.html

Replace everything with:
<input  type="text" [(ngModel)]="name">
<p>{{ name }}</p>

Use the Developer tool in the browser:

  Compiled with problems:

  ERROR

  src/app/app.component.html:19:21 - error NG8002: Can't bind to 'ngModel' since it isn't a known property of 'input'.

  19 <input  type="text" [(ngModel)]="name">
                         ~~~~~~~~~~~~~~~~~~

ngModel is a Forms feature that needs to be imported.
- This needs to be done in src/app.module.ts.
- This is a TypeScript feature: TS needs to know where things are.

Now: FormsModule is added to imports in NgModule.
- This is an Angular feature.

Now the new attribute in app.component.html is known.

<input  type="text" [(ngModel)]="name">
<p>{{ name }}</p>

ngModel reads the input and adds it to the variable {{ name }}.
This will be visible on the website.


---------------------------------------------------------------------------------------------------
2022-01-04:

9. Course structure:

Note:
- Show the end sheet to the rest tomorrow.

- Getting Started
- The Basics
- Components & DataBinding
- Directives
- Services & Dependency Injecion
  - Managing the state of your implementation
- Routing
  - Single Paga application
    - Management of different url's so that to the user it looks like we are switching pages though technically we will remain on that single page.
- Observables
  - Allows to work with asynchronous code.
- Forms:
  - Key part of any application.
- Pipes:
  - Transforms the output, i.e. what is displayed at runtime.
- HTTP:
  - Angular (JavaScript) can not connect to a database, but it can connect to a server (via REST, etc.). That is the function of HTTP here.
- Authentication
  - What does it mean and how is it used in Angular.
- Optimizations and NgModules
- Deployment
  - From local to a place in production.
- Animation & Testing


10. How to get the Most out of the Course.

- Watch the video's.
- Do the Assignments.
- Do the Course Project.
- Experiment.
- Ask in Q&A, 
- Also try to answer in Q&A. Thinking about problems will give more insight.

- Documentation!
- Google.

11. What is TypeScript?

- TS is a superscript over JS.
- Strongly typed.

Is compiled to JavaScript (JS).

Pick TS up along the way.

12. Optional: TypeScript Quick Introduction

See optional: Section 32: Bonus: TypeScript introduction (for Angular usage).

13. A Basic Project Setup using Bootstrap for Styling.

I have created: my-second-app

How to install:

$ cd /Users/rkremers/Development/workspaceJS/Angular/my-second-app
$ npm install --save bootstrap@3

This will download bootstrap locally. Not globally.

added 1 package, removed 1 package, and audited 1015 packages in 2s

90 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities

Will install in the node_modules folder.

Now make Angular aware of this styling package.
- angular.json file.

            "styles": [
              "node_modules/bootstrap/dist/css/bootstrap.min.css", !! bootstrap.min.css has been added here.
              "src/styles.css"
            ],

When running in Chrome (is not visible in FireFox):
Development Tools:
- Sources
  - styles.css:
    - Added: bootstrap.
      /*!
       * Bootstrap v3.4.1 (https://getbootstrap.com/)


14. About the Course Code / Code snapshots

One important note: All the course code will only work if you are NOT using "strict mode" see the "First App" lecture in this module. 
Strict mode forces you to write more verbose code in some places (especially when it comes to class properties). 
If you enabled it by accident, you can also disable it by setting strict: false in your tsconfig.json file.

===================================================================================================

Section 2: The Basics

15. Module Introduction.

16. How an Angular App gets Loaded and Started.

17. Components are important!

18. Creating a New Component.


Note:
- Spend some time on VSC itself
  - Which settings arree possible
  - tslint.json
    - Provides code convention hints.
    - To be added?
  - Provision of code hints, detection of errors, ~ sonarlint, etc.

- Visual Studio Code Tutorial for Beginners - Introduction
  - https://www.youtube.com/watch?v=VqCgcpAypFQ

19. Understanding the Role of AppModule and Component Declaration

- Create new components in a sub-directory under <application>/src/app/.
- Give the new sub-directory a meaningful name.
- A component is a class.
- Modules are used to bundle different items, e.g. components, into packages.
  - In our case we have one module, represented by app.module.ts with class AppModule, i.e. representing the entire application.
  - So multiple modules are possible in case of larger applications.
- We will not add more selectors to the html file. That is not how it is intended to setup an Angular application.


20. Using Custom Components.

21. Creating Components with the CLI & Nesting Components.

- Open a new terminal, next to the existing one that is used for 'ng serve'.
- $ ng generate component servers
- Idem:
  $ ng g c servers

$ ng generate component servers
CREATE src/app/servers/servers.component.css (0 bytes)
CREATE src/app/servers/servers.component.html (22 bytes)
CREATE src/app/servers/servers.component.spec.ts (633 bytes) # this one is used for testing (will come back later)
CREATE src/app/servers/servers.component.ts (279 bytes)
UPDATE src/app/app.module.ts (545 bytes)

Now the new component has been added to app.component.ts by Angular with tag <app-servers>.
Add the <app-server> tag to src/app/servers/servers.component.html.
If the new tag <app-servers> is added to app.component.html the new situation is now visible in the main web page: localhost:4200.


22. Working with Component Templates.

- Each component needs to have a template.
- Instead of using:

   templateUrl: './servers.component.html'

  - Points to an external html File
  - You can use:

    template: `
              <app-server></app-server>
              <app-server></app-server>`,

    - Note that now back-ticks '`' are being used.

This means that the html code is placed within the component content.
This can be handy if the intended code is only a few lines large.


23. Working with Component Styles.

A style can be set in the file <component>.component.css file.

Also the style can be set in the file <component>.component.ts.
- More than one style can be set:
  styleUrls: ['./app.component.css', '']
- Or  the style can be set in the ts file itself, using 'styles' instead of 'styleUrls':

  // styleUrls: ['./app.component.css']
  styles: [`
    h3 {
      color: dodgerblue;
    }
  `]
})


24. Fully Understanding the Component Selector.

Multiple ways to define the Component Selector and the way it is used.

Method 1:

servers.component.ts:

selector: 'app-servers',

- app.component.html:

  <app-servers></app-servers>

Method 2:

servers.component.ts:

selector: '[app-servers]',

- app.component.html:

  <div app-servers></div>

Method 3:

servers.component.ts:

// Select by class: so using the path starting from src:
selector: '.app-servers',

- app.component.html:

  <div class="app-servers"></div> <!-- This class can now be styled in app.components.css -->

Method 1 is the preferred way.

Also directives can be used. That is a separate topic.


Assignment 1: Practicing Components.


Assignment: Practicing Components
10 minutes to complete
34,474 student solutions

Time to practice what you learned about Components. 
In this assignment, you're going to create, use and style your own components and see practice how you can build up your Angular app with Components.

$ ng generate component bkwi-component
CREATE src/app/bkwi-component/bkwi-component.component.css (0 bytes)
CREATE src/app/bkwi-component/bkwi-component.component.html (29 bytes)
CREATE src/app/bkwi-component/bkwi-component.component.spec.ts (676 bytes)
CREATE src/app/bkwi-component/bkwi-component.component.ts (306 bytes)
UPDATE src/app/app.module.ts (657 bytes)

25. [OPTIONAL] Assignment Solution.

Added: 
- bkwi-component
  - generated: 
    $ ng generate component bkwi-component
  - Pimped the css
- warning-alert
  - added manually.
  - Pimped the css.

26. What is DataBinding?

Databinding = Communication

Backend <==> TypeScript Code (Business Logic) <==> Template (HTML)

TS ==> Output Data ==> HTML
- String Interpolation: ( {{ data }} )
- Property Binding    : ( [property]="data" )

TS <== React to (User) Events <== HTML
- Event Binding ( (event)="expression" )

Combination of both: 
- Two-Way-Binding ( [(ngModel)]="data" )



27. String Interpolation.

Normally you don't want hard-coded content in the html files, like app.component.html.

Example:
- controller: server.component.ts
  - controller class: ServerComponent
- viewer: server.component.html

The design pattern that is used is MVC:
- Viewer: <component>.component.html
  - Here a parameter, that always provides a string, is placed.
    {{ serverId }}
    Also possible:
      - A hardcoded string
        {{ 'a String' }}
      - A method defined in the controller class.
        {{ getServerStatus() }}
  - The paramater is places between curly braces.
- Controller: <component.component.ts
  - controller class ServerComponent:

export class ServerComponent {
    /**
     * The type is inferred from the value, but is present for demo-purpose.
     * Apparently I can not use 'var' here.
     */
  serverId: number = 10;
  serverStatus: string = 'offline';

  getServerStatus(): string {
      return this.serverStatus;
  }
}
- server.component.html
  <p>The Server Component with ID {{ serverId }} has status {{ getServerStatus() }}</p>


28. Property Binding.


Example:
- servers.commponents.ts
  - Controller class ServersComponent
    allowNewServer = false;
- servers.components.html
  class="btn btn-primary" [disabled]="!allowNewServer">Add Server</button>


29. Property Binding vs String Interpolation.

Typical use cases:
- Property Binding    : If it is necessary to change the value of a property.
- String Interpolation: It a text needs to be changed dynamically.

Do not mix Property Binding and String Interpolation.
- i.e. do not use curly braces (Property Binding) in combination with the rectangular braces.


30. Event Binding.

Example:
- servers.component.ts

serverCreationStatus = 'No server was created';

onCreateServer() {
  this.serverCreationStatus = "Server was created";
}

- servers.component.html

<button 
    class="btn btn-primary" 
    [disabled]="!allowNewServer"
    (click)="onCreateServer()"
    >Add Server</button>

Note:
<button onclick></button> is HTML
<button (click)></button> is Angular. This is recognized in VSC and in () all available methods can be listed.


31. Bindable Properties and Events.

How do you know to which Properties or Events of HTML Elements you may bind? 
You can basically bind to all Properties and Events - a good idea is to console.log()  the element you're interested in to see which properties and events it offers.

Important: For events, you don't bind to onclick but only to click (=> (click)). (Note: So again: instead of HTML use Angular)

The MDN (Mozilla Developer Network) offers nice lists of all properties and events of the element you're interested in. Googling for YOUR_ELEMENT properties  or YOUR_ELEMENT events  should yield nice results.


32. Passing and Using Data with Event Binding.

- servers.component.html
  <input type="text" class="from-control" (input)="onUpdateServerName($event)">
  - $event
    - Parameter, that contains a lot of information
    - For each character in the insert field a record is created via console.log(event) in servers.componen.tc
      - This is visible in the Developers Tool | Console
      - Each rcord is an event, containing lots of information
        - Each record also contains: event.target.value = <THE COMPLETE INPUT in the inputfield>
          - In this way the (<HTMLInputElement>event.target).value; is obtained.
- servers.component.tc

  serverName = '';
  ..
  onUpdateServerName(event: Event) {

    console.log(event);
    this.serverName = (<HTMLInputElement>event.target).value.

  }

33. Important: FormsModule is Required for Two-Way-Bind.

Important: FormsModule is Required for Two-Way-Binding!
Important: For Two-Way-Binding (covered in the next lecture) to work, you need to enable the ngModel  directive. This is done by adding the FormsModule  to the imports[]  array in the AppModule.

You then also need to add the import from @angular/forms  in the app.module.ts file:

import { FormsModule } from '@angular/forms';


34.Two-Way-Binding.

- servers.component.html

<!-- Two-Way-Databinding -->
<input type="text" class="from-control" [(ngModel)]="serverName">
..
<p>{{ serverName }}</p>


- servers.cmmponent.tc

import { FormsModule } from '@angular/forms';

- When the server name is typed into the text field it will immediately be visible in the field <p>{{ serverName }}</p>.


35. Combining all Forms of DataBinding.

I have given een overview of the four types of databinding in servers.component.html.


Assignment 2: Practicing Databinding.

You learned a lot about Databinding! Time to practice it on your own. 
In this assignment, you're going to use the different forms of Databinding and see how you may use them in your app.

1. Add an Input field which updates a property ('username') via Two-Way-Binding.
2. Output the username property via String Interpolation (in a paragraph below the input).
3. Add a button which may only be clicked if the username is NOT an empty string.
4. Upoon clicking the button, the username should be reset to an empty string.

<input id="Username" name="Username" type="text" class="from-control" [(ngModel)]="userName"><br>
<p>userName = {{ userName }}</p>
<button
    class="btn btn-primary"
    [disabled]="onCheckIsEmpty()"
    (click)="onResetUsername()"
    >Reset Username</button>

36. Assignment Solution.

- app.component.html
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  username = '';
}

- app.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  username = '';
}

$ ng generate component assignment2 
CREATE src/app/assignment2/assignment2.component.css (0 bytes)
CREATE src/app/assignment2/assignment2.component.html (26 bytes)
CREATE src/app/assignment2/assignment2.component.spec.ts (661 bytes)
CREATE src/app/assignment2/assignment2.component.ts (295 bytes)
UPDATE src/app/app.module.ts (867 bytes)

$ ng generate component documentation
CREATE src/app/documentation/documentation.component.css (0 bytes)
CREATE src/app/documentation/documentation.component.html (28 bytes)
CREATE src/app/documentation/documentation.component.spec.ts (675 bytes)
CREATE src/app/documentation/documentation.component.ts (303 bytes)
UPDATE src/app/app.module.ts (977 bytes)

37. Understanding Directives.

For the coming sections also see:
- https://angular.io/guide/built-in-directives#built-in-directives
- https://angular.io/guide/built-in-directives#built-in-structural-directives

- Directives are instructions in the DOM.
  - Components are directives with a template.
    - By placing the component somewhere Angular is instructed to add the component functionality at that place where we use the selector.

Example:

app.component.html
<p appTurnGreen> Receive green background!</p>

@Directive({
  selector: '[appTurnGreen]'
})
export Class TurnGreenDirective {
  
}

==> Directive to turn the background green.


38. Using ngIf to Output Data Conditionally.

Resources:
- https://angular.io/guide/built-in-directives#ngIf

ngIf —conditionally creates or disposes of subviews from the template.
As for all attribute directives: without the '*' it will not work correctly.
- *ngIf="condition"
- *ngIf="condition; else elseBlock"
- *ngIf="condition; then thenBlock else elseBlock"

- servers.components.html
  - <p *ngIf="serverCreated">Server was created, serverName is {{ serverName }}.</p>
    - When looking into the web page under Development Tools | Elements:
      - The element is only present IF serverCreated=true. If serverCreated=false the element will not exist, i.e. it is NOT hidden.
- servers.components.ts
  serverCreated: boolean = false;
  onCreateServer() {
    this.serverCreated = true;
    this.serverCreationStatus = "Server was created! Name is " + this.serverName;
  }


39. Enhancing ngIf with an Else condition.

<p *ngIf="serverCreated; else noServer">Server was created, serverName is {{ serverName }}.</p>
<ng-template #noServer>
    <p>No server was created as yet!</p>
</ng-template>

Note:
- The case with p *ngIf="serverCreated"> is the case you will see most often.
- Another option would have been to create to cases: 
  <p *ngIf="!serverCreated">No server was created as yet!</p>

40. Styling Elements Dynamically with ngStyle.

NgStyle —adds and removes a set of HTML styles.
NgStyle will add a style attribute to the paragraph <p>; visibl in Developer Tools | Elements.

Resources:
- https://angular.io/guide/built-in-directives#ngstyle

Apparently ngStyle does not need a '*' in advance in order to be functional.

- server.component.html
  - <p [ngStyle]="{backgroundColor: getColor()}" >The Server Component with ID {{ serverId }} has status {{ getServerStatus() }}</p>
    - Note that here Property Binding is used.
- server.component.ts

  getColor() {
      return this.serverStatus === 'online' ? 'green' : 'red';
  }


41. Applying CSS Classes Dynamically with ngClass.

Resources:
- https://angular.io/guide/built-in-directives#ngClass

- server.component.css

.online {
    color: white;
}

- server.commponent.html

<p 
    [ngStyle]="{backgroundColor: getColor()}" 
    [ngClass]="{online: serverStatus === 'online'}"
    >The Server Component with ID {{ serverId }} has status {{ getServerStatus() }}</p>


- sesrver.component.ts

styleUrls: ['./server.component.css']

constructor() {
    this.serverStatus = Math.random() > 0.5 ? 'online' : 'ofline';
}

ngClass will create a class attribute in the paragraph <p>
The class attribute will be visible only in Development Tools | Elements if the condition is true.


42. Outputting Lists with ngFor.

Resource:
- https://angular.io/guide/built-in-directives#ngFor

Assignment 3: Practicing Directives.

$ ng generate component assignment3
--> Add the component.

Questions for this assignment
Please complete the tasks outlined in the instructions video. 
Why did you choose the approach you took? 
Which problems did you encounter?

1. Add a button which says 'Display Details'.
2. Add a paragraph with any content of your choice (e.g. 'Secret Password = tuna').
3. Toggle the displaying of that paragraph with the button created in the first step.
4. Log all button clicks in an array and output that array below the secret paragraph (maybe log a timestamp or simply an increment number).
5. Starting at the 5th log item, give all future log items a blue background (via ngStyle) and white color (ngClass).

$ ng generate component assignment3  
CREATE src/app/assignment3/assignment3.component.css (0 bytes)
CREATE src/app/assignment3/assignment3.component.html (26 bytes)
CREATE src/app/assignment3/assignment3.component.spec.ts (661 bytes)
CREATE src/app/assignment3/assignment3.component.ts (295 bytes)


===================================================================================================

Section 3: Course Project - The Basics.

45. Project Introduction.

46. Planning the App.

- Shopping List
- Recipe Book

Overview:
- /Users/rkremers/Development/workspaceJS/Angular_course_content/2022_01_09_Overview_Course_Project.png
  --> Use this for at least this Section.

47. Creating a New App correctly.

Creating a New App Correctly
MUST READ

In the next lecture, we set up the course project.

Make sure, you do create that app by also adding the --no-strict flag to the ng new command - otherwise you will run into issues later on (we'll still dive into that "Strict Mode" later in the course of course, no worries)!

We'll also install the Bootstrap CSS Framework and in this course, we use version 3 of the framework. Install it via npm install --save bootstrap@3  => The @3  is important!

Additionally, when using a project created with Angular CLI 6+ (check via ng v ), you'll have an angular.json  file instead of an .angular-cli.json  file. In that file, you still need to add Bootstrap to the styles[]  array as shown in the next video, but the path should be node_modules/bootstrap/dist/css/bootstrap.min.css , NOT ../node_modules/bootstrap/dist/css/bootstrap.min.css . The leading ../  must not be included.

Also see this lecture - I do show the complete setup process there: https://www.udemy.com/the-complete-guide-to-angular-2/learn/v4/t/lecture/6655614/

If you're facing any problems, please have a look at this very thorough thread by Jost: https://www.udemy.com/course/the-complete-guide-to-angular-2/learn/lecture/17862130#questions/10444944


$ ng new shopping-app --no-strict
  ? Would you like to add Angular routing?  N
  Choose CSS styling

Go to the root directory of the application:
$ ng serve

--> look at http://localhost:4200/

I have created: my-second-app

How to install:

$ cd /Users/rkremers/Development/workspaceJS/Angular/shopping-app
$ npm install --save bootstrap@3

This will download bootstrap locally. Not globally.

added 1 package, removed 1 package, and audited 1015 packages in 2s

90 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities

Will install in the node_modules folder.

Now make Angular aware of this styling package.
- angular.json file.

            "styles": [
              "node_modules/bootstrap/dist/css/bootstrap.min.css", !! bootstrap.min.css has been added here.
              "src/styles.css"
            ],

Add FormsModule to app.module.ts

Go to the root directory of the application:
$ ng serve

====================================================
How to change the default angular port number 4200:

https://www.angularjswiki.com/angular/how-to-change-angular-port-ng-serve-port-number-from-4200-to-other/

here are two ways we can change the default angular port number from 4200 to other number.

    Using ng serve --port flag.
    Specifying default port number in project’s Angular.json file.

$ ng serve --port 3200

Here are the steps to add default port number in Angular applications.

    Navigate to project route folder.
    Open “angular.json” file.
    Search for “serve” configuration and it contains “options” cofig.
    Add “port”:3001(or any other number) property inside options.

 "serve": {
          "builder": "@angular-devkit/build-angular:dev-server",
          "options": {
            "browserTarget": "latest-angular:build",
      "port": 3001
          },
          "configurations": {
            "production": {
              "browserTarget": "latest-angular:build:production"
            }
          }
        }

====================================================

The component header has been added manually.

$ ng generate component recipes --spec false
--> the option --spec false is outdated.

Instead:

$ ng generate component recipes --skip-tests
CREATE src/app/recipes/recipes.component.css (0 bytes)
CREATE src/app/recipes/recipes.component.html (22 bytes)
CREATE src/app/recipes/recipes.component.ts (279 bytes)
UPDATE src/app/app.module.ts (545 bytes)

All recipe related components will now be created under the recipes-folder:

$ ng generate component recipes/recipe-list --skip-tests
CREATE src/app/recipes/recipe-list/recipe-list.component.css (0 bytes)
CREATE src/app/recipes/recipe-list/recipe-list.component.html (26 bytes)
CREATE src/app/recipes/recipe-list/recipe-list.component.ts (294 bytes)
UPDATE src/app/app.module.ts (653 bytes)

$ ng generate component recipes/recipe-detail --skip-tests
CREATE src/app/recipes/recipe-detail/recipe-detail.component.css (0 bytes)
CREATE src/app/recipes/recipe-detail/recipe-detail.component.html (28 bytes)
CREATE src/app/recipes/recipe-detail/recipe-detail.component.ts (302 bytes)
UPDATE src/app/app.module.ts (769 bytes)

$ ng generate component recipes/recipe-list/recipe-item --skip-tests
CREATE src/app/recipes/recipe-list/recipe-item/recipe-item.component.css (0 bytes)
CREATE src/app/recipes/recipe-list/recipe-item/recipe-item.component.html (26 bytes)
CREATE src/app/recipes/recipe-list/recipe-item/recipe-item.component.ts (294 bytes)
UPDATE src/app/app.module.ts (889 bytes)

$ ng generate component shopping-list --skip-tests
CREATE src/app/shopping-list/shopping-list.component.css (0 bytes)
CREATE src/app/shopping-list/shopping-list.component.html (28 bytes)
CREATE src/app/shopping-list/shopping-list.component.ts (302 bytes)
UPDATE src/app/app.module.ts (997 bytes)

$ ng generate component shopping-list/shopping-edit --skip-tests
CREATE src/app/shopping-list/shopping-edit/shopping-edit.component.css (0 bytes)
CREATE src/app/shopping-list/shopping-edit/shopping-edit.component.html (28 bytes)
CREATE src/app/shopping-list/shopping-edit/shopping-edit.component.ts (302 bytes)
UPDATE src/app/app.module.ts (1119 bytes)

When looking into app.module.ts:

import { AppComponent } from './app.component';
import { HeaderComponent } from './header/header.component';
import { RecipesComponent } from './recipes/recipes.component';
import { RecipeListComponent } from './recipes/recipe-list/recipe-list.component';
import { RecipeDetailComponent } from './recipes/recipe-detail/recipe-detail.component';
import { RecipeItemComponent } from './recipes/recipe-list/recipe-item/recipe-item.component';
import { ShoppingListComponent } from './shopping-list/shopping-list.component';
import { ShoppingEditComponent } from './shopping-list/shopping-edit/shopping-edit.component';


50. Using the Components.

51.Adding a Navigation Bar.

52. Alternative Non-Collapsable Navigation Bar.

The way we added it, the Navbar will collapse on smaller screens. Since we didn't implement a Hamburger menu, that means that there's no way of accessing our links on smaller screens.

You can either add such a menu on your own (see below), or you replace collapse navbar-collapse  with just navbar-default.

Adding a Hamburger Menu:

Alternatively, if you want to make the navigation bar responsive, please replace these lines in header.component.html:

<!-- 
This code will cause Recipes and Shopping List to be positioned next to each other if the webpage is broad enough and if too small
to be positioned below each other
-->
<div class="navbar-header">
  <a routerLink="/" class="navbar-brand">Recipe Book</a>
</div>
<div class="collapse navbar-collapse">
with these lines:

<!--
This code will cause the Recipes and Shopping List to disappear if the webpage is too small.
-->
<div class="navbar-header">
  <button type="button" class="navbar-toggle" (click)="collapsed = !collapsed">
  <span class="icon-bar" *ngFor="let iconBar of [1, 2, 3]"></span>
  </button>
  <a routerLink="/" class="navbar-brand">Recipe Book</a>
</div>
<div class="navbar-collapse" [class.collapse]="collapsed" (window:resize)="collapsed = true">
and add this line to header.component.ts:

collapsed = true;


53. Creating a "Recipe" Model.


recipe.model.ts

export class Recipe {
    public name: string;
    public description: string;
    public imagePath: string;

    constructor(name: string, description: string, imagePath: string) {
        this.name = name;
        this.description = description;
        this.imagePath = imagePath;
    }
}

54. Adding Content to the Recipes Components.

55. Outputting a List of Recipers with *ngFor.

56. Displaying Recipe Details.

A limitation for the moment is cross component communication.

57. Working on the ShoppingListComponent.

58. Creating an "Ingredient" Model.

59.Creating and Outputting the Shopping List.

60. Adding a Shopping List Edit Section.

61. Wrap Up & Next Steps.

Next section: Inter Component Communication.

Shortcuts:
- div: type .col-xs-12 + tab. Now will be visible: div class="col-xs-12">
- button: type button + tab. Now will be visible: <button></button>


===================================================================================================

Section 4: Debugging.

62. Understanding Angular Error Messages.

63. Debugging Code in the Browser Using Sourcemaps.

Go to Developer Tools | Sources
--> (in our case) main.js
  --> Here out code, in JavaScript, is available.
- webpack://
  - . directory
    - Here all source code is present. 
    - You can add breakpoints here.
    - In case of an event-driven app, e.g. starting functionality by clicking a button, you can debug through the codde.


===================================================================================================

Section 5: Components & Databinding Deep Dive.


64. Module Introduction.


$ ng new cmp-databinding-start --no-strict
  ? Would you like to add Angular routing?  N
  Choose CSS styling

Go to the root directory of the application:
$ ng serve

--> look at http://localhost:4200/

I have created: shopping-app

How to install:

$ cd /Users/rkremers/Development/workspaceJS/Angular/cmp-databinding-start
$ npm install --save bootstrap@3

This will download bootstrap locally. Not globally.

added 1 package, removed 1 package, and audited 1015 packages in 2s

90 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities

Will install in the node_modules folder.

Now make Angular aware of this styling package.
- angular.json file.

            "styles": [
              "node_modules/bootstrap/dist/css/bootstrap.min.css", !! bootstrap.min.css has been added here.
              "src/styles.css"
            ],

Add FormsModule to app.module.ts

Go to the root directory of the application:
$ ng serve

--> For this section we will use cmp-databinding-start


65. Splitting Apps into Components.


If code, cq. a component, becomes too large the code should be split.

$ ng generate component cockpit --skip-tests
$ ng generate componeny server-element --skip-tests

The original content in app.component is now divided  over the components cockpit and server-element.

This will cause an error because 'serverElements[]' is now present in cockpit.component.ts but should also be known in app.component.html.

In other words: we will need to share data between components.


66. Property & Event Binding Overview.


HTML Elements <==> Native Properties & Events
Directives    <==> Custom Propertis & Events

Now: we can also use this on Components:

Components    <==> Custom Properties & Events


67. Binding to Custom Properties.

By default properties in a component are only accessible inside that component.
We need a decorator in order to make a property available outside the component.
Decorators can not only be used for classes but also for properties.

In order to do this add the decorator @Input():

server-element.component.ts

import { Component, OnInit, Input } from '@angular/core';

@Input() element: { type: string, name: string, content: string };


Angular CLI: 13.1.2
Node: 16.13.1
Package Manager: npm 8.1.2
OS: darwin x64

Angular: 13.1.1
... animations, common, compiler, compiler-cli, core, forms
... platform-browser, platform-browser-dynamic, router

Package                         Version
---------------------------------------------------------
@angular-devkit/architect       0.1301.2
@angular-devkit/build-angular   13.1.2
@angular-devkit/core            13.1.2
@angular-devkit/schematics      13.1.2
@angular/cli                    13.1.2
@schematics/angular             13.1.2
rxjs                            7.4.0
typescript                      4.5.4

At 3:27 I do not see an error.
At the end I do not see the server with name 'Testserver', defined in app.component.ts.



@Input() is always used with property binding in the parent component, and we can have multiple properties decorated in this way.


-----

These are the general rules for component communication:

1. (See course sections 5/6)

You can pass values from a parent to a child component using [property binding] in the parent and @Input() in the child.

You can pass values from a child to a parent component using (event binding) in the parent and @Output() for the EventEmitter in the child.

This syntax is rather intuitive: @Input() marks inputs into the child (coming from its parent), @Output() marks outputs from the child (to its parent).

(A direct parent/child relationship of two components is established by the fact that the selector of the child component is placed somewhere in the template of the parent component.)

2. (See course sections 9/10ff)

In all other cases (if you have a different relationship between components, or if routing is involved) you will have to use a service. This approach has no restrictions, you can use it in all imaginable constellations.

You can also use it for direct parent/child communication in the same way, if you want, although the first approach is preferable in most of these cases.

Jost

Jost — Teaching Assistant
0 upvotes
13 days ago

68.Assigning an Alias to Custom Properties.

Sometimes you want to use a name in the html file, that differs from the one you are using in the controller class.
In that case you can use an alias:

In this example:

app.component.html:
..
[srvElement]="serverElement">
..

server-element.component.ts:
 @Input('srvElement') public element: { type: string, name: string, content: string };


See: 26. What is DataBinding?
--> This method is actually PropertyBinding.


69. Binding to Custom Events.

Resources:
- https://angular.io/guide/inputs-outputs

Jost — Teaching Assistant
12 upvotes
1 year ago

Hi!

For future readers of this thread who also have problems to understand what's happening here:
These are the general rules for component communication in a nutshell.


1. (See course sections 5/6)
You can pass values from a parent to a child component using [property binding] in the parent and @Input() in the child.
You can pass values from a child to a parent component using (event binding) in the parent and @Output() in the child.
This syntax is rather intuitive: @Input() marks inputs into the child (coming from its parent), @Output() marks outputs from the child (to its parent).
(A direct parent/child relationship of two components is established by the fact that the selector of the child component is placed somewhere in the template of the parent component.)


2. (See course sections 9/10ff)

In all other cases (if you have a different relationship between components, or if routing is involved) you will have to use a service. This approach has no restrictions, you can use it in all imaginable constellations.
You can also use it for direct parent/child communication in the same way, if you want, although the first approach is preferable in most of these cases.

Jost

General setup for this section:

TS ==> Output Data ==> HTML
- String Interpolation: ( {{ data }} )
- Property Binding    : ( [property]="data" )

TS <== React to (User) Events <== HTML
- Event Binding       : ( (event)="expression" )

Combination of both: 
- Two-Way-Binding     : ( [(ngModel)]="data" )


  AppComponent
    (someEvent)         <== CockpitComponent @Output()
    [someProperty]      ==> ServerElementComponent @Input()

<parent-component>
  <child-component></child-component>
</parent-component>

The <parent-component> serves as the context for the <child-component>.

@Input() and @Output() give a child component a way to communicate with its parent component. 
- @Input() lets a parent component update data in the child component. 
- @Output() lets the child send data to a parent component.
   - An @Output() must have the type of EventEmitter.
   - The @Output() content will be sent to the parent, i.e. app.component.

Setup of the implementation:
In this Section a project cmp-databinding-start is built.
In this paragraph the following is implemented:
1. Data is entered into <app-cockpit> via cockpit.component.html input fields 
  and is sent to the parent compontent <app-component> via @Output().
2. Now the data enters via Event Binding in app.component.ts to array 'serverElements' via 
    '(serverCreated)' or '(blueprintCreated)' defined in app.component.ts.
3. Via a loop over 'serverElements' the data enters <app-server-element via @Input().
    Here in server-element.component.html a new panel with header and content is created.


70. Assigning an Alias to Custom Events.

cockpit.component.ts

@Output('bpCreated') blueprintCreated = new EventEmitter<{ serverName: string, serverContent: string }>();

app.component.html:

<app-cockpit (serverCreated)="onServerAdded($event)" (bpCreated)="onBlueprintAdded($event)"></app-cockpit>


71. Custom Property and Event Binding Summary.

If data needs to be exchanged between two child-components the same method as describe in paragraph 69 needs to be used.
The data flow will be set up via the parent-component:

child-component 1 <==> parent-component <==> child-component 2.

This can become very intricate if a large distance between two components exists.
In a later section about services an alternative will be described.


72. Understanding View Encapsulation.

Resources:
- https://angular.io/api/core/ViewEncapsulation

Emulates a native Shadow DOM encapsulation behavior by adding a specific attribute to the component's host element and applying the same attribute to all the CSS selectors provided via styles or styleUrls.

This is the default option.

In practice this means that the elements of a given component will all have an attribute, e.g. _ngcontent-npgf-c43.
The elements of another component will each have a different attribute.
Reason:
- Angular enforces style encapsulation. It does this by adding the same attribute to all elements of a component.
  This ensures that a given style will only be applied to the elements that component.
  It implements a shadow DOM to the component.
  Reason for this is that not all browsers work in the same way. To ensure the same behavior in multiple browsers that has been implemented.


73. More on View Encapsulation.

Resources:
- https://angular.io/api/core/ViewEncapsulation

e.g. encapsulation: ViewEncapsulation.ShadowDom

Use:
import { Component, ViewEncapsulation } from '@angular/core';
 
@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css'],
  encapsulation: ViewEncapsulation.ShadowDom // This will override the styles of child components.

})
export class AppComponent {
..
}

Uses the browser's native Shadow DOM API to encapsulate CSS styles, meaning that it creates a ShadowRoot for the component's host element which is then used to encapsulate all the Component's styling.

This allows to set a standard style for all components that are below the component where this has been set.


74. Using Local References in Templates.

cockpit.component.html

<div class="row">
    <div class="col-xs-12">
        <p>Add new Servers or blueprints!</p>
        <label>Server Name</label>

        <!-- Here Two-Way-Binding is used. -->
        <!-- <input type="text" class="form-control" [(ngModel)]="newServerName"> -->

        <!-- paragraph 74. Example of the use of Local Reference in Templates. -->
        <input type="text" class="form-control" #serverNameInput>

        <label>Server Content</label>
        <!-- Here Two-Way-Binding is used. -->
        <input type="text" class="form-control" [(ngModel)]="newServerContent">

        <br>
        <button class="btn btn-primary" (click)="onAddServer(serverNameInput)">Add Server</button>
        <button class="btn btn-primary" (click)="onAddBlueprint(serverNameInput)">Add Server Blueprint</button>
    </div>
</div>

Local Reference: 
- cockpit.component.html
  - Add with a hashtag '#'.
    - Example:
      <input type="text" class="form-control" #serverNameInput>
        --> #serverNameInput receives data: actually the entire setup of the input field with is a HTMLInputElement.
        - This can be used anywhere in the html-template. However: NOT in the TypeScript.
      Use:
      <button class="btn btn-primary" (click)="onAddServer(serverNameInput)">Add Server</button>

- cockpit.component.ts:

 onAddServer(nameInput: HTMLInputElement) {
    /**
     * The input will be: serverNameInput: [object HTMLInputElement]
     * See The Developer Tool | Console for the log result.
     */
    console.log("serverNameInput: " + nameInput);
    console.log("serverNameInput.value: " + nameInput.value);
    this.serverCreated.emit({
      serverName: nameInput.value,
      serverContent: this.newServerContent
    });
  }

Now no TS instance variable is necessary.

75. @ViewChild() in Angular 8+.

  In Angular 8+, the @ViewChild() syntax which you'll see in the next lecture needs to be changed slightly:

  Instead of:

    @ViewChild('serverContentInput') serverContentInput: ElementRef;

  use

    @ViewChild('serverContentInput', {static: true}) serverContentInput: ElementRef;

  The same change (add { static: true } as a second argument) needs to be applied to ALL usages of @ViewChild() (and also @ContentChild() which you'll learn about later) IF you plan on accessing the selected element inside of ngOnInit().

  If you DON'T access the selected element in ngOnInit (but anywhere else in your component), set static: false instead!

  If you're using Angular 9+, you only need to add { static: true } (if needed) but not { static: false }.


76. Getting Access to the Template & DOM with @ViewChild

Resource:
- https://angular.io/api/core/ViewChild

@ViewChild:
Property decorator that configures a view query. 
The change detector looks for the first element or the directive matching the selector in the view DOM. 
If the view DOM changes, and a new child matches the selector, the property is updated.


Sometimes you want to access data in the html-template before adding it to the method.

- cockpit.component.html:

        <!-- 
            Again a Local Reference will be used, but now in the TS template it will be passed via a @ViewChild variable.
        -->
        <input 
            type="text" 
            class="form-control" 
            #serverContentInput>

        <br>

- cockpit.component.ts:

 /**
   * The use of @ViewChild.
   * This gives access to the DOM and the variables / attributes in the html-template.
   * Circumvents the use of input paramters for the class methods.
   */
  @ViewChild('serverContentInput', {static: true}) serverContentInput: ElementRef;

    console.log("serverContentInput: " + this.serverContentInput);
    this.serverCreated.emit({
      serverName: nameInput.value,
      serverContent: this.serverContentInput.nativeElement.value
    });

Note:
It difficult to determine that you should use '.nativeElement.value'.
When using the logging you see: serverContentInput is of type Object.
Also: because you have access to the complete HtmlInputElement you have more options to access the html-variables.


77.Projecting Content into Components with ng-content.

Resource:
- https://angular.io/guide/content-projection


Another way to send data from html-template to ts-template.


Current:
- server.component.html:

<div class="panel panel-default">
    <div class="panel-heading">{{ element.name }}</div>
    <div class="panel-body">
        <p>
            <strong *ngIf="element.type === 'server'" style="color: red"> {{ element.content }} </strong>
            <em *ngIf="element.type === 'blueprint'"> {{ element.content }} </em>
        </p>
    </div>
</div>

However your might want to use the <p>..</p> at a different, higher level en use the server.component as a more generic component.
In that case:

<div class="panel panel-default">
    <div class="panel-heading">{{ element.name }}</div>
    <div class="panel-body">
      <ng-content></ng-content>
    </div>
</div>

And move the <p>..</p> to a higher level, i.e. app.component.html:

- app.component.html:
  ..
  <div class="row">
    <div class="col-xs-12">
      <!-- Property Binding: TS ==> Output Data ==> HTML -->
      <app-server-element *ngFor="let serverElement of serverElements" [srvElement]="serverElement">
        <p>
          <strong *ngIf="serverElement.type === 'server'" style="color: red"> {{ serverElement.content }} </strong>
          <em *ngIf="serverElement.type === 'blueprint'"> {{ serverElement.content }} </em>
        </p>
      </app-server-element>
    </div>
  </div>
</div>

Note:
- 'element' is now changed to 'serverElement'
- In itself now the content of serverElement is not sent to server-element.component.

In order to mitigate the last problem the directive 'ng-content' is used in server-element.component.html.

Now the element-server.component can potentially be used more than once in a different context.


78. Understanding the Component LifeCycle.

Resource:
- lifecycle.pdf

                      Lifecycle

ngOnChanges           Called after a bound input property changes
                      - This concerns variables decorated with @Input()

ngOnInit              Called once the component is initialized
                      - Not yet part of the DOM, but the object has been created.
                      - It will run after the constructor.

ngDoCheck             Called during every change detection run
                      - e.g. after every event.

ngAfterContentInit    Called after content (ng-content) has been projected into view
                      - A lifecycle hook that is called after Angular has fully initialized all content of a directive. 
                        Define an ngAfterContentInit() method to handle any additional initialization tasks.

ngAfterContentChecked Called every time the projected content has been checked

ngAfterViewInit       Called after the component’s view (and child views) has been initialized

ngAfterViewChecked    Called every time the view (and child views) have been checked

ngOnDestroy           Called once the component is about to be destroyed


79. Seeing Lifecycle Hooks in Action.

For all Lifecycle hooks mentioned in paragraph 78 methods have been created in server-elements.component.ts.
In server-element.component.html and app.component.html changes were made in order to make this work.

The effects will be visible in Developer Tool | Console logging.


80. Lifecycle Hooks and Template Access.


81. @ContentChild() in Angular 8+.

For ContentChild, the same adjustments as for ViewChild apply: 
- https://www.udemy.com/course/the-complete-guide-to-angular-2/learn/lecture/14865241
  --> Paragraph 75.

  In Angular 8+, the @ContentChild() syntax which you'll see in the next lecture needs to be changed slightly:

  Instead of:

    @ContentChild('serverContentInput') serverContentInput: ElementRef;

  use

    @ContentChild('serverContentInput', {static: true}) serverContentInput: ElementRef;

  The same change (add { static: true } as a second argument) needs to be applied to ALL usages of @ContentChild() (and also @ContentChild() which you'll learn about later) IF you plan on accessing the selected element inside of ngOnInit().

  If you DON'T access the selected element in ngOnInit (but anywhere else in your component), set static: false instead!

  If you're using Angular 9+, you only need to add { static: true } (if needed) but not { static: false }.


82. Getting Access to ng-content with @ContentChild.

The description is present in the application: cmp-databinding-start.

- app-component.html:

        <!-- 
          Again a Local Reference but now it will not be linked to the TS file app.component.ts 
          but to the child-component TS server-element.component.ts.
          There we need to use @ContentChild() instead of @ViewChild().
        -->
        <p #contentParagraph>
          <strong *ngIf="serverElement.type === 'server'" style="color: red"> {{ serverElement.content }} </strong>
          <em *ngIf="serverElement.type === 'blueprint'"> {{ serverElement.content }} </em>
        </p>

- server-element.component.ts:

 // 82. Getting Access to ng-content with @ContentChild.
  @ContentChild('contentParagraph') paragraph: ElementRef;

/**
Initially the paragraph will not be filled.
First from app.component.ts needs to be added: 
serverElements = [ {type: 'server', name: 'TestServer', content: 'Just a test'} ];

Therefore in Developer Tool | Console the variable paragraph will be empty.

*/
  ngOnInit(): void {
    console.log('ServerElementComponent ngOnit() called.');
    console.log("ServerElementComponent: ngOnInit()): Textcontent: " + this.header.nativeElement.textContent);
    if (typeof this.paragraph === 'undefined' ) {
      console.log('ServerElementComponent: ngOnInit()): Textcontent of paragraph: Empty');
    } else {
      console.log('ServerElementComponent: ngOnInit()): Textcontent of paragraph: ' + this.paragraph.nativeElement.textContent);
    }
  }

/**
Afer running the loop in app.component.html:

      <app-server-element 
        *ngFor="let serverElement of serverElements" 

Now the variable paragraph in server-element.component.ts will contain data.

*/

  ngAfterContentInit(): void {
    console.log('ngAfterContentInit called.');
    console.log('ServerElementComponent: ngOnInit()): Textcontent of paragraph: ' + this.paragraph.nativeElement.textContent);
  }


83. Wrap Up.


Assignment 4. Practicing Property & Event Binding and View Encapsulation.

Instructions:

Questions for this assignment
Please complete the tasks outlined in the instructions video. 
- Why did you choose the approach you took? 
- Which problems did you encounter?

Application:
assignment3-cmp-databinding

A normal start of a new app:

$ ng new assignment3-cmp-databinding --no-strict
  ? Would you like to add Angular routing?  N
  Choose CSS styling

Go to the root directory of the application:
$ ng serve

--> look at http://localhost:4200/

I have created: assignment3-cmp-databinding

How to install:

$ cd /Users/rkremers/Development/workspaceJS/Angular/assignment3-cmp-databinding
$ npm install --save bootstrap@3

This will download bootstrap locally. Not globally.

added 1 package, removed 1 package, and audited 1015 packages in 2s

90 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities

Will install in the node_modules folder.

Now make Angular aware of this styling package.
- angular.json file.

            "styles": [
              "node_modules/bootstrap/dist/css/bootstrap.min.css", !! bootstrap.min.css has been added here.
              "src/styles.css"
            ],

Add FormsModule to app.module.ts

Go to the root directory of the application:
$ ng serve


In a second terminal generate new components:
$ ng generate component recipes --spec false
--> the option --spec false is outdated.

Instead:

$ ng generate component GameControl --skip-tests
$ ng generate component Odd --skip-tests
$ ng generate component Even --skip-tests

0. Create a new application
$ npm install --save bootstrap@3
Now make Angular aware of this styling package.
- angular.json file.

            "styles": [
              "node_modules/bootstrap/dist/css/bootstrap.min.css", !! bootstrap.min.css has been added here.
              "src/styles.css"
            ],
Add FormsModule to app.module.ts
import { FormsModule } from '@angular/forms';
..
  imports: [
    BrowserModule,
    FormsModule
  ],
..
1. Create three new components: GameControl, Odd and Even
2. The GameControl Component should have buttons to start and stop the game
  - Stop Button:
    - Clear the interval, so reset.
3. When starting the game, an event (holding a incrementing number) should get emitted each second (ref = setInterval())
- You can use the built-in JS function setInterval()
  - Google this.
4. The event should be listenable from outside the component
5. When stopping the game, no more events should get emitted (clearInterval(ref))
6. A new Odd component should get created for every odd number emitted, the same should happen for the Even Component (on even numbers)
7. Simply output Odd - NUMBER or Even - NUMBER in the two components
8. Style the element (e.g. paragraph) holding your output text differently in both components

Task:
- To continuously emit new events.
- You can use the built-in JS function setInterval()
  - Google this.
- Store a reference to this interval into a property.

https://www.codegrepper.com/code-examples/javascript/frameworks/ionic/setinterval+in+angular

ngOnInit() {
  this.battleInit();
  this.id = setInterval(() => {
    this.battleInit(); 
  }, 5000);
}

ngOnDestroy() {
  if (this.id) {
    clearInterval(this.id);
  }
}

$ ng serve 
An unhandled exception occurred: require() of ES Module /Users/rkremers/Development/workspaceJS/Angular/assignment3-cmp-databinding/node_modules/@angular/compiler-cli/bundles/index.js from /Users/rkremers/Development/workspaceJS/Angular/assignment3-cmp-databinding/node_modules/@angular-devkit/build-angular/node_modules/@ngtools/webpack/src/angular_compiler_plugin.js not supported.

Instead change the require of index.js in /Users/rkremers/Development/workspaceJS/Angular/assignment3-cmp-databinding/node_modules/@angular-devkit/build-angular/node_modules/@ngtools/webpack/src/angular_compiler_plugin.js to a dynamic import() which is available in all CommonJS modules.
See "/private/var/folders/t4/7fbd31bn2gx7547s9lscm9h00000gp/T/ng-hXISj8/angular-errors.log" for further details.


assignment3-cmp-databinding.
- Implemented.

2

4

6

8

2

4

1

3

5

7

1

3

5

I had difficulty in implementing the correct way to define the interval counter. I found different ways but none worked perfectly.
I also had difficulty when defining  'intervalTimer' in game-control.component.ts. I could not add a type other than 'any'.

The problem is that because two components (Even and Odd) have been defined they do not stack up under each other.
Rather they rearrange in two lists: an even and an odd numbers list in ascending order.

Extra info:
- https://angular.io/guide/inputs-outputs


===================================================================================================
2022-01-17:

Section 6. Course Project - Components & Databinding


85. Introduction.

86. Adding Navigation with Event Binding and ngIf.

- Start here to hook up navigation.
  - Load either the Recipes or the Shopping-List.
  - Use *ngIf to load only one of the two sections at a time.

Task:
- Determine which component should be exposed.

Setup:
- In header.component
  - html
            <ul class="nav navbar-nav">
                <li><a href="#" (click)="onSelect('recipes')">Recipes</a></li>
                <li><a href="#" (click)="onSelect('shopping-list')">Shopping List</a></li>
            </ul>
  - ts
    @Output() chosenItem = new EventEmitter<string>();

    onSelect(chosenItem: string ) {
        this.chosenItem.emit(chosenItem);
    }

- app.component
  - html
    <div class="col-md-12">
      <app-recipes *ngIf="chosenItem === 'recipes'"></app-recipes>
      <hr>
      <app-shopping-list *ngIf="chosenItem == 'shopping-list'"></app-shopping-list>
    </div>
  - ts
    visibleItem: string;
    onItemChosen(item: string) {
      this.visibleItem = item;
    }

--> Okay: added.


87. Passing Recipe Data with Property Binding.

[property]="data"

- recipe-list.component.html:
<div class="row">
    <!-- 
        The recipes are received from this component recipe-list.component.ts.
        The recipes are hard-coded.
        Binding to custom properties (@Input()) is used in recipe-item.component.

        Property Binding is used to send the data to recipe-item.ts: 
        @Input() recipe: Recipe;
    -->
    <div class="col-xs-12">
        <app-recipe-item 
        *ngFor="let recipeElement of recipes"
        [recipe]="recipeElement"
        ></app-recipe-item>
    </div>
</div>

- recipe-item.component
  - Functionality:
    - Shows a recipe.
    - The recipes are received from parent recipe-list.component via Property Binding & @Input().
    - THe recipe content is shown via Property Binding and String Interpolation.
  - html:
    <a href="#" class="list-group-item clearfix">
        <div class="pull-left">
            <h4 class="list-group-item-heading">{{ recipe.name }}</h4>
            <p class="list-group-item-text">{{ recipe.description }}</p>
        </div>
        <span class="pull-right">
            <!-- 
                Both String Interpolation and Property Binding are correct.  
                The course leader chose to use Property Binding for src. For alt String Interpolation is used.
            -->
            <img [src]="recipe.imagePath" alt="{{ recipe.description }}" class="img-responsive" style="max-height:50px;">
        </span>
    </a>
  - ts:
      @Input() recipe: Recipe;


88. Passing Data with Event and Property Binding.

Task:
- Add the ability to click on a single recipe-item and load it into the recipe detail section.
  - Emit an event on recipe-item to the parent-component recipes-component and send further to the recipe-detail-component.
  - In the recipe-detail-component the description, etc. needs to be filled in.
  - Use Property- and event-binding for this.

Setup:
<app-recipe-item> ==> <app-recipe-list> ==> <app-recipes *ngIf="chosenItem === 'recipes'"> ==> <app-recipe-detail>

In general the same setup as described in paragraph 87.


89. Make sure you have FormsModule added!

One quick note: 
In case you're hitting an error in the next lecture, make sure you have FormsModule added to your imports[] in the AppModule. 
Also have a look at the following Q&A thread for more info: https://www.udemy.com/the-complete-guide-to-angular-2/learn/v4/questions/4924644


90. Allowing the User to Add Ingredients to the Shopping List.

Use Local Reference.


===================================================================================================
2022-01-18:

Section 7: Directives Deep Dive.

91. Module Introduction.

Attribute vs Structural Directives

- Attribute Directives sit on elements, just like attributes.
  - Look like a normal HTML Attribute, possibly with databinding or event binding.
  - Only affect / change the element they are added to.
- Structural Directives basically also sit on elements but also change the structure of the DOM around it.
  - Look like a normal HTML attribute but have a leading '*' (for desugaring).
  - Affect a whole area in the DOM (elements are added / removed).


Application: directives-start

$ ng new directives-start --no-strict
  ? Would you like to add Angular routing?  N
  Choose CSS styling

Go to the root directory of the application:
$ ng serve

--> look at http://localhost:4200/

I have created: directives-start

How to install:

$ cd /Users/rkremers/Development/workspaceJS/Angular/directives-start
$ npm install --save bootstrap@3

This will download bootstrap locally. Not globally.

added 1 package, removed 1 package, and audited 1015 packages in 2s

90 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities

Will install in the node_modules folder.

Now make Angular aware of this styling package.
- angular.json file.

            "styles": [
              "node_modules/bootstrap/dist/css/bootstrap.min.css", !! bootstrap.min.css has been added here.
              "src/styles.css"
            ],

Add FormsModule to app.module.ts

Go to the root directory of the application:
$ ng serve --port 4203

--> For this section we will use directives-start


The code has been added.
Todo:
- Check again ng-template before moving ahead.

https://angular.io/api/core/ng-template
- With <ng-template>, you can define template content that is only being rendered by Angular when you, whether directly or indirectly, specifically instruct it to do so, allowing you to have full control over how and when the content is displayed.
- One of the main uses for <ng-template> is to hold template content that will be used by Structural directives.


92. ngFor and ngIf Recap.

https://angular.io/guide/structural-directives
- ngFor and ngIf are structural directives.

Note:
Can't have multiple template bindings on one element. Use only one attribute prefixed with *.

So this would fail:

        <li
          class="list-group-item"
          *ngFor="let number of numbers; let i = index"
          *ngIf="number % 2 === 0" !!!!!! Only one structural directive is allowed per element.
          >

93. ngClass and ngStyle recap.

https://angular.io/guide/attribute-directives
- ngClass and ngStyle are attribute directives.

https://blog.angular-university.io/angular-ngclass-ngstyle/

Summary

There are a ton of options to style our components using ngClass and ngStyle, so it's important to know which one to use when and why. Here is a short summary:

- most styles can be added simply to the HTML directly, for those we can simply add them to the class property, and no special Angular functionality is needed
- Many state styles can be used using browser-supported pseudo-class selectors such as :focus, we should prefer those conventional solutions for those cases
- for state styles that don't have a pseudo-class selector linked to it, its best to go with ngClass
- if the ngClass expressions get too big, it's a good idea to move the calculation of the styles to the component class
- only for situations where we have a dynamically calculated embedded style should we use ngStyle, this should be rarely needed


https://stackoverflow.com/questions/26919963/what-is-the-difference-between-ng-class-and-ng-style
  Theoretically they both are different, but practically at some point they both become same
  ngStyle is used to add style dynamically at run time and
  ngClass is used to add some class dynamically at run time but class also holds some css content, so indirectly you are also adding css here dynamically


94. Creating a Basic Attribute Directive.


https://angular.io/guide/structural-directives
- Create a new directive:
  $ ng generate directive <name>

$ ng generate directive basic-highlight/basic-highlight

Result:
- app.module.ts
import { BasicHighlightDirective } from './basic-highlight/basic-highlight.directive';

@NgModule({
  declarations: [
    AppComponent,
    BasicHighlightDirective
  ],
..

- basic-highlight.ts
import { Directive } from '@angular/core';
export class BasicHighlightDirective implements OnInit {

  /**
   * 
   * @param elementRef The element the directive is placed on.
   */
  constructor(private elementRef: ElementRef) { }

  ngOnInit() {
    this.elementRef.nativeElement.style.backgroundColor = 'green';
    this.elementRef.nativeElement.style.color = 'yellow';
  }

}

- basic-highlight.spec.ts

import { BasicHighlightDirective } from './basic-highlight.directive';

describe('BasicHighlightDirective', () => {
  it('should create an instance', () => {
    const directive = new BasicHighlightDirective();
    expect(directive).toBeTruthy();
  });
});


95. Using the Renderer to build a Better Attribute Directive.


According to the course leader the above mentioned implementation is not best practice.
Angular is able to render your templates without a DOM.

$ ng generate directive better-highlight/better-highlight ----skip-tests

CREATE src/app/better-highlight/better-highlight.directive.ts (159 bytes)
UPDATE src/app/app.module.ts (613 bytes)


96. More about the Renderer.

In the last lecture, we used the Angular Renderer class to change the style of a HTML element. 
As explained in that lecture, you should use the Renderer for any DOM manipulations.

Of course, you can do more than simply change the styling of an element via setStyle(). 
Learn more about the available Renderer methods here:
- https://angular.io/api/core/Renderer2
  - API Documentation

API > @angular/core
mode_edit code
Renderer2
class

Extend this base class to implement custom rendering. 
By default, Angular renders a template into DOM. 
You can use custom rendering to intercept rendering calls, or to render to something other than DOM.


97. Using HostListener to Listen to Host Events.

Implementation:


import { Directive, OnInit, Renderer2, ElementRef, HostListener } from '@angular/core';

@Directive({
  selector: '[appEvenBetterHighlight]'
})
/**
 * This class will provide a color dynamically when the mouse hovers over the element.
 * Used: Renderer2 and HostListener.
 * 
 */
export class EvenBetterHighlightDirective implements OnInit {

  constructor(private elementRef: ElementRef, private renderer: Renderer2) { }

  ngOnInit(): void {
    // this.renderer.setStyle(this.elementRef.nativeElement, 'background-color', 'blue');
    // this.renderer.setStyle(this.elementRef.nativeElement, 'color', 'yellow');
  }

  /**
   * Purpose:
   * Change the background color when a mouse hovers over the element.
   * 
   * Functionality:
   * @HostListener is triggered when some event occurs. This is specified as input parameter.
   * In this case 'mouseenter' is used as event.
   */
  @HostListener('mouseenter') mouseOver(eventData: Event) {
    this.renderer.setStyle(this.elementRef.nativeElement, 'background-color', 'blue');
    this.renderer.setStyle(this.elementRef.nativeElement, 'color', 'yellow');
  }

  @HostListener('mouseleave') mouseLeave(eventData: Event) {
    this.renderer.setStyle(this.elementRef.nativeElement, 'background-color', 'transparent');
    this.renderer.setStyle(this.elementRef.nativeElement, 'color', 'black');
  }

}


Effect:
- app.component.html
  ..
  <p appEvenBetterHighlight>Style me with an even better directive using Renderer2! Only becomes blue if the mouse hovers over it.</p>
  ..

Further examples:
- https://www.codegrepper.com/code-examples/javascript/angular+mouseenter


98. Using HostBinding to Bind to Host Properties.

An even easier way to change the background color if that is everything we want to do.

import { Directive, OnInit, HostListener, HostBinding } from '@angular/core';

@Directive({
  selector: '[appHostbindingBetterHighlight]'
})
export class HostbindingBetterHighlightDirective implements OnInit {
  /**
   * HostBinding functionality:
   * We can pass a string, defining to which property of the hosting element we want to bind.
   * We are binding to the DOM property.
   * 
   * Of course the element should be available on the element.
   */
  @HostBinding('style.backgroundColor') backgroundColor: string = 'transparent';
  @HostBinding('style.color') letterColor: string  = 'black';

  constructor() { }

  ngOnInit(): void {
  }

  /**
   * Purpose:
   * Change the background color when a mouse hovers over the element.
   * 
   * Functionality:
   * @HostListener is triggered when some event occurs. This is specified as input parameter.
   * In this case 'mouseenter' is used as event.
   */
  @HostListener('mouseenter') mouseOver(eventData: Event) {
    // this.renderer.setStyle(this.elementRef.nativeElement, 'background-color', 'blue');
    this.backgroundColor = 'blue';
    // this.renderer.setStyle(this.elementRef.nativeElement, 'color', 'yellow');
    this.letterColor = 'yellow';
  }

  @HostListener('mouseleave') mouseLeave(eventData: Event) {
    // this.renderer.setStyle(this.elementRef.nativeElement, 'background-color', 'transparent');
    this.backgroundColor = 'transparent';
    // this.renderer.setStyle(this.elementRef.nativeElement, 'color', 'black');
    this.letterColor = 'black';
  }
}

Effect:
..
<p appHostbindingBetterHighlight>Style me using HostBinding! Only becomes blue if the mouse hovers over it.</p>
..


99. Binding to Directive Properties.

hostbinding-better-highlight.directive.ts:

import { Directive, OnInit, HostListener, HostBinding, Input } from '@angular/core';

@Directive({
  selector: '[appHostbindingBetterHighlight]'
})
export class HostbindingBetterHighlightDirective implements OnInit {
  @Input() defaultBackgroundColor: string = 'transparent';
  @Input() highlightBackgroundColor: string = 'blue';

  @Input() defaultLetterColor: string = 'black';
  @Input() highlightLetterColor: string = 'yellow';
  /**
   * HostBinding functionality:
   * We can pass a string, defining to which property of the hosting element we want to bind.
   * We are binding to the DOM property.
   * 
   * Of course the element should be available on the element.
   */
  @HostBinding('style.backgroundColor') backgroundColor: string;
  @HostBinding('style.color') letterColor: string  = 'black';

  constructor() { }

  ngOnInit(): void {
    this.backgroundColor = this.defaultBackgroundColor;
    this.letterColor = this.defaultLetterColor;
  }

  /**
   * Purpose:
   * Change the background color when a mouse hovers over the element.
   * 
   * Functionality:
   * @HostListener is triggered when some event occurs. This is specified as input parameter.
   * In this case 'mouseenter' is used as event.
   */
  @HostListener('mouseenter') mouseOver(eventData: Event) {
    this.backgroundColor = this.highlightBackgroundColor;
    this.letterColor = this.highlightLetterColor;
  }

  @HostListener('mouseleave') mouseLeave(eventData: Event) {
    this.backgroundColor = this.defaultBackgroundColor;
    this.letterColor = this.defaultLetterColor;
  }
}

app.component.html:
..
      <!-- 
        Angular will first look at custom Binding Properties before it will look at the standard properties of the paragraph <p>
      -->
      <p appHostbindingBetterHighlight
        [defaultBackgroundColor]="'yellow'"
        [highlightBackgroundColor]="'orange'"
        [defaultLetterColor]="'black'"
        [highlightLetterColor]="'yellow'"
        >Style me using HostBinding! Only becomes blue if the mouse hovers over it.</p>
..


For the situation that it nonetheless becomes confusing an alias can be used.
e.g. if [ngClass] is used.
Only use this if the standard selector has the same name as the custom selector.

In the above snippet example Property Binding is being used.

[defaultBackgroundColor]="'yellow'"

In this special case, with double-quotes and single-quotes you can also use:

defaultBackgroundColor="yellow'"


100. What Happens behind the Scenes on Structural Directives.


Explanation why structural directives, like ngIf, ngFor have a '*' in advance in the code:

Example:

app.component.html:

        <div *ngIf="onlyOdd">
          <li 
            class="list-group-item" 
            [ngClass]="{odd: number % 2 !== 0}"
            [ngStyle]="{backgroundColor: number % 2 !== 0 ? 'yellow' : 'transparent'}"
            *ngFor="let number of oddNumbers; let i = index">
            {{ number }}
          </li>
        </div>

Behind the scene Angular will transform them into something else.
There is only:

  Databinding = Communication

  Backend <==> TypeScript Code (Business Logic) <==> Template (HTML)

  TS ==> Output Data ==> HTML
  - String Interpolation  : {{ data }}
  - Property Binding      : [property]="data"

  TS <== React to (User) Events <== HTML
  - Event Binding     : (event)="expression"

  Combination of both: 
  - Two-Way-Binding     : [(ngModel)]="data"

So *ngIf, etc. is rewritten by the Angular compiler when converting to JS.


app.component.html:

What we write:

        <div *ngIf="!onlyOdd">
          <li 
            class="list-group-item" 
            [ngClass]="{even: number % 2 === 0}"
            [ngStyle]="{backgroundColor: number % 2 === 0 ? 'cyan' : 'transparent'}"
            *ngFor="let number of evenNumbers; let i = index">
            {{ number }}
          </li>
        </div>

What will actually happen (but now the actual code.)
        <!-- 
          100. What Happens behind the Scenes on Structural Directives.  
          ng-temmplate is an element is itself not rendered but will be rendered, based on some condition.

          In the following 'ngIf' is not preceded by a star, because it is the form to which it will be transformed
          due to the star at the place where '*ngIf' is calling this functionality.

          Under the hood this is what *ngIf actually does anyway.
        -->
        <ng-template [ngIf]="!onlyOdd">
          <div>
            <li 
            class="list-group-item" 
            [ngClass]="{even: number % 2 === 0}"
            [ngStyle]="{backgroundColor: number % 2 === 0 ? 'cyan' : 'transparent'}"
            *ngFor="let number of evenNumbers; let i = index">
            {{ number }}
          </li>            
          </div>
        </ng-template>

101. Building a Structural Directive.

As opposed to an Attribute Directive now create a Structural Directive:

https://angular.io/guide/structural-directives
https://angular.io/guide/structural-directives#creating-a-structural-directive

$ ng generate directive directives/unless/unless --skip-tests CREATE src/app/directives/unless/unless.directive.ts (141 bytes)
UPDATE src/app/app.module.ts (728 bytes)

https://angular.io/guide/template-syntax
- In Angular, a template is a chunk of HTML. Use special syntax within a template to build on many of Angular's features.
  - Each Angular template in your application is a section of HTML to include as a part of the page that the browser displays. 
    An Angular HTML template renders a view, or user interface, in the browser, just like regular HTML, but with a lot more functionality.
  - When you generate an Angular application with the Angular CLI, the app.component.html file is the default template containing placeholder HTML.
  - When looking looking at the snippet below the template is now formed by a paragraph: <p>.


      <p *appUnless="condition" class="unless a">
        (A) This paragraph is displayed because the condition is false.
      </p>
      
      <p *appUnless="!condition" class="unless b">
        (B) Although the condition is true,
        this paragraph is displayed because appUnless is set to false.
      </p>
      <hr>
      <p>
        The condition is currently
        <span [ngClass]="{ 'a': !condition, 'b': condition, 'unless': true }">{{condition}}</span>.
        <button
          (click)="condition = !condition"
          [ngClass] = "{ 'a': condition, 'b': !condition }" >
          Toggle condition to {{condition ? 'false' : 'true'}}
        </button>
      </p>

unless.directive.ts


import { Directive, Input, TemplateRef, ViewContainerRef } from '@angular/core';

@Directive({
  selector: '[appUnless]'
})
/**
 * Purpose:
 * The UnlessDirective creates an embedded view from the Angular-generated <ng-template> 
 * and inserts that view in a view container adjacent to the directive's original <p> host element.
 * 
 * Functionality:
 * - TemplateRef      : allows access to the <ng-template> contents.
 *                      Represents an embedded template that can be used to instantiate embedded views. 
 *                      To instantiate embedded views based on a template, use the ViewContainerRef method createEmbeddedView().
 *                      - Determines what will be shown.
 * - ViewContainerRef : allows access to the view.
 *                      Represents a container where one or more views can be attached to a component.
 *                      - Determines how it will be shown.
 * 
 * Documentation:
 * - https://angular.io/guide/structural-directives#creating-a-structural-directive
 * - https://angular.io/guide/template-syntax
 * 
 */
export class UnlessDirective {
  hasView: boolean = false;

  constructor(
    /**
     * TemplaeRef gives access to a Template.
     */
    private templateRef: TemplateRef<any>,
    private viewContainer: ViewContainerRef) { }

  /**
   * Angular sets the appUnless property whenever the value of the condition changes.
   * If the condition is false and Angular hasn't created the view previously, 
   * the setter causes the view container to create the embedded view from the template.
   * If the condition is true and the view is currently displayed, the setter clears the container, which disposes of the view.
   * 
   * 'set' turns the property into a method.
   * 
   * @Input() is used because Property Binding is being used.
   * The name of the method needs to be the same the name of the selector. Otherwise it will not be a known property.
   * Reason: we try to bind to the selector, via Property Binding.
   * 
   */
  @Input() set appUnless(condition: boolean) {
    if (!condition && !this.hasView) {
      this.viewContainer.createEmbeddedView(this.templateRef);
    } else if (condition && this.hasView) {
      this.viewContainer.clear();
      this.hasView = false;
    }
  }

}

102. Understanding ngSwitch.

Resource:
- https://angular.io/api/common/NgSwitch

The [ngSwitch] directive on a container specifies an expression to match against. 
The expressions to match are provided by ngSwitchCase directives on views within the container.


===================================================================================================
Section 8: Course Project - Directives

103. Building and Using a Dropdown Directive.


$ ng generate directive shared/dropdown --skip-tests
CREATE src/app/shared/dropdown.directive.ts (145 bytes)
UPDATE src/app/app.module.ts (1207 bytes)

https://www.codegrepper.com/code-examples/javascript

The implementation as given by the course leader is considerably more simple:

shared/dropdown.directive.ts:

import { Directive, HostBinding, HostListener } from '@angular/core';

@Directive({
  selector: '[appDropdown]'
})
/**
 * Purpose:
 * Add a certain css class to the element it sits on once it is clicked and remove it if it is clicked again.
 * So:
 * - Implement clicks
 * - Toggle via a caret
 * - Choose one of the items.
 */
export class DropdownDirective {
  /**
   * HostBinding functionality:
   * We can pass a string, defining to which (css) property of the hosting element we want to bind.
   * We are binding to the DOM property.
   * 
   * Of course the element should be available on the element.
   * The variable isOpen should be bound to class.open.
   * - If true: the dropdown list will switch open.
   * - If false: the dropdown list will close.
   * Example:
   * <div class="btn-group open"> in recipe-detail.component.html.
   */
  @HostBinding('class.open') isOpen: boolean = false;

  constructor() { }

  @HostListener('click') toggleOpen() {
    this.isOpen = !this.isOpen;
  }

}

header.component.html:

<ul class="nav navbar-nav navbar-right">
                <li class="dropdown" appDropdown>
                    <a href="#" class="dropdown-toggle" role="button">Manage<span class="caret"></span></a>
                    <ul class="dropdown-menu">
                        <li><a href="#">Save Data</a></li>
                        <li><a href="#">Fetch Data</a></li>
                    </ul>
                </li>
            </ul>

recipe-detail.component.html:

        <div class="col-xs-12">
            <!-- 
                <div class="btn-group open"> would set the dropdown list to 'open'.
            -->
            <div 
                class="btn-group"
                appDropdown
                >
                <button 
                    type="button" 
                    class="btn btn-primary dropdown-toggle">
                    Manage Recipe <span class="caret"></span>
                </button>
                <ul class="dropdown-menu">
                    <li><a href="#">To Shopping List</a></li>
                    <li><a href="#">Edit Recipe</a></li>
                    <li><a href="#">Delete Recipe</a></li>
                </ul>
            </div>            
        </div>


104. Closing the Dropdown From Anywhere.

If you want that a dropdown can also be closed by a click anywhere outside (which also means that a click on one dropdown closes any other one, btw.), replace the code of dropdown.directive.ts by this one (placing the listener not on the dropdown, but on the document):

import {Directive, ElementRef, HostBinding, HostListener} from '@angular/core';
 
@Directive({
  selector: '[appDropdown]'
})
export class DropdownDirective {
  @HostBinding('class.open') isOpen = false;

  @HostListener('document:click', ['$event']) toggleOpen(event: Event) {
    this.isOpen = this.elRef.nativeElement.contains(event.target) ? !this.isOpen : false;
  }
  constructor(private elRef: ElementRef) {}
}


Note:
As an alternative for this Angular functionality:

services-start:
- new-account.component.html:

        <div class="form-group">
            <select class="form-control" #status>
                <option value="active">Active</option>
                <option value="inactive">Inactive</option>
                <option value="hidden">Hidden</option>
            </select>
        </div>

  - This functionality will show a drop-down list and the value will be added to parameter #status (Local Reference).

This will be picked up later:

        <button class="btn btn-primary" (click)="onCreateAccount(accountName.value, status.value)">
            Add Account
        </button>


===================================================================================================
2022-01-20:

Section 9: Using Services & Dependency Injection.

105. Module Introduction.

Test application: services-start

Example of Services:
- Log data to console : LogService
- Store user data     : UserService

Todo:
- Create the services-start app.

Application: services-start

$ ng new services-start --no-strict
  ? Would you like to add Angular routing?  N
  Choose CSS styling

Go to the root directory of the application:
$ ng serve

--> look at http://localhost:4204/

I have created: services-start

How to install:

$ cd /Users/rkremers/Development/workspaceJS/Angular/services-start
$ npm install --save bootstrap@3

This will download bootstrap locally. Not globally.

added 1 package, removed 1 package, and audited 1015 packages in 2s

90 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities

Will install in the node_modules folder.

Now make Angular aware of this styling package.
- angular.json file.

            "styles": [
              "node_modules/bootstrap/dist/css/bootstrap.min.css", !! bootstrap.min.css has been added here.
              "src/styles.css"
            ],

Add FormsModule to app.module.ts

Go to the root directory of the application:
$ ng serve --port 4204

--> For this section we will use services-start

$ ng generate component account --skip-tests
CREATE src/app/account/account.component.css (0 bytes)
CREATE src/app/account/account.component.html (22 bytes)
CREATE src/app/account/account.component.ts (279 bytes)
UPDATE src/app/app.module.ts (463 bytes)

$ ng generate component new-account --skip-tests
CREATE src/app/new-account/new-account.component.css (0 bytes)
CREATE src/app/new-account/new-account.component.html (26 bytes)
CREATE src/app/new-account/new-account.component.ts (294 bytes)
UPDATE src/app/app.module.ts (563 bytes)

Analysis of services-start:
- Here and there descriptions have been added.



106. Why would you need Services?

Todo:
Double check this setup: Make a schema in order to understand this app.


107. Creating a Logging Service.

Replace in account.component.ts and new-account-component.ts:

console.log('A server status changed, new status: ' + accountStatus);

Create:
- logging.service.ts

$ ng generate service logging --skip-tests

CREATE src/app/logging.service.ts (136 bytes)

logging.service.ts:

mport { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class LoggingService {

  constructor() { }
}

WRONG METHOD:

import { LoggingService } from '../logging.service';

export class NewAccountComponent implements OnInit {
  ..

  logService: LoggingService = new LoggingService();

  onCreateAccount(accountName: string, accountStatus: string) {
    ..
    this.logService.logStatusChange(accountStatus);

  }

108. Injecting the Logging Service into Components.

Dependency Injector:
- An object, functionality a class will depend on.

Hierarchical Injector:
- We should not instantiate the LoggingService. Instead Angular will do it. But Angular needs to know how to instantiate.
  - Import:
    import { LoggingService } from '../logging.service';
  
  - Create a private instance of the LoggingService:
    constructor(private logService: LoggingService) { }
  
  - Tell Angular how to instantiate the instance:
    providers: [LoggingService]


new-account.component.ts:

import { Component, EventEmitter, OnInit, Output } from '@angular/core';
import { LoggingService } from '../logging.service';

@Component({
  selector: 'app-new-account',
  templateUrl: './new-account.component.html',
  styleUrls: ['./new-account.component.css'],
  providers: [LoggingService]
})
export class NewAccountComponent implements OnInit {
  @Output() accountAdded = new EventEmitter<{name: string, status: string}>();

  constructor(private logService: LoggingService) { }

  ngOnInit(): void {
  }

  onCreateAccount(accountName: string, accountStatus: string) {
    this.accountAdded.emit({
      name: accountName,
      status: accountStatus
    });
    this.logService.logStatusChange(accountStatus);
  }
}


109. Creating a Data Service.

$ ng generate service accounts --skip-tests

CREATE src/app/accounts.service.ts (137 bytes)

An array is a reference type.


110. Understanding the Hierarchical Injector.

Resource:
- https://angular.io/guide/hierarchical-dependency-injection

The Angular injector is a Hierarchical Injector.
That means that a component and all it's child-components will receive the same instance of the Injector.
The highest component in the hierarchy is the AppModule component.
- If the service is provided there the same instance of the service will be available in all components.
The next level is the AppComponent.
- The same instance of a service is available for all Components but not for other Services.
Any other Component:
- The same instance of a service is available for the Component and all it's child components.
- The instance of a service injected here would override the instances that were injected at a higher level.


111. How many instances of Service should it be?

In this situation (application services-start) we want only one instance of AccountsService.

112. Injecting Sevices into Services.


113. Using Services for Cross-Component Communication.

Example:

- accounts.service.ts:

statusUpdated = new EventEmitter<string>();

- account.component.ts:

  onSetTo(status: string) {
    this.accountsService.updateStatus(this.id, status);
    this.accountsService.statusUpdated.emit(status); !!!! The status is sent !!!!
  }

- new-account.component.ts:

  constructor(
    private accountsService: AccountsService
  ) {
    this.accountsService.statusUpdated.subscribe(
      (status: string) => alert('New Status: ' + status) !!!! An alert is activated.
    );
  }

This is an example of Cross-Component Communication.


114. Services in Angular 6+.

If you're using Angular 6+ (check your package.json  to find out), you can provide application-wide services in a different way.

Instead of adding a service class to the providers[]  array in AppModule , you can set the following config in @Injectable() :

@Injectable({providedIn: 'root'})
export class MyService { ... }
This is exactly the same as:

export class MyService { ... }
and

import { MyService } from './path/to/my.service';
 
@NgModule({
    ...
    providers: [MyService]
})
export class AppModule { ... }
Using this new syntax is completely optional, the traditional syntax (using providers[] ) will still work. The "new syntax" does offer one advantage though: Services can be loaded lazily by Angular (behind the scenes) and redundant code can be removed automatically. This can lead to a better performance and loading speed - though this really only kicks in for bigger services and apps in general.


Assisgnment 5: Practicing Services.


Time to practice the usage of Services. You're going to build, inject and use your own Services. Make sure you get the instance management right!


Solution: services-assignment-solution

Start: services-assignment-start

Test application: services-assignment-start

Todo:
- Create the services-start app.

Application: services-start

$ ng new services-assignment-start --no-strict
  ? Would you like to add Angular routing?  N
  Choose CSS styling

Go to the root directory of the application:
$ ng serve

--> look at http://localhost:4205/

I have created: services-start

How to install:

$ cd /Users/rkremers/Development/workspaceJS/Angular/services-assignment-start
$ npm install --save bootstrap@3

This will download bootstrap locally. Not globally.

added 1 package, removed 1 package, and audited 1015 packages in 2s

90 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities

Will install in the node_modules folder.

Now make Angular aware of this styling package.
- angular.json file.

            "styles": [
              "node_modules/bootstrap/dist/css/bootstrap.min.css", !! bootstrap.min.css has been added here.
              "src/styles.css"
            ],

Add FormsModule to app.module.ts

Go to the root directory of the application:
$ ng serve --port 4205

--> For this section we will use services-start

$ ng generate component active-users --skip-tests
$ ng generate component inactive-users --skip-tests


Assignment 5:
- Use services:
  - Add a UsersService to handle the active / inactive users.
  - Add a CounterService that increases whenever the users are activated / inactivated.

Questions for this assignment
Please complete the tasks outlined in the instructions video. Why did you choose the approach you took? Which problems did you encounter?

Create:

$ ng generate service active-users --skip-tests
$ ng generate service inactive-users --skip-tests


Add UsersService and CounterService to app.module.ts.

  providers: [UsersService, CounterService],

Add the accounts and the methods onSetToInactive() and onSetToActive() to the UsersService class.
- Purpose: Now there will be one source (okay: in this simple example that was already the case).

Works. No problems.

The services are added to providers in app.module.ts.
Reason:
In all child-components the same instances need to be used.


===================================================================================================
2022-01-20:

Section 10: Course Project - Services & Dependency Injection.

116. Introduction.

117. Setting up the Services.

$ ng generate service recipes/recipe --skip-tests
- Take the content from RecipeListComponent.

$ ng generate service shopping-list/shopping-list --skip-tests
- Take the content from ShoppingListComponent

We should place these services in the folder holding the feature they belong to.


118. Managing Recipes in a Recipe Service.

app/recipes/recipe.service.ts:

  import { Injectable } from '@angular/core';
  import { Recipe } from './recipe.model';

  /**
   * Purpose:
   * Manage the recipes.
   * 
   * Again: Adding decorator Injector is common practice in the later Angular versions, 
   * but actually it is only necessary if you inject something here.
   */
  @Injectable({
    providedIn: 'root'
  })
  export class RecipeService {
    private recipes: Recipe[] = [
      new Recipe("Test Recipe 1", "This is test recipe 1", "https://cdn.pixabay.com/photo/2016/06/15/19/09/food-1459693_960_720.jpg"),
      new Recipe("Test Recipe 2", "This is test recipe 2", "https://cdn.pixabay.com/photo/2016/06/15/19/09/food-1459693_960_720.jpg")
    ];

    constructor() { }

    /**
     * 
     * @returns a copy of the recipes array (instead of providing a reference to the actual array).
     */
    getRecipes() {
      return this.recipes.slice();
    }
  }

app/recipes/recipe-list.component.ts:

  import { Component, OnInit, EventEmitter, Output } from '@angular/core';

  import { Recipe } from '../recipe.model';
  import { RecipeService } from '../recipe.service';

  @Component({
    selector: 'app-recipe-list',
    templateUrl: './recipe-list.component.html',
    styleUrls: ['./recipe-list.component.css']
  })
  export class RecipeListComponent implements OnInit {
    recipes: Recipe[];
    @Output() recipeWasSelected = new EventEmitter<Recipe>();

    constructor(private recipeService: RecipeService) { 
    }

    ngOnInit(): void {
      this.recipes = this.recipeService.getRecipes();
    }

    onRecipeSelected(recipe: Recipe) {
      this.recipeWasSelected.emit(recipe);
    }

  }


119. Using a Service for Cross-Component Communication.

recipe.service.ts:
- RecipeService
  - Provides data:
    - A copy of the recipes[].
  - property: recipeSelected = new EventEmitter<Recipe>();
    - retains a selected recipe

- recipes.component:
  - ts:
    - RecipesComponent
    - Loads the class RecipeService and provides the instance to the child-components.
    - ngOnInit:
      - Starts a listener: if a recipe is emitted elsewhere it will be the selected recipe RecipesComponent.selectedRecipe.
  - html:
    - <app-recipe-list>
      - recipe-list.component
        - ts:
          - RecipeListComponent
            - Loads the class RecipeService and receives the instance initiated in class RecipesComponent.
        - html:
          - Shows all recipes via <app-recipe-item>
          - <app-recipe-item>
            - recipe-item.component
              - ts:
                - RecipeItemComponent
                  - Receives a recipe as @Input().
                  - This recipe is emitted. This means that in RecipeComponent this will now be RecipesComponent.selectedRecipe.
              - html:
                - Shows: the recipe properties.
                - The recipe view is in a <a> hyperlink tag that is clickable. When clicking the selected recipe is emitted.
                  - The selected and emitted recipe will be input for <app-recipe-detail>
    - <app-recipe-detail>
      - RecipeDetailComponent
      - Purpose:
        - Will show the recipe available in RecipesComponent.selectedRecipe. This is input for RecipeDetailComponent.recipe.


Instead of child-component <==> parent-component <==> child-component:
- Use a service to transport the data from one child to another.
- As usual the bonus is that intricate Data Binding can be removed.


120. Adding the Shopping List Service.

Challenge: fill the ShoppingListService
- Add the list of ingredients.
- Add ingredient method.

shopping-list.service.ts:
- ShoppingListService
  - Provides data
  - property


121. Using Services for Pushing Data from A to B.

122. Adding Ingredients to Recipes.

123. Passing Ingredients from Recipes to the Shopping List (via a Service).

Challenge: Make the button 'Manage Recipe' 'To Shopping List' work.

shopping-list.service.ts
- class ShoppingListService

  ingredientsChanged = new EventEmitter<Ingredient[]>();

  /**
   * Purpose:
   * Add an array ingredient[] to the already existing ShoppingListService.ingredientsChanged.
   * 
   * Note:
   * These ingredients will be listed in shopping-list.component.html.
   * 
   * @param ingredients An array of instances of class Ingredient
   */
  addIngredients(ingredients: Ingredient[]) {
    /**
     * Here the spread input is used. Also known in Java.
     */
    this.ingredients.push(...ingredients);
    this.ingredientsChanged.emit(this.ingredients.slice());
  }
recipe.service.ts
- class RecipeService

// Injection of service class ShoppingListService
constructor(private shoppingListService: ShoppingListService) {}

  addIngredientsToShoppingList(ingredients:Ingredient[]) {
    this.shoppingListService.addIngredients(ingredients);
  }

recipe-detail.component.ts
  @Input() recipe: Recipe; // The recipe content is received from recipes.compoent.html

  constructor(private recipeService: RecipeService) { }


  onAddToShoppingList() {
    this.recipeService.addIngredientsToShoppingList(this.recipe.ingredients);
  }

recipe-detail.component.html

                <!-- The method recipe-detail.component.ts.onAddToShoppingList() will be called via (click) -->
                <ul class="dropdown-menu">
                    <li><a href="#" (click)="onAddToShoppingList()" style="cursor: pointer;">To Shopping List</a></li>
                    <li><a href="#">Edit Recipe</a></li>
                    <li><a href="#">Delete Recipe</a></li>
                </ul>


===================================================================================================
2022-01-21:

Section 11: Changing Pages with Routing.

Application: routing-start.


124. Module Introduction.

Until now we were always on the same page: http://localhost:4206/#

Angular ships with it's own router which allows you to change the url but actually you are still on the same page.

125. Why do we need a Router?


Application: routing-start

$ ng new routing-start --no-strict
  ? Would you like to add Angular routing?  y
  Choose CSS styling

Go to the root directory of the application:
$ ng serve

--> look at http://localhost:4206/

I have created: routing-start

How to install:

$ cd /Users/rkremers/Development/workspaceJS/Angular/routing-start
$ npm install --save bootstrap@3

This will download bootstrap locally. Not globally.

added 1 package, removed 1 package, and audited 1015 packages in 2s

90 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities

Will install in the node_modules folder.

Now make Angular aware of this styling package.
- angular.json file.

            "styles": [
              "node_modules/bootstrap/dist/css/bootstrap.min.css", !! bootstrap.min.css has been added here.
              "src/styles.css"
            ],

Add FormsModule to app.module.ts

app/
  home
  servers/
    edit-server
    server
  users/
    user


$ ng generate component home --skip-tests
$ ng generate component servers --skip-tests
$ ng generate component servers/edit-server --skip-tests
$ ng generate component servers/server --skip-tests
$ ng generate component users --skip-tests
$ ng generate component users/user --skip-tests

$ng generate service servers/servers --skip-testsGo to the root directory of the application:
$ ng serve --port 4206

126. Understanding the Example Project.

In our app, we got three sections:

- Home
- Servers
  - View and Edit Servers
  - A Service is used to load and update Servers
- Users
  - View Users
This app will be improved by adding routing but definitely feel free to play around with it - besides routing, everything should be working fine.

- App
  - ts
    empty
  - html
    nav-tabs
    <app-home></app-home>
    <app-users></app-users>
    <app-servers></app-servers>
  - Home
  - Servers
    - ts

    - html
      - View and Edit Servers
        - Overview of servers
        <app-edit-server></app-edit-server>
        <app-server></app-server>

    - A Service is used to load and update Servers
  - Users
    - View Users

127. Setting up and Loading Routes.

Because this is fundamental to the application it should be declared and set up in app.module.ts.

Resource:
- https://angular.io/guide/router
- https://angular.io/api/router/RouterOutlet
- https://www.telerik.com/blogs/angular-basics-using-router-angular-12-navigate-views?kw=&cpn=13466528117&&utm_source=google&utm_medium=cpc&utm_campaign=kendo-ui-angular-trial-search-bms-EMEA&ad_group=Angular+DSA&utm_term=DYNAMIC+SEARCH+ADS&ad_copy=&ad_type=search_DSA&ad_size=DSA2_blazor-dsa_D1-complete-native-angular-ui-component-library-built-for-quality-and-performance&ad_placement=&gclid=Cj0KCQiAubmPBhCyARIsAJWNpiO5ft0n9y_csM_ntuWJSa9b5phyYDd73w3wMYL5VxelDl0j0GMssGMaAizuEALw_wcB&gclsrc=aw.ds

The order of routes is important because the Router uses a first-match wins strategy when matching routes, 
so more specific routes should be placed above less specific routes. 
List routes with a static path first, followed by an empty path route, which matches the default route. 
The wildcard route comes last because it matches every URL and the Router selects it only if no other routes match first.

app.module.ts

import { RouterModule, Routes } from '@angular/router';

/**
 * Notes:
 * - The HomeComponent is added to the default path: ''.
 */
const appRoutes: Routes = [
  { path: '', component: HomeComponent},
  { path: 'users', component: UsersComponent},
  { path: 'servers', component: ServersComponent}
];

@NgModule({
  ..
  imports: [
    BrowserModule,
    FormsModule,
    RouterModule.forRoot(appRoutes) !!!
  ],

app.component.html:
<div class="container">
  <div class="row">
    <div class="col-xs-12 col-sm-10 col-md-8 col-sm-offset-1 col-md-offset-2">
      <ul class="nav nav-tabs">
        <li role="presentation" class="active"><a href="#">Home</a></li>
        <li role="presentation"><a href="#">Servers</a></li>
        <li role="presentation"><a href="#">Users</a></li>
      </ul>
    </div>
  </div>
  <div class="row">
    <div class="col-xs-12 col-sm-10 col-md-8 col-sm-offset-1 col-md-offset-2">
      <!-- 
        router-outlet is an Angular decorator. 
        Ref: https://angular.io/api/router/RouterOutlet
        This will be the place where we will start the component of the currently selected router.
      -->
      <router-outlet></router-outlet>
    </div>
  </div>
</div>

Now: if the app is running we can see:
- http://localhost:4206/#
  --> <app-home>
- http://localhost:4206/users
  --> <app-users>
- http://localhost:4206/servers
  --> <app-servers>


128. Navigating with Router Links.


  <div class="row">
    <div class="col-xs-12 col-sm-10 col-md-8 col-sm-offset-1 col-md-offset-2">
      <!-- 
        In setting the href to resp. /#, /servers, /users the tabs on the web pages can now be clicked
        and the correct content is shown.
        However: now the complete app will be reloaded, i.e. restarted.
                  That means that the state of the application would be lost and it would slow down the performance.
      -->
      <ul class="nav nav-tabs">
        <li role="presentation" class="active"><a href="/#">Home</a></li>
        <li role="presentation"><a href="/servers">Servers</a></li>
        <li role="presentation"><a href="/users">Users</a></li>
      </ul>
    </div>
  </div>

So because of the above mentioned reason using href is not the way to go.

Now: anchor attribute routerLink is used: see below.

<div class="container">
  <div class="row">
    <div class="col-xs-12 col-sm-10 col-md-8 col-sm-offset-1 col-md-offset-2">
      <!-- 
        See: paragraph 128 for details:
        In setting the href to resp. /#, /servers, /users the tabs on the web pages can now be clicked
        and the correct content is shown.
        However: now the complete app will be reloaded, i.e. restarted.
                  That means that the state of the application would be lost and it would slow down the performance.
        
        Instead routerlink is used. This directive is an Angular feature.
        This attribute will catch the select, prevent starting the default, parses it and
      -->
      <ul class="nav nav-tabs">
        <li role="presentation" class="active"><a routerLink="/">Home</a></li>
        <li role="presentation"><a routerLink="/servers">Servers</a></li>
        <!-- 
          Property Binding was used before, but now we bind to non-string data!
          Here we will use this and the input will be an array with one or more paths.
          In this case one path.
          This method will be useful in the later implementation.
        -->
        <li role="presentation"><a [routerLink]="['/users']">Users</a></li>
      </ul>
    </div>
  </div>
  <div class="row">
    <div class="col-xs-12 col-sm-10 col-md-8 col-sm-offset-1 col-md-offset-2">
      <!-- 
        router-outlet is an Angular decoratort. 
        This will be the place where we will start the component of the currently selected router.
      -->
      <router-outlet></router-outlet>
    </div>
  </div>
</div>


129. Understanding Navigation Paths.

How to navigate:
- absolute paths
  - e.g.:
    app.component.html:
        <li role="presentation" class="active"><a routerLink="/">Home</a></li>
        <li role="presentation"><a routerLink="/servers">Servers</a></li>

- Relative paths:
  - Means: appends to the currently loaded path.
  - e.g.:
    app.component.html
        <li role="presentation"><a routerLink="/servers">Servers</a></li>
        - Here it is added to the current path:
    servers.component.html
      <div class="col-xs-12 col-sm-4">
        <a routerLink="../servers">Reload Page</a>
        <app-edit-server></app-edit-server>
        <hr>
        <app-server></app-server>
      </div>
      ../servers

What can go wrong with relative paths:
    servers.component.html
      <div class="col-xs-12 col-sm-4">
        <a routerLink="servers">Reload Page</a> <!-- Relative path, i.e. a path relative to http://localhost:4206/servers -->
        --> 
        ERROR Error: Uncaught (in promise): Error: Cannot match any routes. URL Segment: 'servers/servers'
        Error: Cannot match any routes. URL Segment: 'servers/servers'

         <a routerLink="../servers">Reload Page</a>
         --> relative to http://localhost:4206/servers/../servers
         - In other words: this path does exist.


130. Styliing Active Router Links.

It would be nice to make more visible which tab is active:
- Use routerLinkActive instead of 'class="active' in:
  <li role="presentation" class="active"><a routerLink="/">Home</a></li>

  So it would be:
  <li role="presentation" routerLinkActive=""><a routerLink="/">Home</a></li>
  --> Now the 
  Or:
  <li role="presentation" ><a routerLink="/" routerLinkActive="active">Home</a></li>


The 'Home' tab is allways black (the other non-active tabs are blue).
This is explained and improved using below code: routerLinkActiveOptions

        routerLinkActive="active"
        - routerLinkActive is an Angular directive.
          - It analyses your currently loaded path and then checks which link leads to route which uses this path.
          - By default it marks the element as 'active' on which you are.
          - In the case below the empty path will be part of all paths and therefore will allways be marked active.
        - active is a css feature.
        - routerLinkActiveOptions="{exact: true}"
          - Tells Angular: only add this routerLink active class if the exact path is true.

      -->
      <ul class="nav nav-tabs">
        <li 
          role="presentation" 
          routerLinkActive="active"
          [routerLinkActiveOptions]="{exact: true}"
          ><a routerLink="/">Home</a></li>


131. Navigating Programmatically.

Example:
- home.component
  - ts

  constructor(private router: Router) { }

  onLoadServers() {
    // Some complex calculation which prevents us to simply use 'routerLink' directive.
    // We need access to our router. We can access the router via Dependency Injection.
    this.router.navigate(['/servers']);
  }

  - html
    <button class="btn btn-primary" (click)="onLoadServers()">Load Servers</button>


132. Using Relative Paths in Programmatic Navigation.

This contains an in depth discussion about routes.

servers.component:
- html:
    <button class="btn btn-primary" (click)="onReload()">Reload Page</button>
- ts:

  /**
   * 
   * @param serversService: ServersService: The service giving access to server data and related functionality.
   * @param router : Router; declared in app.module.ts.
   * @param currentRoute : ActivatedRoute: injects the currently activated route which loaded this component.
   *                        - contains a lot of meta-information about the current route.
   */
  constructor(
    private serversService: ServersService,
    private router: Router,
    private currentRoute: ActivatedRoute) { }

  ngOnInit() {
    this.servers = this.serversService.getServers();
  }

  /**
   * 132. Using Relative Paths in Progammatic Navigation.
   * In this method three possible implementations and their effects are given and commented on.
   */
  onReload() {
    /**
     * Navigate using an absolute path: '/servers'
     * - Nothing will happen, but no harm done either.
     * - Angular decides that we are already on this page so no action is necessary.
     * - Note that in itself this implementation is working.
     */
    // this.router.navigate(['/servers']);
    
    /**
     * Navigate using a relative path: 'servers'
     * - We still don't get an error whereas using routerLink this would have caused an error.
     *  - Reason:
     *    Unlike routerLink this.router.navigate does not know on which route it currently is.
     *    So nothing happens.
     *    - routerLink always knows on which component it resides, in which component template
     *      and therefore it knows what the currently loaded route is.
     * - The relative route still needs to be a route defined earlier in app.module.ts.
     */
    // this.router.navigate(['servers']);

    /**
     * Navigate using a relative path: 'servers' and tell where we currently are using relativeTo.
     * With this implementation Angular:
     * - knows what our currently active route is.
     * - should navigate relative to this active route.
     * 
     * When trying to click the 'Reload Page' button this results in the following, correct error:
     * core.mjs:6461 ERROR Error: Uncaught (in promise): Error: Cannot match any routes. URL Segment: 'servers/servers'
     * Error: Cannot match any routes. URL Segment: 'servers/servers' !!!
     * 
     */
    // this.router.navigate(['servers'], {relativeTo: this.currentRoute});
  }


133. Passing Parameters to Routes.

/**
 * Notes:
 * - The HomeComponent is added to the default path: ''.
 * 
 * It is possible to add parameters to the routes: 'users/:id'
 * - The colon ':' tells Angular that this is a dynamic part of the path.
 * - Warning: without ':' Angular would literally look for a route 'users/id'.
 * 
 * Result: http://localhost:4206/users/something will work.
 * 
 */
const appRoutes: Routes = [
  { path: '', component: HomeComponent},
  { path: 'users', component: UsersComponent},
  { path: 'users/:id', component: UserComponent},
  { path: 'servers', component: ServersComponent}
];

134. Fetching Route Parameters.

Question:
- How can we add data to user.component given that in the previous paragraph we setup passing a parameter to routes.
  - { path: 'users/:id', component: UserComponent},

app.module.ts:
  const appRoutes: Routes = [
    { path: '', component: HomeComponent},
    { path: 'users', component: UsersComponent},
    { path: 'users/:id/:name', component: UserComponent},
    { path: 'servers', component: ServersComponent}
  ];

  user.component.ts:
  import { Component, OnInit } from '@angular/core';
  import { ActivatedRoute } from '@angular/router';

  @Component({
    selector: 'app-user',
    templateUrl: './user.component.html',
    styleUrls: ['./user.component.css']
  })
  export class UserComponent implements OnInit {
    user: {id: number, name: string};

    /**
     * 
     * @param route : ActivatedRoute: injects the currently activated route which loaded this component.
     *                - This object will give us access to the id and name passed in the URL => Selected User.
     *                - contains a lot of meta-information about the current route.
     *                - In this case the used route, defined in app.module.ts may be:
     *                  { path: 'users/:id/:name', component: UserComponent}
     */
    constructor(private route: ActivatedRoute) { }

    /**
     * Detail:
     * this.route.params vs this.rout.snapshot.params:
     * If you know that the params don't change during lifetime of the component, 
     * you don't need a subscription and can use the simpler syntax provided by the snapshot. 
     * If the params may change during lifetime, you will have to use the subscription
     */
    ngOnInit(): void {
      this.user = {
        id: this.route.snapshot.params['id'],
        name: this.route.snapshot.params['name']
      };
      console.log('UserComponent.ngOnInit: user.id = ' + this.user.id + ', user.name = ' + this.user.name);
    }

  }

user.component.html:
  <p>User with ID {{ user.id }} loaded.</p>
  <p>User name is {{ user.name }}</p>

When using the url: http://localhost:4206/users/1/Rob
In the console logging I see:
UserComponent.ngOnInit: user.id = 1, user.name = Rob


135. Fetching Route Parameters Reactively.
136. An Important Note about Route Observables.

There are ways to break the approach shown in paragraph 134.
A typical example is shown.

user.compoonent.ts:
  import { Component, OnDestroy, OnInit } from '@angular/core';
  import { ActivatedRoute, Params } from '@angular/router';
  import { Subscription } from 'rxjs';

  @Component({
    selector: 'app-user',
    templateUrl: './user.component.html',
    styleUrls: ['./user.component.css']
  })
  export class UserComponent implements OnInit, OnDestroy {
    user: {id: number, name: string};
    paramsSubscription: Subscription

    /**
     * 
     * @param route : ActivatedRoute: injects the currently activated route which loaded this component.
     *                - This object will give us access to the id and name passed in the URL => Selected User.
     *                - contains a lot of meta-information about the current route.
     *                - In this case the used route, defined in app.module.ts may be:
     *                  { path: 'users/:id/:name', component: UserComponent}
     */
    constructor(private route: ActivatedRoute) { }

    /**
     * Detail:
     * this.route.params (Observable subscrption; continuously waiting for input) 
     * vs this.rout.snapshot.params (handover of properties once):
     * 
     * If you know that the params don't change during lifetime of the component, 
     * you don't need a subscription and can use the simpler syntax provided by the snapshot. 
     * If the params may change during lifetime, you will have to use the subscription
     */
    ngOnInit(): void {
      /**
       * This code will only be accessed at the beginning.
       * route.snapshot.params is a property.
       */
      this.user = {
        id: this.route.snapshot.params['id'],
        name: this.route.snapshot.params['name']
      };
      /**
       * This code will be necessary if the Users page is chosen and the content of the route changes.
       * route.params is an Observable.
       * Observables are a feature, added by a third party, but heavily used.
       * - allows you to easily work with asynchronous tabs.
       * - This IS an asynchronous task because the parameters of the currently loaded route might change 
       *   at some point in the future if the user clicks this link.
       *   But it is not known when, if or how long it will take. 
       * - An Observable is an easy way to subscribe to some event that might happen in the future
       *    to then execute some code when it happens without having to wait for it now.
       * 
       * 136. An Important Note about Route Observables.
       * 
       * In the background Angular will clean up this subscription once the user.component is destroyed.
       * If it wouldn't do this the subscription would live on afterwards because it is not closely
       * tied to the component.
       * When you come back to the component a new instance will be created.
       * Again: Angular cleans the subscription but from a theoretical point you would want to 
       * explicitly remove the subscription. Therefore ngOnDestroy is used.
       * Here, see below at ngOnDestroy() this is executed.
       * 
       */
      console.log('UserComponent.ngOnInit: user.id = ' + this.user.id + ', user.name = ' + this.user.name);
      this.paramsSubscription = this.route.params.subscribe(
        (params: Params) => {
          this.user.id = params['id'];
          this.user.name = params['name'];
          console.log('UserComponent.ngOnInit: user.id = ' + this.user.id + ', user.name = ' + this.user.name);
        }
      );
      
    }

    ngOnDestroy(): void {
      this.paramsSubscription.unsubscribe();
    }

  }

Using this:
localhost:4202/1/Rob will work.

The logging will show:

http://localhost:4206/users/1/Rob

Console:
UserComponent.ngOnInit: user.id = 1, user.name = Rob // OnInit: The page is accessed and the content is entered initially.
UserComponent.ngOnInit: user.id = 1, user.name = Rob // OnInit: The subscription receives the content too.

Click: Load Anna (10)
http://localhost:4206/users/10/Anna

Console:
UserComponent.ngOnInit: user.id = 10, user.name = Anna // Clicking the anchor does not renew the page: so no OnInit is access. Only the subscription.

But also:

user.component.html:
  <a [routerLink]="['/users', 10, 'Anna']">Load Anna (10)</a>

Because the Obervable.subcription will keep looking for changes in the data and act accordingly.


137. Passing Query Parameters and Fragments.

You might have query parameters:
- These are parameters set by question marks and '&' signs in case of multiple parameters.
- Question:
  - How can you pass them on to the router links
  - How can you retrieve them.

You might have a hash sign ('#') to:
- jump to a specific place in your app.
- retrieve some extra information.

Example:
localhost:4202/users/10/Anna?mode=editing#loading


Example of the use of query parameters and fragments:


routerLink in html:

  app.module.ts
  const appRoutes: Routes = [
    { path: '', component: HomeComponent},
    { path: 'users', component: UsersComponent},
    { path: 'users/:id/:name', component: UserComponent},
    { path: 'servers', component: ServersComponent},
    { path: 'servers/:id/edit', component: EditServerComponent}
  ];

  --> The last route should load an instance of EditServerComponent.


  servers.component.html:

  <div class="row">
      <div class="col-xs-12 col-sm-4">
        <div class="list-group">
          <!-- 
            queryParams is another part of the routerLink directive.
            Resulting url when selecting a server: http://localhost:4206/servers/1/edit?allowEdit=1&allowTest=2
          -->
          <a
            [routerLink]="['/servers', 1, 'edit']"          --> Now an EditComponent can be started.
            [queryParams]="{allowEdit:'1', allowTest: '2'}" --> allowEdit and allowTest are parameters to select certain features.
            [fragment]="'loading'"
            href="#"
            class="list-group-item"
            *ngFor="let server of servers">
            {{ server.name }}
          </a>
        </div>
      </div>
      <div class="col-xs-12 col-sm-4">
        <button class="btn btn-primary" (click)="onReload()">Reload Page</button>
        <app-edit-server></app-edit-server>
        <hr>
        <app-server></app-server>
      </div>
    </div>

Result:
url: http://localhost:4206/servers/1/edit?allowEdit=1&allowTest=2#loading


Now programmatically via TypeScript:

home.component.ts:

  onLoadServer(id: number) {
    this.router.navigate(['/servers', id, 'edit'], {queryParams: {allowEdit: '1'}, fragment: 'loading'});
  }

home.component.html:

<button class="btn btn-primary" (click)="onLoadServer(1)">Load Server 1</button>


Result:

url: http://localhost:4206/servers/1/edit?allowEdit=1#loading


138. Retrieving Query Parameters and Fragments.


139. Practicing and some Common Gotchas.

Multiple options available in TypeScript to parse a string to a number:
- https://www.tektutorialshub.com/typescript/typescript-string-to-number/

app.module.ts:
- Added:
  { path: 'servers/:id', component: ServerComponent},


users.component.html:

<div class="row">
  <div class="col-xs-12 col-sm-4">
    <div class="list-group">
      <!-- 
          Apparently when using routerLink I do not need to use Property Binding. 
          According to Marnix I only need to use Property Binding, in the case below
          String Interpolation, if I want to show the value.
          Otherwise I can just use the property, in this case user, as such.
          Now we add the values dynamically instead of hard-coded.
        -->
      <a [routerLink]="['/users', user.id, user.name]" href="#" class="list-group-item" *ngFor="let user of users">
        {{ user.name }}
      </a>
    </div>
  </div>
  <div class="col-xs-12 col-sm-4">
    <app-user></app-user>
  </div>
</div>

servers.component.html:

<div class="row">
    <div class="col-xs-12 col-sm-4">
      <div class="list-group">
        <!-- 
          queryParams is another part of the routerLink directive.
          Resulting url when selecting a server: http://localhost:4206/servers/1/edit?allowEdit=1&allowTest=2
          You may only have one fragment.
          [fragment]="'loading'" can be replaced by fragment="loading"

          139. Practicing and some Common Gotchas.
          Now the intention is to load here the server component and not anymore the edit-server-component.
        -->
        <a
          [routerLink]="['/servers', server.id]"
          [queryParams]="{allowEdit:'1', allowTest: '2'}"
          [fragment]="'loading'"
          href="#"
          class="list-group-item"
          *ngFor="let server of servers">
          {{ server.name }}
        </a>
      </div>
    </div>

    <div class="col-xs-12 col-sm-4">
      <button class="btn btn-primary" (click)="onReload()">Reload Page</button>
      <app-edit-server></app-edit-server>
      <hr>
      <!-- <app-server></app-server> -->
    </div>
  </div>

server.component:
- ts:

 export class ServerComponent implements OnInit, OnDestroy {
  server: {id: number, name: string, status: string};
  paramsSubscription: Subscription;

  constructor(
      private serversService: ServersService,
      private route: ActivatedRoute
      ) { }

  ngOnInit(): void {
    /**
     * If we parse a parameter, coming from a url, it will always be a string.
     * However the id is a number. Therefore the incoming id-string needs to be converted to a number.
     */
    const id: number = parseInt(this.route.snapshot.params['id']);
    this.server = this.serversService.getServer( id );
    /**
     * The following is added to enable reacting to subsequent changes.
     */
    this.paramsSubscription = this.route.params.subscribe(
      (params: Params) => {
        this.server = this.serversService.getServer( parseInt(params['id']));
      }
    );
  }

  ngOnDestroy() {
    this.paramsSubscription.unsubscribe();
  }
}


140. Setting up Child (Nested) Routes.

Resources:
- See also: 127. Setting up and Loading Routes.

app.module.ts:

const appRoutes: Routes = [
  { path: '', component: HomeComponent},
  { path: 'users', component: UsersComponent},
  { path: 'users/:id/:name', component: UserComponent},
  { path: 'servers', component: ServersComponent},
  { path: 'servers/:id', component: ServerComponent},
  { path: 'servers/:id/edit', component: EditServerComponent}
];

--> These routes are more of the same. Now nesting is introduced.

const appRoutes: Routes = [
  { path: '', component: HomeComponent},
  { path: 'users', component: UsersComponent, children: [
    { path: ':id/:name', component: UserComponent}
  ]},
  { path: 'servers', component: ServersComponent, children: [
    { path: ':id', component: ServerComponent},
    { path: ':id/edit', component: EditServerComponent}
  ]},
];


app.component.html:
  <div class="row">
    <div class="col-xs-12 col-sm-10 col-md-8 col-sm-offset-1 col-md-offset-2">
      <!-- 
        router-outlet is an Angular decorator. 
        Ref: 
        - https://angular.io/guide/router 
        - https://angular.io/api/router/RouterOutlet
        This will be the place where we will start the component of the currently selected router.
        This element informs Angular to update the application view with the component for the selected route.

        140. Setting up Child (Nested) Routes.

        THE <router-outlet> HERE IS RESERVED FOR THE TOP-LEVEL OF OUR ROUTES THAT HAVE NESTED ROUTES.
        So nested routes need a separate <router-outlet> element at the appropriate place where they will be used.
        In the case of servers: servers.component.html.
      -->
      <router-outlet></router-outlet>
    </div>
  </div>
</div>

servers.component.html:

<div class="row">
    <div class="col-xs-12 col-sm-4">
      <div class="list-group">
        <!-- 
          queryParams is another part of the routerLink directive.
          Resulting url when selecting a server: http://localhost:4206/servers/1/edit?allowEdit=1&allowTest=2
          You may only have one fragment.
          [fragment]="'loading'" can be replaced by fragment="loading"

          139. Practicing and some Common Gotchas.
          Now the intention is to load here the server component and not anymore the edit-server-component.
        -->
        <a
          [routerLink]="['/servers', server.id]"
          [queryParams]="{allowEdit:'1', allowTest: '2'}"
          [fragment]="'loading'"
          href="#"
          class="list-group-item"
          *ngFor="let server of servers">
          {{ server.name }}
        </a>
      </div>
    </div>

    <div class="col-xs-12 col-sm-4">
      <!-- 
        140. Setting up Child (Nested) Routes.
        When using nested routes are used: see explanation in app.component.html:
        - At the point where the nested routes will be used a new hook <router-outlet> needs to be placed.
          - Here servers-related nested routes, so relative to servers (see routes declaration) will be displayed.
          - Note that above is defined:
            - [routerLink]="['/servers', server.id]"
            - That points to (app.module.ts) the server-compnent. So that component will be loaded.
      -->
      <router-outlet></router-outlet>

      <!-- <button class="btn btn-primary" (click)="onReload()">Reload Page</button>
      <app-edit-server></app-edit-server>
      <hr>
      <app-server></app-server>
    </div> -->
  </div>

Now the same for users:

users.component.html:

  <div class="col-xs-12 col-sm-4">
    <!--
      140. Setting up Child (Nested) Routes.
      Here all nested routes relative to the users route will be displayed (see declaration in app.module.ts).
    -->
    <!-- <app-user></app-user> -->
    <router-outlet></router-outlet>
  </div>


141. Using Query Parameters - Practice.

Topic: adding access to edit-server component again.


142. Configuring the Handling off Query Parameters.

servers.component.ts

  onEdit() {
    const id: number = parseInt(this.route.snapshot.params['id']);
    /**
     * 141. Using Query Parameters - Practice.
     * 
     * This is one approach: use the complete path.
     * However we have created nested paths. 
     */
    // this.router.navigate(['servers', this.server.id, 'edit']);

    /**
     * In the following way we  can add 'edit' to the current route.
     * 
     * 142. Configuring the Handling off Query Parameters.
     * queryParamsHandling:
     * - We want to preserve the existing query parameters, like http://localhost:4206/servers/2?allowEdit=0#loading
     * - Therefore we choose to use 'preserve'.
     * - 'merge', another option, would be used to add new query parameters.
     */
    this.router.navigate(['edit'], {relativeTo: this.route, queryParamsHandling: 'preserve'});
  }
}

TODO:
- Find the references where the above mentioned implementation is described.


143. Redirecting and Wildcard Routes.

Add 404 error handling:
- Redirect the user to a specific page whenever there is a url / properties we don't have.

Create  new component:
$ ng generate component page-not-found --skip-tests

CREATE src/app/page-not-found/page-not-found.component.css (0 bytes)
CREATE src/app/page-not-found/page-not-found.component.html (29 bytes)
CREATE src/app/page-not-found/page-not-found.component.ts (305 bytes)
UPDATE src/app/app.module.ts (2043 bytes)

page-not-found.component.html:
  <h3>HTTP-status 404: The page was not found!</h3>

app.module.ts:
/**
 * 143. Redirecting and Wildcard Routes.
 * 
 * When using the wildcard '**' any non-defined url will (after IP:portnumber)
 * will be redirected to PageNotFoundComponent.
 * Make sure that the wildcard is the last path because the paths will be scanned from top to bottom.
 * 
 */
const appRoutes: Routes = [
  { path: '', component: HomeComponent},
  { path: 'users', component: UsersComponent, children: [
    { path: ':id/:name', component: UserComponent}
  ]},
  { path: 'servers', component: ServersComponent, children: [
    { path: ':id', component: ServerComponent},
    { path: ':id/edit', component: EditServerComponent}
  ]},
  { path: 'not-found', component: PageNotFoundComponent}, 
  { path: '**', redirectTo: '/not-found'}
];


144. Important: Redirection Path Matching.

Important: Redirection Path Matching
In our example, we didn't encounter any issues when we tried to redirect the user. But that's not always the case when adding redirections.

By default, Angular matches paths by prefix. That means, that the following route will match both /recipes  and just / 

{ path: '', redirectTo: '/somewhere-else' } 

Actually, Angular will give you an error here, because that's a common gotcha: This route will now ALWAYS redirect you! Why?

Since the default matching strategy is "prefix" , Angular checks if the path you entered in the URL does start with the path specified in the route. Of course every path starts with ''  (Important: That's no whitespace, it's simply "nothing").

To fix this behavior, you need to change the matching strategy to "full" :

{ path: '', redirectTo: '/somewhere-else', pathMatch: 'full' } 

Now, you only get redirected, if the full path is ''  (so only if you got NO other content in your path in this example).


145. Outsourcing the Route Configuration.

If you have more than a few routes you will typically outsource the paths to a separate file.

If you intend to do this anyway:

Application: routing-start

$ ng new routing-start --no-strict
  ? Would you like to add Angular routing?  y # This will add ap-routing.module.ts
  Choose CSS styling

Otherwise create file app-routing.module.ts

Outsource the paths to app-routing.module.ts and import the defined class AppRoutingModule.

app-routing.module.ts:

import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { HomeComponent } from './home/home.component';
import { PageNotFoundComponent } from './page-not-found/page-not-found.component';
import { EditServerComponent } from './servers/edit-server/edit-server.component';
import { ServerComponent } from './servers/server/server.component';
import { ServersComponent } from './servers/servers.component';
import { UserComponent } from './users/user/user.component';
import { UsersComponent } from './users/users.component';

 const routes: Routes = [
  { path: '', component: HomeComponent},
  { path: 'users', component: UsersComponent, children: [
    { path: ':id/:name', component: UserComponent}
  ]},
  { path: 'servers', component: ServersComponent, children: [
    { path: ':id', component: ServerComponent},
    { path: ':id/edit', component: EditServerComponent}
  ]},
  { path: 'not-found', component: PageNotFoundComponent},
  { path: '**', redirectTo: '/not-found', pathMatch: 'full'}
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }

app.module.ts:

// import { RouterModule, Routes } from '@angular/router';
import { AppRoutingModule } from './app-routing.module';

@NgModule({
  declarations: [
    AppComponent,
    HomeComponent,
    UsersComponent,
    ServersComponent,
    UserComponent,
    EditServerComponent,
    ServerComponent,
    PageNotFoundComponent
  ],
  imports: [
    BrowserModule,
    FormsModule,
    AppRoutingModule  // Added.
    // RouterModule.forRoot(routes) // Moved to app-routing.module.ts
  ],
  // exports: [     // No longer necessary for our app.
  //   RouterModule
  // ],
  providers: [ServersService],
  bootstrap: [AppComponent]
})
export class AppModule { }


146. An Introduction to Guards.


Guards concerns code to be executed before a route or when you leave a route.
Example:
- In the current app routing-start it should not be allowed to edit a server without permission.

It is preferred to implement functionality that can be accessed in multiple components.


147. Protecting Routes with canActivate.

Resource:
- https://angular.io/api/router/CanActivate
- https://dev.to/techiediaries/angular-10-promise-by-example-bne

API > @angular/router
mode_edit code
CanActivate
interface

Interface that a class can implement to be a guard deciding if a route can be activated. 
If all guards return true, navigation continues. 
If any guard returns false, navigation is cancelled. 
If any guard returns a UrlTree, the current navigation is cancelled and a new navigation begins to the UrlTree returned from the guard.


@ng generate service auth-guard --skip-tests

CREATE src/app/auth-guard.service.ts (138 bytes)

Add: implements CanActivate.

import { Injectable } from '@angular/core';
import { ActivatedRouteSnapshot, CanActivate, RouterStateSnapshot, UrlTree } from '@angular/router';
import { Observable } from 'rxjs';

/**
 * 147. Protecting Routes with canActivate.
 * 
 * Note:
 * - The course leader prefers to omit 'Service' in the classname.
 */
@Injectable({
  providedIn: 'root'
})
export class AuthGuard implements CanActivate {

  constructor() { }

  canActivate(
    route: ActivatedRouteSnapshot, 
    state: RouterStateSnapshot): boolean | UrlTree | Observable<boolean | UrlTree> | Promise<boolean | UrlTree> {
    throw new Error('Method not implemented.');
  }
}

# Generate a fake service for authentication:
$ ng generate service auth --skip-tests



Promises • Angular - codecraft.tv
https://codecraft.tv › courses › angular › es6-typescript
Promises are a far cleaner solution to writing asynchronous code than callbacks. The resulting code that's created is easier to read and is often written the ...


    HTTP Example with Promises • Angular - codecraft.tv
    https://codecraft.tv › courses › http › http-with-promises

    Using Promises. The search function is going to make an asynchronous call using the Http client lib to the iTunes API .

People also ask
What is an angular Promise?
Promises in AngularJS are provided by the built-in $q service. 
They provide a way to execute asynchronous functions in series by registering them with a promise object. 
Practically speaking AJAX calls using the $http service are some of the most common scenarios where promises are used.


https://dev.to/techiediaries/angular-10-promise-by-example-bne

A promise is a JavaScript object that may produce a value at some point in time. 
A promise may be in one of 4 possible states: fulfilled, rejected, pending or settled.

After implementation:
- auth.service.ts
  export class AuthService 
  - A fake service providing access functionality.
- auth-guard.service.ts
  export class AuthGuard implements CanActivate
  - Regulate access to a given route.
  - Using AuthService.
- app.module.ts:
- AuthService, AuthGuard have been added to providers[]:
  providers: [ServersService, AuthService, AuthGuard],
- app-routing.module.ts:
  * 147. Protecting Routes with canActivate.
  * Via canActivate[] a Promise, defined in AuthGuard, will be implemented.
  * Now access to the servers will only be possible if AuthGuard will return 'true'.

  { path: 'servers', canActivate: [AuthGuard], component: ServersComponent, children: [
    { path: ':id', component: ServerComponent},
    { path: ':id/edit', component: EditServerComponent}
  ]},

In the current application:

export class AuthService {
  private loggedIn: boolean = false;
--> Access is always set to false, therefore denying access.

export class AuthGuard:

  canActivate(
    route: ActivatedRouteSnapshot, 
    state: RouterStateSnapshot): boolean | UrlTree | Observable<boolean | UrlTree> | Promise<boolean | UrlTree> {
    
    return this.authService.isAuthenticated()
    .then(
      (authenticated: boolean) => {
        if (authenticated) {
          return true;
        }
        // Alternatively also 'false' could have been returned.
        // In this setup the user will be redirected to the root.
        this.router.navigate(['/']);
      }
    );
  }
--> after 800 msec the user will be redirected to the root.


148. Protecting Child (Nested) Routes with canActivateChild.

Purpose:
- We only want to protect the child routes.
- So it will be allowed to view tab 'Servers'.

Now in service class AuthGuard in auth-guard.service.ts is alos defined:

  canActivateChild(
    route: ActivatedRouteSnapshot, 
    state: RouterStateSnapshot): boolean | UrlTree | Observable<boolean | UrlTree> | Promise<boolean | UrlTree> {
    
    return this.canActivate(route, state);
    }


149. Using a Fake Auth Service.

home.component:
- ts:
  constructor(private router: Router, private authService: AuthService) { }

  onLogin() {
    this.authService.login();
  }

  onLogout() {
    this.authService.logOut();
  }
- html:
<div>
    <button class="btn btn-default" (click)="onLogin()">Login</button>
    <button class="btn btn-default" (click)="onLogout()">Logout</button>
</div>


150. Controlling Navigation with canDeactivate.

canDeactivate can be used to control whether it is admitted to leave a route.

# This is what is done by the course leader.
$ ng generate service can-deactivate-guard --skip-tests

# But he creates an interface so, in Angular 13, I'll use this method:
$ ng generate interface can-component-deactivate          
CREATE src/app/can-deactivate-guard.ts (40 bytes)

$ ng generate service can-deactivate-guard --skip-tests


151. Passing Static Data to a Route.

Some routes depends on received data, either statically or dynamically.

In this paragraph the case of static data is investigated.

Example: Instead of page-not-found use an error-page.

$ ng generate component error-page --skip-tests

error-page.component:
- html:

  <h4>{{ errorMessage }}</h4>

- ts:

  import { Component, OnInit } from '@angular/core';
  import { ActivatedRoute, Data } from '@angular/router';

  @Component({
    selector: 'app-error-page',
    templateUrl: './error-page.component.html',
    styleUrls: ['./error-page.component.css']
  })
  export class ErrorPageComponent implements OnInit {
    errorMessage: string;

    constructor(private route: ActivatedRoute) { }

    /**
     * The 'message' has been defined in app-router.module.ts.
     */
    ngOnInit(): void {
      this.errorMessage = this.route.snapshot.data['message'];
      this.route.data.subscribe(
        (data: Data) => {
          this.errorMessage = data['message'];
        }
      );
    }

  }

app-routing.module.ts:

  // { path: 'not-found', component: PageNotFoundComponent},
  { path: 'not-found', component: ErrorPageComponent, data: {message: 'Page not found!'}},
  { path: '**', redirectTo: '/not-found', pathMatch: 'full'}

--> So for this example for the moment the PageNotFoundComponent has been commented out.
    Now in case of an unknown path the ErrorPageComponent will be used.
    The actual data is set here in app-routing.module.ts.


152. Resolving Dynamic Data with the resolve Guard.

If you need to fetch data from a backend you need a resolver.
In this case if choosing a specific server I want to load the specific data from some backend.

The resolver will always render the component in the end but will some pre-loading.
It will fetch some data to build the component.
So in other words: the data would be loaded BEFORE displaying the route.

The alternative would be to render the component or target-page instantly and in the onInit() method you could fetch data and show it when it's available.

$ ng generate service /servers/server/server-resolver --skip-tests

CREATE src/app/servers/server/server-resolver.service.ts (143 bytes)

The resolver will be especially important when using asynchronous data.

server-resolver.service.ts:

  export class ServerResolver implements Resolve<Server> {

    // Again: we are linked to the service providing the server data.
    constructor(private serversService: ServersService) { }

    /**
     * 152. Resolving Dynamic Data with the resolve Guard.
     * 
     * the resolve method will be used in app-routing.module.ts:
     * ..
     *     { path: ':id', component: ServerComponent, resolve: {server: ServerResolver}},
     * ..
     * The data that is to be received, in this case the server.id, will be stored in the routes instance,
     * defined in app-routing.module.ts.
     * 
     * @param route 
     * @param state 
     * @returns 
     */
    resolve(
      route: ActivatedRouteSnapshot, 
      state: RouterStateSnapshot): Server | 
                                    Observable<Server> | 
                                    Promise<{ id: number; name: string; status: string; }> {
      // '+' in advance has the same effect as parseInt().
      return this.serversService.getServer(+route.params['id']);
    }
  }

app-routing.module.ts:

  { path: ':id', component: ServerComponent, resolve: {server: ServerResolver}},

--> So the resolver will be used for 'servers/:id' --> ServerComponent.

server.component.ts:

In this component the use of a Resolver is an example.
The normal situation is to use a subscription of this.route.params.subscribe().
Using the Resolver this.route.data.subscribe() is used.

  ngOnInit(): void {
    // /**
    //  * If we parse a parameter, coming from a url, it will always be a string.
    //  * However the id is a number. Therefore the incoming id-string needs to be converted to a number.
    //  */
    // const id: number = parseInt(this.route.snapshot.params['id']);
    // this.server = this.serversService.getServer( id );
    // /**
    //  * The following is added to enable reacting to subsequent changes.
    //  */
    // this.paramsSubscription = this.route.params.subscribe(
    //   (params: Params) => {
    //     this.server = this.serversService.getServer( parseInt(params['id']));
    //   }
    // );
    /**
     * 152. Resolving Dynamic Data with the resolve Guard.
     * Now we will use a Resolver for the previously implemented functionality.
     * 
     * 'server' should have the same name as defined in app-routing.module.ts:
     * { path: ':id', component: ServerComponent, resolve: {server: ServerResolver}},
     * --> 'server'.
     */
     this.paramsSubscription = this.route.data.subscribe(
      (data: Data) => {
        this.server = data['server'];
      }
    );
  }


153. Understanding Location Strategies.

The app has to be configured such that in case of HTTP 404 it has to return the <application>/src/index.html file.
This is the file containing the Angular app.
Otherwise the routes configured in <application>/src/app/app-routing.module.ts may not be recognized by the production server.


app-routing.module.ts:

/**
 * Using {useHash: true} results in:
 * http://localhost:4206/#servers 
 * http://localhost:4206/#users
 * 
 * This tells older browsers / servers that they should only look at everything BEFORE '#'.
 * So in this case: http://localhost:4206/
 * --> This will point to index.html.
 * 
 * Normally this should not be necessary.
 * 
 */
@NgModule({
  imports: [RouterModule.forRoot(routes, {useHash: true})],
  exports: [RouterModule]
})


154. Wrap up.

https://medium.com/@fivedicephoto/angular-activatedroute-vs-activatedroutesnapshot-6365c384feb8

When subscribing to an observable in a component, you almost always arrange to unsubscribe when the component is destroyed.

There are a few exceptional observables where this is not necessary. The ActivatedRoute observables are among the exceptions.

The ActivatedRoute and its observables are insulated from the Router itself. 
The Router destroys a routed component when it is no longer needed and the injected ActivatedRoute dies with it.



===================================================================================================

Section 12: Course Project - Routing.


I'll set up a new project shopping-app-router.
This starts with the content of shopping-app.


$ ng new shopping-app-router --no-strict
  ? Would you like to add Angular routing?  Y
  Choose CSS styling

Go to the root directory of the application:
$ ng serve

--> look at http://localhost:4207/

How to install:

$ cd /Users/rkremers/Development/workspaceJS/Angular/shopping-app
$ npm install --save bootstrap@3

This will download bootstrap locally. Not globally.

Now make Angular aware of this styling package.
- angular.json file.

            "styles": [
              "node_modules/bootstrap/dist/css/bootstrap.min.css", !! bootstrap.min.css has been added here.
              "src/styles.css"
            ],

Add FormsModule to app.module.ts

Go to the root directory of the application:
$ ng serve --port 4207


155. Planning the General Structure.

Instead of *ngIf now routes will be used to navigate the web application.
Also the recipe-edit component will be added in order to edit an existing recipe or create a new recipe.


156. Setting up Routes.

app-routing.modules.ts:

  /**
   * pathMatch: 'full':
   * - Only redirect if the full path is empty.
   */
  const appRoutes: Routes = [
      // { path: '', component: HeaderComponent},
      { path: '', redirectTo: '/recipes', pathMatch: 'full'},
      { path: 'recipes', component: RecipesComponent},
      { path: 'shopping-list', component: ShoppingListComponent}
  ];

  @NgModule({
      imports: [RouterModule.forRoot(appRoutes)],
      exports: [RouterModule]
    })
    export class AppRoutingModule { }

app.module.ts:

@NgModule({
 ..
  imports: [
    BrowserModule,
    FormsModule,
    AppRoutingModule // Added here.
  ],
  providers: [ShoppingListService],
  bootstrap: [AppComponent]
})
export class AppModule { }


app.component.html:

..
      <router-outlet></router-outlet>
..

--> This is the hook where the routes, defined in app-routing.module.ts start looking.


157. Adding Navigation to the App.

header.component
- ts: all content is removed.

  import { Component } from '@angular/core';

  @Component({
      selector: 'app-header',
      templateUrl: './header.component.html'
  })
  export class HeaderComponent {

  }

- html: use of 'routerLink'

  <nav class="navbar navbar-default">
      <div class="container-fluid">
          <div class="navbar-header">
              <a href="#" class="navbar-brand">Recipe Book</a>
          </div>
          <div class="navbar-collapse">
              <ul class="nav navbar-nav">
                  <!-- The selected item will be sent to parent app.component  -->
                  <li><a routerLink="/recipes">Recipes</a></li>
                  <li><a routerLink="/shopping-list">Shopping List</a></li>
              </ul>
              <ul class="nav navbar-nav navbar-right">
                  <li class="dropdown" appDropdown>
                      <a href="#" class="dropdown-toggle" role="button">Manage<span class="caret"></span></a>
                      <ul class="dropdown-menu">
                          <li><a href="#">Save Data</a></li>
                          <li><a href="#">Fetch Data</a></li>
                      </ul>
                  </li>
              </ul>
          </div>
      </div>
  </nav>

158. Marking Active Routes.

app.component.html:

..
            <ul class="nav navbar-nav">
                <!-- 
                    "active" is a bootstrap component.
                    routerLinkActive is an Angular attribute.
                -->
                <li routerLinkActive="active"><a routerLink="/recipes">Recipes</a></li>
                <li routerLinkActive="active"><a routerLink="/shopping-list">Shopping List</a></li>
            </ul>
..

--> Added: routerLinkActive="active" to both links. Now when clicking on 'Recipes' or 'Shopping-List' it will appear darker-grey.


159. Fixing Page Reload Issues.

160. Child Routes: Challenge.

161. Adding Child Routing Together.

$ ng generate component recipes/recipe-start --skip-tests

CREATE src/app/recipes/recipe-start/recipe-start.component.css (0 bytes)
CREATE src/app/recipes/recipe-start/recipe-start.component.html (27 bytes)
CREATE src/app/recipes/recipe-start/recipe-start.component.ts (298 bytes)
UPDATE src/app/app.module.ts (1494 bytes)

Details regarding the implementation will follow later.


162. Configuring Route Parameters.

163. Passing Dynamic Parameters to Links.

164. Styling Active Recipe Items.

165. Adding Editing Routes.

Enable:
- Create new recipes and adapt existing ones.

$ ng generate component recipes/recipe-edit --skip-tests

CREATE src/app/recipes/recipe-edit/recipe-edit.component.css (0 bytes)
CREATE src/app/recipes/recipe-edit/recipe-edit.component.html (26 bytes)
CREATE src/app/recipes/recipe-edit/recipe-edit.component.ts (294 bytes)
UPDATE src/app/app.module.ts (1602 bytes)

app-routing.module.ts:

Note:

const appRoutes: Routes = [
    // { path: '', component: HeaderComponent},
    { path: '', redirectTo: '/recipes', pathMatch: 'full'},
    { path: 
        'recipes', 
        component: RecipesComponent,
        children: [
            { path: '', component: RecipeStartComponent},
            { path: 'new', component: RecipeStartComponent },
            { path: ':id', component: RecipeDetailComponent },
            { path: ':id/edit', component: RecipeEditComponent}
        ]
    },
    { path: 'shopping-list', component: ShoppingListComponent}
];


166. Retrieving Route Parameters.

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Inequality
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Strict_inequality

JavaScript: !== vs != 

The inequality operator (!=) checks whether its two operands are not equal, returning a Boolean result. 
Unlike the strict inequality operator, it attempts to convert and compare operands that are of different types. 

The strict inequality operator (!==) checks whether its two operands are not equal, returning a Boolean result. 
Unlike the inequality operator, the strict inequality operator always considers operands of different types to be different. 

https://www.tutorialspoint.com/What-is-the-difference-between-null-and-undefined-in-JavaScript
In JavaScript, undefined is a type, whereas null an object.

https://codeburst.io/javascript-null-vs-undefined-20f955215a2

What is null?

There are two features of null you should understand:

    null is an empty or non-existent value.
    null must be assigned.

What is undefined?

Undefined most typically means a variable has been declared, but not defined.


167. Programmatic Navigation to the Edit Page.

Difference between: Router and ActivatedRoute

https://stackoverflow.com/questions/64074632/angular-activatedroute-vs-angular-router

Angular Router is a service that presents a particular component view for a given URL. 
The Router interprets the URL in the browser and handles navigation to the configured component. 
After the end of each successful navigation lifecycle, the router builds a tree of ActivatedRoute objects that make up the current state of the router.

AcivatedRoute is an injectable service that provides access to information about a route associated with a component such as the route path and URL parameters in the component.

Both of them are included in the package '@angular/router'. You can read more in the Angular Docs.

https://angular.io/guide/router


168. One Note about Route Observables.


169. Project Cleanup.


-------------------------------------------------
2022-01-31:

Todo:
- Study:
  - @angular/router
  - Route
  - ActivatedRoute
  - Router Common Tasks
  - RouterOutlet
  - Guard
  - Promise.
  - canActivate
    - https://angular.io/api/router/CanActivate
  - canActivateChild
    - https://angular.io/api/router/CanActivateChild
  - QueryParameters and Fragments.
- Go through the code of both (including setting up the structure):
  - routing-start
  - shopping-app-router.


https://angular.io/api/router

@angular/router
- package
- Contains:
  - Classes
  - Functions
  - Structures
  - Directives
  - Types

https://angular.io/guide/router
- Common Routing Tasks
  - Read and compared with the router projects routing-start and shopping-app-router.


===================================================================================================
2022-02-03:

Section 13: Understanding Observables.

170. Module Introduction.

What is an Observable?
- It is a data source.
  - (User Input) Events, Http Requests, Triggered in Code, etc.
- Imported from a 3rd party package: RxJS.
- Design Pattern:
  - Observer <==> Observable.

What is an Observer?
- The code (application)
- Types:
  - Handle Data
  - Handle Error
  - Handle Commpletion
  --> In these boxes the code will be executed.

Events:
- asynchronous
  - e.g. the Observable under a button. You don't want to wait until a button is pressed. The application needs to proceed.
- synchronous

171. Install RxJS.

  Install RxJS
  In order to follow along smoothly with the course examples, make sure you install RxJS v6 by running

  npm install --save rxjs@6
  In addition, also install the rxjs-compat package:

  npm install --save rxjs-compat


172. Analyzing Angular Observables.

Project: obs-01-start

$ ng new obs-01-start --routing --no-strict

Go to the root directory of the application:
$ ng serve

--> look at http://localhost:4200/

I have created: my-second-app

How to install:

$ cd /Users/rkremers/Development/workspaceJS/Angular/shopping-app
$ npm install --save bootstrap@3

$ npm install --save rxjs-compat

Now make Angular aware of this styling package.
- angular.json file.

            "styles": [
              "node_modules/bootstrap/dist/css/bootstrap.min.css", !! bootstrap.min.css has been added here.
              "src/styles.css"
            ],

Add FormsModule to app.module.ts

Go to the root directory of the application:
$ ng serve


Create a new component:

In a second terminal:
$ ng generate component recipes --spec false
--> the option --spec false is outdated.

Instead:

$ ng generate component home --skip-tests
$ ng generate component user --skip-tests


173. Getting Closer to the Core of Observables.

package.json:
..
    "rxjs": "~7.4.0",
    "rxjs-compat": "^6.6.7",
..

The difference is explained between Observables provided by Angular packages and Observables provided by a 3rd party, like RxJS.
See below:
- user.component.ts: Angular provided Observable: this.route.params
  - Does not need to be unsubscribed explicitly. Angular will take care of this.
- home.component.ts: RxJS provided Observable: interval(1000).subscribe()
  - Needs to be unsubscribed explicitly.
    - Not doing this will lead to memory leaks.

home.component.ts:

export class HomeComponent implements OnInit, OnDestroy {
  paramSubscription: Subscription;

  constructor() { }

  /**
   * A new interval that will fire a new value every second.
   */
  ngOnInit(): void {
    this.paramSubscription = interval(1000).subscribe(
      count => {
        console.log(count);
      });
  }

  /**
   * The subscription will not die after moving to another tab, i.e. component.
   * It needs to be explicitly unsubscribed.
   */
  ngOnDestroy(): void {
    this.paramSubscription.unsubscribe();
  }
}

user.component.ts:

export class UserComponent implements OnInit {
  id: number;

  constructor(private route: ActivatedRoute) {
  }

  /**
   * this.route.params is an Observable.
   * In this case an explicit unsubscribe is not necessary because, coming from this.route.params,
   * i.e. provided by Angular, Angular will do this for you.
   * If an Observable is provided by an Angular package Angular will also provide the unsubscribe().
   * 
   */
  ngOnInit() {
    this.route.params.subscribe(
      (params: Params) => {
        this.id = +params.id;
      });
  }
}


174. Building a Custom Observable.

In this paragraph the custom version of standard rxjs.interval Observable will be built.

home.component.ts:

  // 174. Building a Custom Observable.
  /**
   * An observer is the part of the Observable that is interested in:
   * - new data
   * - errors
   * - the Observable being completed.
   * The observer IS the listener.
   * 
   * The functionality below will have a custom counter and will provide this value, which is incremented
   * each time after 1000 msec.
   * 
   */
 customIntervalObservable = new Observable(
    observer => {
      let count = 0;
      setInterval( () => {
        observer.next(count++);
      }, 1000);
    }
  );

ngOnInit(): void {
    // 173. Getting Closer to the Core of Observables.
    // this.paramSubscription = interval(1000).subscribe(
    //   count => {
    //     console.log(count);
    //   });

    this.paramSubscription = customIntervalObservable.subscribe(
      data => {
        console.log(data);
      }
    );
  }

175. Errors & Completion.

Emitting data is the most important task of Observables.
in 99% of all cases the received data will be passed on.

home.component.ts:


  /**
   * 175. Errors & Completion.
   * Added the error.
   * Whenever a subscription encounters an error it stops. In that case unsubsription is not necessary.
   * When a subscription completes it is automatically also unsubscribed.
   * completion() does not have an argument.
   * If an error occurs before completion the completion will not be executed.
   * 
   */
 customIntervalObservable = new Observable(
    observer => {
      let count = 0;
      setInterval( () => {
        observer.next(count++);
        if (count > 5) {
          observer.complete();
        }
        if (count > 3) {
          observer.error(new Error('Count is > 3!'));
        }
      }, 1000);
    }
  );

  ngOnInit(): void {
    // 173. Getting Closer to the Core of Observables.
    // this.paramSubscription = interval(1000).subscribe(
    //   count => {
    //     console.log(count);
    //   });

    /**
     * 175. Errors & Completion.
     * Often the error message will be sent to the backend, or an alert will be shown.
     * If it needs to be reacted to a completion a completion handler can be used.
     */
    this.paramSubscription = this.customIntervalObservable.subscribe(
      data => {
        // Here functionality can be executed using the data.
        console.log(data);
      }, error => {
        console.log(error);
        alert(error.message)
      }, () => {
        // Here some cleanup work or anything else can be done.
        console.log('Completed!');
      });
  }

176. Observables & You.

Normally the Observables available from libraries will be used.
However it is important to understand the functionality.


177. Understanding Operators.


Operators are a feature of the RxJS library.

Data Stream
- Observable
  --> Subscription
    --> Observer

A more elegant way is:

Data Stream
- Observable
  - Operator: function: will do something with the data.
  --> Subscription
    --> Observer

 customIntervalObservable = new Observable(
    observer => {
      let count = 0;
      setInterval( () => {
        observer.next(count++);
        if (count > 7) {
          observer.complete();
        }
        if (count > 6) {
          observer.error(new Error('Count is > 6!'));
        }
      }, 1000);
    }
  );

  isEven(value: number): boolean {
    return ( value % 2 === 0);
  }

    /**
     * 177. Understanding Operators.
     * 
     * In order to us the pipe functionality subscribe to the result of the .pipe().
     * With .pipe() you can add one or more operators.
     * If you have more than one you add them as arguments:
     * .pipe( .., ..).
     * Each argument would be an operator from 'rxjs/operators'. By the way: these days available from 'rxjs'.
     * They will execute one after the other and will perform actions on the data.
     * 
     * Note that .subscribe() is deprecated in some cases: https://rxjs.dev/deprecations/subscribe-arguments
     * In future it will only take one argument, not multiple as is the case here.
     */
    this.paramSubscription = this.customIntervalObservable.pipe(filter( (data: number) => {
      return this.isEven( (data) );
    }), map( (data: number) => {
      return 'Round: ' + (data + 1);
    })).subscribe( 
      data => {
        // Here functionality can be executed using the data.
        console.log(data);
      }, 
      error => {
        console.log(error);
        alert(error.message)
      }, () => {
        // Here some cleanup work or anything else can be done.
        console.log('Completed!');
      }
      );


178. Subjects.

$ ng generate service user --skip-tests

The old approach for sending data was using an EventEmitter:

user.service.ts:
export class UserService {
  activatededEmitter = new EventEmitter<boolean>();

  constructor() { }
}

user.component
- ts:

export class UserComponent implements OnInit {
  id: number;

  constructor(    
    private route: ActivatedRoute,
    private  userService: UserService) {
  }

  onActivate() {
    this.userService.activatededEmitter.emit(true);
  }

- html:
<button class="btn btn-primary" (click)="onActivate()">Activate</button>

app.component:
- ts

  userActivated: boolean = false;

  ngOnInit(): void {
    this.userService.activatededEmitter.subscribe(
      didActivated => {
        this.userActivated = didActivated;
      }
    );
  }

- html:

  <p *ngIf="userActivated">Activated!</p>


Now the use of Subject() instead.

Observer --> Subscripion --> Observable
- Passive:
  - e.g. wraps callback, event, ....
  - .next() will perform a follow up action here.

Observer --> Subscription --> Subject <-- next()
- Active
  - Can be triggered in code  via .next().

Subject vs Event Emitter

  Please tell me the clear differences between Subject and Event Emitter and why is Subject recommended over Event Emitter?

  Hi!

  Subject.next() does the same like EventEmitter.emit(): It emits an event.

  Angular's EventEmitter extends RxJS' Subject; the implementation differences are not relevant,thus both could be used interchangeably.

  The official docs use ...

  ● EventEmitter in connection with @Output() and event binding in direct child/parent communication, and

  ● Subjects in connection with Subscriptions in cross component communication.

  From a technical point of view this is just a convention. And it's good to follow this convention (even though it might just be based on historical reasons), using different tools for different tasks.

  In this way we can always recognize at first sight in which way the event will be received on the other end (with @Output() and event binding or with a Subscription).

  Important:

  If you would use an EventEmitter with a Subscription, you would have to unsubscribe in the same way like when using a Subject.

  Jost

Using Subject() in the code:


user.service.ts:
export class UserService {
  // activatededEmitter = new EventEmitter<boolean>();

  activatededEmitter = new Subject<boolean>();

  constructor() { }
}

user.component
- ts:

export class UserComponent implements OnInit {
  id: number;

  constructor(    
    private route: ActivatedRoute,
    private  userService: UserService) {
  }

  onActivate() {
    // this.userService.activatededEmitter.emit(true);

    /**
     * .next() is used because Subject() is a special kind of observable.
     */
    this.userService.activatededEmitter.next(true);
  }

- html:
<button class="btn btn-primary" (click)="onActivate()">Activate</button>

app.component:
- ts

  userActivated: boolean = false;
  subscription: Subscription;

  ngOnInit(): void {
    this.userService.activatededEmitter.subscribe(
      didActivated => {
        this.userActivated = didActivated;
      }
    );
  }

  ngOnDestroy(): void {
    this.subscription.unsubscribe();
  }

- html:

  <p *ngIf="userActivated">Activated!</p>

Notes:
- In case of Cross Component Communication it is recommended to use Subjects instead of EventEmitters.
  Behind the scenes Subjects are more efficient.
- You don't use Subjects in case of @Output().


179. Wrap Up.

- Observables, in combination with Maps and Filters are very useful in data handling.
- In case of Cross Component Communication it is recommended to use Subjects instead of EventEmitters.


180. Useful Resources & Links.

Useful Resources:

Official Docs: https://rxjs-dev.firebaseapp.com/
--> https://rxjs-dev.firebaseapp.com/deprecations/breaking-changes
  - This documents deprecated functionality.

RxJS Series: https://academind.com/learn/javascript/understanding-rxjs/

Updating to RxJS 6: https://academind.com/learn/javascript/rxjs-6-what-changed/ 


===================================================================================================
2022-02-05:

Section 14: Course Project - Observables.

181. Improving the Reactive Service with Observables (Subjects).

EventEmitter is replaced by Subject as discussed in the previous chapter.

shopping-list.service.ts:

  // ingredientsChanged = new EventEmitter<Ingredient[]>();
  ingredientsChanged = new Subject<Ingredient[]>();

  addIngredient(ingredient: Ingredient) {
    this.ingredients.push(ingredient);
    // this.ingredientsChanged.emit(this.ingredients.slice());
    this.ingredientsChanged.next(this.ingredients.slice());
  }

  addIngredients(ingredients: Ingredient[]) {
    /**
     * Here the spread input is used. Also known in Java.
     */
    this.ingredients.push(...ingredients);
    // this.ingredientsChanged.emit(this.ingredients.slice());
    this.ingredientsChanged.next(this.ingredients.slice());
  }

shopping-list.component.ts:

export class ShoppingListComponent implements OnInit, OnDestroy {
  ingredients: Ingredient[];
  private subscription: Subscription;

    ngOnDestroy(): void {
    this.subscription.unsubscribe();
  }


  ===================================================================================================
2022-02-05:

Section 15. Handling Forms in Angular Apps.

183. Module Intrduction.


184. Why do we Need Angular's Help?


<form>
  <label>Name</label>
  <input type="input" name="name"></input>
  <label>Mail</label>
  <input type="input" name="email"></input>
  <button type="submit">Save</button>
</form>

In Angular could look like this after parsing:

{
  value: {
    name: 'Max',
    email: 'test@test.com'
  }
}


185. Template-Driven (TD) vs Reactive Approach.

Template-Driven:
- The Form is set up in html.
- Angular infers the Form Object from the DOM.
Reactive:
- Form is created programmatically and synchronized with the DOM.


186. An Example Form.

Resource:
- forms-td-start.zip

$ ng new forms-td-start --routing --no-strict
  Choose CSS styling

Go to the root directory of the application:
$ ng serve

--> look at http://localhost:4200/

How to install:

$ cd /Users/rkremers/Development/workspaceJS/Angular/forms-td-start
$ npm install --save bootstrap@3

This will download bootstrap locally. Not globally.

Will install in the node_modules folder.

Now make Angular aware of this styling package.
- angular.json file.

            "styles": [
              "node_modules/bootstrap/dist/css/bootstrap.min.css", !! bootstrap.min.css has been added here.
              "src/styles.css"
            ],

Add FormsModule to app.module.ts

$ npm install --save rxjs-compat

Go to the root directory of the application:
$ ng serve

--> http://localhost:4200/


The purpose of this form setup is that it will be handled by Angular.

Probably look first at: https://www.w3schools.com/html/html_forms.asp


187. TD: Creating the Form and Registering the Controls.

Ensure that FormsModule is imported in app.module.ts.
- With this module present Angular will automatically create a Form representation if it detects a <form> element.
- Angular will not automatically detect your imports in this form. You still have to add this information.

For this ngModel is used.
- ngModel has already been used for Two-Way-Binding     : [(ngModel)]="data"
- Now it will be used in a different way.

Note:
HttpModule is deprecated and does not exist anymore.

Implementation:

app.component.html:

            <!-- 
              Adding ngModel here tells Angular: this input is a control of my form. 
              Whatever is entered as a value should be the value or name of that control.
              For this the html attribute 'name' is used.
            -->
            <input type="text" id="username" class="form-control" ngModel name="username">

            <input type="email" id="email" class="form-control" ngModel name="email">

            <select id="secret" class="form-control" ngModel name="secret">


188. TD: Submitting and Using the Form.

189.TD: Understanding Form State.

NgForm
- form
  - value:
    - email: "robkremers@hotmail.com"
    - secret: "teacher"
    - username: "rkremers"
--> The input parameters of the form.
--> This form is set up by Angular.

app.component:
- html:

  <div class="container">
    <div class="row">
      <div class="col-xs-12 col-sm-10 col-md-8 col-sm-offset-1 col-md-offset-2">
        <!-- 
          187. TD: Creating the Form and Registering the Controls.
          188. TD: Submitting and Using the Form.
          ngSubmit is an Angular directive that will be triggered by the submit button.
          See addition explanation below.
          Template Driven Development: every functionality is added to the Template.

          #form="ngForm":
          - Tells Angular to give access to the form that has been created automactically by Angular.
        -->
        <form id="Angular-Submit-Form" name="Angular-Submit-Form" (ngSubmit)="onSubmit(form)" #form="ngForm">
          <div id="user-data">
            <div class="form-group">
              <label for="username">Username</label>
              <!-- 
                Adding ngModel here tells Angular: this input is a control of my form. 
                Whatever is entered as a value should be the value or name of that control.
                For this the html attribute 'name' is used.
              -->
              <input type="text" id="username" class="form-control" ngModel name="username">
            </div>
            <button class="btn btn-primary" type="button">Suggest a Username</button>
            <div class="form-group">
              <label for="email">Mail</label>
              <input type="email" id="email" class="form-control" ngModel name="email">
            </div>
          </div>
          <div class="form-group">
            <label for="secret">Secret Questions</label>
            <select id="secret" class="form-control" ngModel name="secret">
              <option value="pet">Your first Pet?</option>
              <option value="teacher">Your first teacher?</option>
            </select>
          </div>
          <!-- 
            A button of type 'submmit' will trigger the default behavior of the form 
            It will send a request normally.
            Besides that it will also trigger a JavaScript event: the submit event.
            This behaviour is built into HTML / JavaScript.
          -->
          <button class="btn btn-primary" type="submit">Submit</button>
        </form>
      </div>
    </div>
  </div>

- ts:

  export class AppComponent {
    title = 'forms-td-start';

    suggestUserName() {
      const suggestedName = 'Superuser';
    }

    /**
     * 188. TD: Submitting and Using the Form.
     * 
     * By sending 'form' to the console now a lot of information is visible.
     * - Among them:
     *  
     * 
     * @param form: NgForm: An element in the DOM; it allows access to and in some cases modification 
     *              of aspects of the form, as well as access to its component elements
     *              This is what has been accessed in app.component.html:
     *              - (ngSubmit)="onSubmit(form)" #form="ngForm"
     * 
     */
    onSubmit(form: NgForm) {
      console.log(form);
    }

  }

  Todo:
  - Understand why the '#' is used in front of '#ngForm'.
    - Normally '#' indicates a local reference.


190. TD: Accessing the Form with @ViewChild

Reference:
- https://angular.io/api/core/ViewChild

ViewChild
decorator

Property decorator that configures a view query. 
The change detector looks for the first element or the directive matching the selector in the view DOM. 
If the view DOM changes, and a new child matches the selector, the property is updated.

See also paragraph 76.

The use of @ViewChild.
This gives access to the DOM and the variables / attributes in the html-template.
Circumvents the use of input parameters for the class methods.

Using @ViewChild is especially useful if you need to access the form even before submitting.
@ViewChild gives access to the DOM and the variables / attributes in the html-template.
Now the onSubmit() method does not have an input parameter anymore.
@ViewChild allows to access a local reference. In this case #form. 

Implementation:

app.component:
- ts:

  @ViewChild('form') signupForm: NgForm;

    onSubmit() {
    console.log(this.signupForm);
  }

- html:

<!--
  190. TD: Accessing the Form with @ViewChild.
  This gives access to the DOM and the variables / attributes in the html-template.
  Now the onSubmit() method does not have an input parameter anymore.
  @ViewChild allows to access a local reference. In this case #form. 
-->
<form id="Angular-Submit-Form" name="Angular-Submit-Form" (ngSubmit)="onSubmit()" #form="ngForm">


191. TD: Adding Validation to check User Input.

You need to  validate input in the server since input from a frontend can always be tricked.
However it can be useful to nonetheless validate at the frontend.

In a Template Driven approach we can only add validations in the template.

A list of all built-in Validators can be found in a later Lecture.

app.component.html:

            <!-- 
              Adding ngModel here tells Angular: this input is a control of my form. 
              Whatever is entered as a value should be the value or name of that control.
              For this the html attribute 'name' is used.

              191. TD: Adding Validation to check User Input.
              required is a valid HTML attribute.
              Here Angular will detect it so it will act as a selector for a built in directive
              shipping with Angular. It will automatically configure your form to take this
              into account. The input will be treated as invalid if it is empty.

            -->
            <input 
              type="text" 
              id="username" 
              class="form-control" 
              ngModel 
              name="username"
              required
              >

            <!-- 
              191. TD: Adding Validation to check User Input.
              required: see above.
              email: another Angular directive that ensures that the input is a valid address.
            -->
            <input 
              type="email" 
              id="email" 
              class="form-control" 
              ngModel 
              name="email"
              required
              email="">

If you click the 'Submit' button while the input fields are empty and you look at Developer Tool | Console:
NgForm:
- dirty: false # No input was received.
- invalid: true
- valid: false.

Only if the input fields are filled in correctly NgForm | valid == true.

This does not only work at the form level:
NgForm | form | controls | email | status: "VALID" !!

Also:

If the inputfield email is selected it is visible in Developer Tools | Elements that a number of classes have been added:

<input 
_ngcontent-wdo-c48="" 
type="email" 
id="email" 
ngmodel="" 
name="email" 
required="" 
email="" 
class="form-control ng-dirty ng-touched ng-valid" # Added by Angular.
ng-reflect-model="" 
g-reflect-name="email" 
ng-reflect-required="" 
ng-reflect-email="">

If the content changes from a valid to an invalid email address the class 'ng-valid' changes to 'ng-invalid'.
In this way we can receive information about the state of an input field.


192. Built-in Validators & Using HTML5 Validation.

Which Validators do ship with Angular? 

Check out the Validators class: https://angular.io/api/forms/Validators 
- these are all built-in validators, though that are the methods which actually get executed (and which you later can add when using the reactive approach).

For the template-driven approach, you need the directives. 
You can find out their names, by searching for "validator" in the official docs: https://angular.io/api?type=directive 
- everything marked with "D" is a directive and can be added to your template.

Additionally, you might also want to enable HTML5 validation (by default, Angular disables it). 
You can do so by adding the ngNativeValidate to a control in your template.


193. TD: Using the Form State.

In previous lessons we found that Angular tracks the state of a Form.
This is visible in Developer Tool | Console -> ngForm with a lot of content: css, field id's, etc.

With that information you can go back to the code and use this.

app.component.css:

Multiple ways are possible:

input.ng-valid, select.ng-valid {
    border: 1px solid red;
}

Or

input.ng-invalid.ng-touched {
    border: 1px solid red;
}

--> ng-valid, ng-touched will have the values as shown in Developer Tool | Console -> ngForm.

194. TD: Outputting Validation Error Messages.

app.component.html

A local reference #email is associated with ngModel.
ngModel also, like ngForm, exposes information about the control it creates for us.
The Form directive is automatically added by Angular when it detects a form element.
ngModel acts in the same way.
The <span> with the text shows an easy way to access control-edit by Angular.

            <input 
              type="email" 
              id="email" 
              class="form-control" 
              ngModel 
              name="email"
              required
              email
              #email="ngModel"> !!!! ngModel -->  local reference #email="ngModel" --> "!email.valid && email.touched" below in the <span> element.
          </div>
          <span class="help-block" *ngIf="!email.valid && email.touched">Please enter a valid value!</span>


195. TD: Set Default Values with ngModel Property Binding.

          <!-- 
            195. TD: Set Default Values with ngModel Property Binding.
            Property Binding:
            [ngModel]="defaultQuestion" TS ==> Output Data ==> HTML
            Now in the web page the default Secret Question is "Your first Pet?".
          -->
          <select 
            id="secret" 
            class="form-control" 
            [ngModel]="defaultQuestion" 
            name="secret">
            <option value="pet">Your first Pet?</option>
            <option value="teacher">Your first teacher?</option>
          </select>

196. TD: Using ngModel with Two-Way-Binding.

Sometimes you not only want to pre-populate the default value but you want to instantly react to any changes.
ngModel is used either without binding or with one-way binding.
But you can use it with  Two-Way-Binding.

        <!-- 
          196. TD: Using ngModel with Two-Way-Binding.
          [(ngModel)] is connected with the property 'answer' declared in app.component.ts.
          The content of the textarea will be visible immediately in the paragraph 'Your reply:'.
          When the button 'Submit' is clicked a snapshot of the content is taken and visible
          in Development Tool | Console -> ngForm.
          (but only once. Apparently the form needs to be told to submit again)
        -->
        <div class="form-group">
          <textarea 
            name="questionAnswer" 
            rows="3"
            class="form-control"
            [(ngModel)]="answer"
            ></textarea>
        </div>
        <p>Your reply: {{ answer }}</p>

ngModel can be used in all three cases:
- No-way-binding: just tell Angular that an input field is a control.
- One-way-binding: to give that control a default value.
- Two-way-binding: to instantly do something with it.


197. TD: Grouping Form Controls.

Now we want to group some parts, e.g. the secret and the questionAnswer.
It would be advantageous if we would to check the combined values of properties.

<div _ngcontent-sqs-c48="" id="user-data" ngmodelgroup="userData" ng-reflect-name="userData" class="ng-dirty ng-touched ng-valid"><div _ngcontent-sqs-c48="" class="form-group"><label _ngcontent-sqs-c48="" for="username">Username</label><input _ngcontent-sqs-c48="" type="text" id="username" ngmodel="" name="username" required="" class="form-control ng-dirty ng-valid ng-touched" ng-reflect-model="" ng-reflect-name="username" ng-reflect-required=""></div><button _ngcontent-sqs-c48="" type="button" class="btn btn-primary">Suggest a Username</button><div _ngcontent-sqs-c48="" class="form-group"><label _ngcontent-sqs-c48="" for="email">Mail</label><input _ngcontent-sqs-c48="" type="email" id="email" ngmodel="" name="email" required="" email="" class="form-control ng-dirty ng-valid ng-touched" ng-reflect-model="" ng-reflect-name="email" ng-reflect-required="" ng-reflect-email=""></div><!--bindings={
  "ng-reflect-ng-if": "false"
}--></div>

        <!--
          197. TD: Grouping Form Controls.
          This is done by using 'ngModelGroup'.
          Below <div id="user-data" already contains the input-fields 'username' and 'email'.
          With ngModelGroup="userData" these input-fields will now be formally grouped together.
          Result:
          In Developer Tool | Console: ngForm is now visible that form | value contains:
          - userData: {username: 'rkremers', email: 'robkremers@hotmail.com'}.
          Also in ngForm | controles we have a group:
          - userData: with a lot of data controls.

          In Developer Tool | Elements you see:
          <div _ngcontent-sqs-c48="" id="user-data" ngmodelgroup="userData" with a lot of properties.
          So this can be used for overview / control. 

          You can access these properties and their values via a local reference property:
        -->
        <div 
          id="user-data" 
          ngModelGroup="userData"
          #userData="ngModelGroup"
          >
          ..

        </div>
        <!-- 
          197. TD: Grouping Form Controls.
          Example of the use of formGroup properties access via local reference property: #userData.
        -->
        <p *ngIf="!userData.valid && userData.touched">User Data is invalid!</p>


198. TD: Handling Radio Buttons.

        <!--
          198. TD: Handling Radio Buttons.

          Below ngModel is added to make it a control.
          Also used via Property Binding to set a standard value.
          The attribute 'required' will ensure that the 'Submit' button will only be usable if a selection
          is made.
        -->
        <div class="radio" *ngFor="let gender of genders">
          <label>
            <input 
              type="radio" 
              name="gender" 
              [ngModel]="defaultGender" 
              [value]="gender"
              required> 
              {{ gender }}
          </label>
        </div>


199. TD: Setting and Patching Form Values.

app.component:
- ts

  /**
   * 199. TD: Setting and Patching Form Values.
   * One approach: this.signupForm.setValue()
   * - all fields need to receive an a value. Otherwise an error will occur.
   * - now all fields will receive a suggested value.
   * - Disadvantage: it would override already existing values.
   * Other approach: this.signupFrom.form.patchValue()
   * - now only specific fields can be given a value.
   * - no error will occur if the other fields remain empty.
   * 
   */
  suggestUserName() {
    const suggestedName = 'Superuser';
    // this.signupForm.setValue({
    //   userData: {
    //     username: suggestedName,
    //     email: ''
    //   },
    //   secret: 'pet',
    //   questionAnswer: '',
    //   gender: 'male'
    // });
    this.signupForm.form.patchValue({
      userData: {
        username: suggestedName
      }
    });
  }

- html:

            <!-- 
              ..

              199. TD: Setting and Patching Form Values.
              One way to add a suggested username to input field username via the button 'Suggest a Username'
              would be Two-Way-Binding.
              Here another way is shown.

            -->
            <input 
            qtype="text" 
            id="username" 
            class="form-control" 
            ngModel 
            name="username" 
            required>
          </div>
          <button 
            class="btn btn-primary" 
            type="button"
            (click)="suggestUserName()">
            Suggest a Username
          </button>


200. TD: Using Form Data.

app.component
- ts

  user = {
    username: '',
    email: '',
    secretQuestion: '',
    answer: '',
    gender: ''
  };
  submitted: boolean = false;

  /**
   * 200. TD: Using Form Data.
   * 
   * This.signupFrom.value.<name of the element>!!!
   * Thus the name of the property in this class may be different in the html page.
   * So this could be a reason to equalize the values of these properties.
   */
  onSubmit() {
    console.log(this.signupForm);
    this.submitted = true;
    this.user.username = this.signupForm.value.userData.username;
    this.user.email = this.signupForm.value.userData.email;
    this.user.secretQuestion = this.signupForm.value.secretQuestion;
    this.user.answer = this.signupForm.value.questionAnswer;
    this.user.gender = this.signupForm.value.gender;

  }

- html

  <!-- 
    200. TD: Using Form Data.
  -->
  <div class="row" *ngIf="submitted">
    <div class="col-xs-12">
      <h3>Your Data</h3>
      <p>Username: {{ user.username }}</p>
      <p>Mail: {{ user.email }}</p>
      <p>Secret Question: {{ user.secretQuestion }}</p>
      <p>Answer: {{ user.answer }}</p>
      <p>Gender: {{ user.gender }}</p>
    </div>
  </div>


201. TD: Resetting Forms.

   * 201. TD: Resetting Forms.
   * 
   * this.signupForm.reset();
   * When looking in Developer Tool | Elements the properties will now
   * show class = 'ng-untouched ng-pristine ng-invalid' (depending on the element).
   * It's like the page has been reloaded.
   * 
   */
  onSubmit() {
    ..

    this.signupForm.reset();
  }


Assignment 6: Practicing Template-Driven Forms

Time to practice the creation and usage of template-driven forms. This assignment allows you to register your controls and use the form created by Angular.

Use:
- forms-td-assignment-start.zip


$ ng new forms-td-assignment-start --routing --no-strict --defaults

Go to the root directory of the application:
$ ng serve

--> look at http://localhost:4200/

I have created: my-second-app

How to install:

$ cd /Users/rkremers/Development/workspaceJS/Angular/forms-td-assignment-start
$ npm install --save bootstrap@3

Now make Angular aware of this styling package.
- angular.json file.

            "styles": [
              "node_modules/bootstrap/dist/css/bootstrap.min.css", !! bootstrap.min.css has been added here.
              "src/styles.css"
            ],

Add FormsModule to app.module.ts

$ npm install --save rxjs-compat

Go to the root directory of the application:
$ ng serve


Create a new component:

In a second terminal:
$ ng generate component recipes --spec false
--> the option --spec false is outdated.

Instead:

$ ng generate component recipes --skip-tests

Create a new directive:

$ ng generate directive <name>

Create a new service:

$ ng generate service user --skip-tests


Task:

<!-- Add a Form with the following Inputs (and Validators)
     1) Mail address (should not be empty and should be an email address)
     2) A Dropdown which allows the user to select from three different Subscriptions ("Basic", "Advanced", "Pro")
        Set "Advanced" as Default
     3) A Password field (should not be empty)
     4) A Submit Button

     Display a warning message if the Form is invalid AND was touched. Display a warning message below each input if it's invalid.

     Upon submitting the form, you should simply print the Value of the Form to the Console.
     Optionally, display it in your template.
-->


Questions for this assignment
Please complete the tasks outlined in the instructions video. Why did you choose the approach you took? Which problems did you encounter?


Result:

app.component:
- ts: 

import { Component, ViewChild } from '@angular/core';
// This is necessary for the html even if it is not being used in this class at the moment.
import { NgForm, NgControl } from '@angular/forms';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title = 'forms-td-assignment-start';

  @ViewChild('form') signupForm: NgForm;

  defaultMailAddress: string = 'default@mail.com';
  
  subscriptions: string[] = ['Basic', 'Advanced', 'Pro'];
  defaultSubscription: string = 'Advanced';

  defaultPassword: string = 'password123';

  submitted: boolean = false;

  input = {
    email: '',
    subscription: '',
    password: ''
  };

  onSubmit() {
    console.log(this.signupForm);

    this.input.email = this.signupForm.value.email;
    this.input.subscription = this.signupForm.value.subscription;
    this.input.password = this.signupForm.value.password;
    this.submitted = true;

    // this.signupForm.reset();
  }
}

- html:

<div class="container">
  <div class="row">
    <div class="col-xs-12 col-sm-10 col-md-8 col-sm-offset-1 col-md-offset-2">
      <!-- Add a Form with the following Inputs (and Validators)
           1) Mail address (should not be empty and should be an email address)
           2) A Dropdown which allows the user to select from three different Subscriptions ("Basic", "Advanced", "Pro")
              Set "Advanced" as Default
           3) A Password field (should not be empty)
           4) A Submit Button

           Display a warning message if the Form is invalid AND was touched. Display a warning message below each input if it's invalid.

           Upon submitting the form, you should simply print the Value of the Form to the Console.
           Optionally, display it in your template.
      -->
      <form id="Angular-Submit-Form" name="Angular-Submit-Form" (ngSubmit)="onSubmit()" #form="ngForm">

        <!-- 
          email an Angular directive that will test whether the input is syntactically correct 
          ngModel needs to be added in order to tell Angular that this is an active control in this form.
        -->
        <div class="form-group">
          <label for="email">Email</label>
          <input type="email" id="email" name="email" class="form-control" required [ngModel]="defaultMailAddress" email #email="ngModel">
          <span class=help-block *ngIf="!email.valid && email.touched">The input for the email is invalid!</span>
        </div>

        <!-- A value other than the provided ones can not be chosen. Therefore a warning message below is not necessary. -->
        <!--
          [ngModel] because of One-Way-Binding.
        -->
        <div class="form-group">
          <label for="subscription">Subscription</label>
          <select name="subscription" id="subscription" class="form-control" required [ngModel]="defaultSubscription">
            <option *ngFor="let subscription of subscriptions" [value]="subscription">
              {{ subscription }}
            </option>
          </select>
        </div>

        <div class=form-group>
          <label for="password">Password</label>
          <input type="password" name="password" id="password" class="form-control" required [ngModel]="defaultPassword" #password="ngModel">
          <span class=help-block *ngIf="!password.valid && password.touched">The input for the password is invalid!</span>
        </div>

        <button class="btn btn-primary" type="submit">Submit</button>
      </form>
    </div>
  </div>
  <hr>
  <div class="row" *ngIf="submitted">
    <div class="col-xs-12">
      <h3>The Input Data</h3>
      <p>Email: {{ input.email }}</p>
      <p>Subscription: {{ input.subscription }}</p>
      <p>Password: {{ input.password }}</p>
    </div>
  </div>
</div>


- cs:

.container {
    margin-top: 30px;


Please complete the tasks outlined in the instructions video. Why did you choose the approach you took? Which problems did you encounter?

The main problem was to figure out how to set up a dropdown list for a Template-Driven form.
I have googled that solution.

Within the form I have used three form-groups, for the respective input fields and their labels, in order to keep the setup well ordered.
I have declared the default values for email, subscription and password in the controller class in order not to use hard-coded values in the html-code.
For the same reason I have declared the possible values for the subsciptions in the controller class.
All three input parameters were required so I have added the html attribute 'required' to eacht input field.
I could not find an Angular password directive.


***************************************************************************************************
2022-02-21:

Now the reactive approach.

202. Introduction to the Reactive Approach.


203. Reactive: Setup.


Reactive Approach:
- Form is created programmatically and synchronized with the DOM.

Use: forms-reactive-start.zip

Now you need to import ReactiveFormsModule in app.module.ts

app.component.ts

import { FormGroup } from '@angular/forms';

export class AppComponent {
  genders: string[] = ['male', 'female'];
  signupForm: FormGroup;

}

Use:
- forms-reactive-start.zip


$ ng new forms-reactive-start --routing --no-strict --defaults

Go to the root directory of the application:
$ ng serve

--> look at http://localhost:4200/


How to install:

$ cd /Users/rkremers/Development/workspaceJS/Angular/forms-reactive-start
$ npm install --save bootstrap@3

Now make Angular aware of this styling package.
- angular.json file.

            "styles": [
              "node_modules/bootstrap/dist/css/bootstrap.min.css", !! bootstrap.min.css has been added here.
              "src/styles.css"
            ],

Add FormsModule to app.module.ts

$ npm install --save rxjs-compat

Go to the root directory of the application:
$ ng serve --port 4202


Create a new component:

In a second terminal:
$ ng generate component recipes --spec false
--> the option --spec false is outdated.

Instead:

$ ng generate component recipes --skip-tests

Create a new directive:

$ ng generate directive <name>

Create a new service:

$ ng generate service user --skip-tests


204. Reactive: Synching HTML and Form.

Background:
- https://angular.io/guide/reactive-forms
- https://angular.io/api/forms/FormControl


205. Reactive: Submitting the form.

206. Reactive: Submitting the Form.

207. Reactive: Adding Validation.

208. Reactive: Getting Access to Controls.

209. Reactive: Grouping Controls.

Nested FormGroups are possible.
In the following 'username' and 'email' are grouped in a nested FormGroup 'userData'.
This needs to be synchronized in ts and in html.

app.component:
- ts: 

export class AppComponent implements OnInit {
  genders = ['male', 'female'];
  signupForm: FormGroup;

  ngOnInit(): void {
    this.signupForm = new FormGroup({
      'userData': new FormGroup({
        'username': new FormControl(null, Validators.required),
        'email': new FormControl(null, [Validators.required, Validators.email]),
      }),
      'gender': new FormControl('male')
    });
  }

  /**
   * 206. Reactive: Submitting the Form.
   * console.log(this.signupForm) --> will show the form in Developer Tool | Console.
   */
  onSubmit() {
    console.log(this.signupForm);
  }
}

- html:

        <div formGroupName="userData">
          <div class="form-group">
            <label for="username">Username</label>
            <input type="text" id="username" formControlName="username" class="form-control">
            <span *ngIf="!signupForm.get('userData.username').valid && signupForm.get('userData.username').touched" class="help-block">
              Please enter a valid username!
            </span>
          </div>
          <div class="form-group">
            <label for="email">email</label>
            <input type="text" id="email" formControlName="email" class="form-control">
            <span *ngIf="!signupForm.get('userData.email').valid && signupForm.get('userData.email').touched" class="help-block">
              Please enter a valid mail address!
            </span>
          </div>
        </div>


210. Fixing a bug.


In the next lecture, we'll add some code to access the controls of our form array:

*ngFor="let hobbyControl of signupForm.get('hobbies').controls; let i = index"

This code will fail as of the latest Angular version.

You can fix it easily though. Outsource the "get the controls" logic into a method of your component code (the .ts file):

getControls() {
  return (<FormArray>this.signupForm.get('hobbies')).controls;
}
In the template, you can then use:

*ngFor="let hobbyControl of getControls(); let i = index"

Alternatively, you can set up a getter and use an alternative type casting syntax:

get controls() {
  return (this.signupForm.get('hobbies') as FormArray).controls;
}
and then in the template:

*ngFor="let hobbyControl of controls; let i = index"

This adjustment is required due to the way TS works and Angular parses your templates (it doesn't understand TS there).


211. Reactive: Arrays of Form Controls (FormArray).

Allowing to dynamically add Form Controls.

app.component
- ts
  /**
   * 211. Reactive: Arrays of Form Controls (FormArray).
   * The new FormArray 'hobbies' could already be initiated here with one or more FormControls.
   */
  ngOnInit(): void {
    this.signupForm = new FormGroup({
      'userData': new FormGroup({
        'username': new FormControl(null, Validators.required),
        'email': new FormControl(null, [Validators.required, Validators.email]),
      }),
      'gender': new FormControl('male'),
      'hobbies': new FormArray([])
    });
  }

  /**
   * 211. Reactive: Arrays of Form Controls (FormArray).
   * Allowing to dynamically add Form Controls.
   */
  onAddHobby() {
    const control = new FormControl(null, Validators.required);
    (<FormArray>this.signupForm.get('hobbies')).push(control);
  }

  /**
   * 210. Fixing a bug.
   * @returns FormArray([])
   */
  getControls() {
    return (<FormArray>this.signupForm.get('hobbies')).controls;
  }

- html:

        <!--
          210. Fixing a bug.
            Here I have used as an updated method:
              *ngFor="let hobbyControl of getControls(); let i = index"
            Alternatively, you can set up a getter and use an alternative type casting syntax:
              getControls() {
                return (this.signupForm.get('hobbies') as FormArray).controls;
              }
              and then in the template:

              *ngFor="let hobbyControl of controls; let i = index"
          
          211. Reactive: Arrays of Form Controls (FormArray).
            Allowing to dynamically add Form Controls.
            ts and html need to be synchronized as shown below (and in ts).
         -->
         <hr>
        <div formArrayName="hobbies">
          <h4>Your Hobbies</h4>
          <button 
            class="btn btn-primary" 
            type="button" 
            (click)="onAddHobby()">Add Hobby</button>
            <div 
              class="form-group"
              *ngFor="let hobbyControl of getControls(); let i = index">
              <!-- Property Binding is needed because a local variable is passed. -->
              <input type="text" class="form-control" [formControlName]="i">
            </div>
        </div>


212. Reactive: Creating Custom Validators.

app.component
- ts:

   * 212. Reactive: Creating Custom Validators.
   * 
   * A custom validator forbiddenNames is created and added to the 'username' FormControl.
   * In order to work properly it needs to be bound via this.forbiddenNames.bind(this).
   */
  ngOnInit(): void {
    this.signupForm = new FormGroup({
      'userData': new FormGroup({
        'username': new FormControl(null, [Validators.required, this.forbiddenNames.bind(this)]),
        'email': new FormControl(null, [Validators.required, Validators.email]),
      }),
      'gender': new FormControl('male'),
      'hobbies': new FormArray([])
    });
  }

  /**
   * 212. Reactive: Creating Custom Validators.
   * 
   * A validator is a functionality that is automatically executed by Angular when it checks the validity of the FormControl.
   * Now if e.g. 'Anna' is typed the Developer Tool | Elements will show: class = ng-invalid.
   */
  forbiddenNames(control: FormControl): {[s: string]: boolean} {
    /**
     * If the value is NOT part of the array the value '-1' will be returned. 
     */
    if (this.forbiddenUsernames.indexOf(control.value) !== -1) {
      return {'nameIsForbidden': true};
    }
    /**
     * At this point the return should be null or be omitted.
     * Any other possibility is false.
     */
    return null;
  }

- html:

No changes.


213. Reactive: Using Error Codes.

In Developer Tool the error if 'Anna' is typed in the Username field is present in:

Console:
- controls
  - userData
    - controls
      - username
        - errors:
          - nameIsForbidden: true

If nothing is typed in (just click on the Username field and move away):
Console:
- controls
  - userData
    - controls
      - username
        - errors:
          - required: true

This can be used to finetune a message.
e.g. we want to say: this field is empty or this field contains an invalid value.

The properties found in Development Tool | Console can be used to finetune the error messages:

app.component
- ts:

No changes.

- html:

      <form [formGroup]="signupForm" (submit)="onSubmit()">
        <div formGroupName="userData">
          <div class="form-group">
            <label for="username">Username</label>
            <input type="text" id="username" formControlName="username" class="form-control">
            <span 
              *ngIf="!signupForm.get('userData.username').valid && signupForm.get('userData.username').touched" 
              class="help-block">
              <span *ngIf="signupForm.get('userData.username').errors['nameIsForbidden']">This name is invalid!</span>
              <span *ngIf="signupForm.get('userData.username').errors['required']">This field is required!</span>          
            </span>
          </div>

Possible tricks:

One possible fix should be to use this code:

<span *ngIf="signupForm.get('userData.username').errors?.required">Name Required</span>

Max

!! Note the '?' in '.errors?'

Or use: hasError().

Also see:

<span class="help-block" *ngIf="!signupForm.get('name').valid && signupForm.get('name').touched">
  <span *ngIf = "signupForm.get('name').hasError['forbiddenName']">You can't give it this name</span>
  <span *ngIf = "signupForm.get('name').hasError['required']">This is a required field</span>
</span>

forbiddenNamesAsync(control: FormControl): Promise<any> | Observable <any>{
    const promise = new Promise((resolve, reject) => {
      setTimeout(() => {
        if (control.value === 'testproject') {
          resolve({'forbiddenName': true});
        }else{
          resolve(null);
        }
      }, 1500);
    });
    return promise;
  }

So: changing .errors[] to .hasError[] may make a difference.

Check again: what is a promise.


214. Reactive: Creating a Custom Async Validator.


Asynchronous validators will wait until the response comes in, e.g. because it has to be returned from a webservice.

app.component.ts:

   * 214. Reactive: Creating a Custom Async Validator.
   * 
   * A custom validator this.forbiddenEmails is created and added to the 'email' FormControl.
   * In this case .bind(this) was not necessary.
   */
  ngOnInit(): void {
    this.signupForm = new FormGroup({
      'userData': new FormGroup({
        'username': new FormControl(null, [Validators.required, this.forbiddenNames.bind(this)]),
        'email': new FormControl(null, [Validators.required, Validators.email], this.forbiddenEmails.bind(this)),
      }),
      'gender': new FormControl('male'),
      'hobbies': new FormArray([])
    });
  }


/**
   * 214. Reactive: Creating a Custom Async Validator.
   * 
   * Below the 1500 ms will simulate that the response will take some time.
   * Effect:
   * If a value is entered in html field 'email' the class will change briefly to ng-pending before switching to
   * either ng-valid or ng-invalid.
   * 
   * a Promise is always asynchronous, while an Observable can be either synchronous or asynchronous, 
   * a Promise can provide a single value, whereas an Observable is a stream of values.
   * 
   * https://angular.io/guide/comparing-observables
   * 
   * @param control : FormControl
   */
  forbiddenEmails(control: FormControl): Promise<any> | Observable<any> {
    const promise = new Promise<any>( (resolve, reject) => {
      setTimeout( () => {
        if (control.value === 'test@test.com') {
          resolve({'emailIsForbidden': true});
        } else {
          resolve(null);
        }
      }, 1500);
    });
    return promise;
  }

215. Reactive: Reacting to Status or Value Changes.

app.component.ts:

    /**
     * 215. Reactive: Reacting to Status or Value Changes.
     * Again: signupForm is of type FormGroup, which is an Observable.
     * The following code will cause the entire form to be printed in the console.
     */
    this.signupForm.valueChanges.subscribe(
      (value) => console.log(value)
    );
    /**
     * 215. Reactive: Reacting to Status or Value Changes.
     * The following code will log the status of the form in the console.
     * e.g. INVALID, PENDING, VALID (when the required fields have been filled correctly).
     */
    this.signupForm.statusChanges.subscribe(
      (status) => console.log(status)
    );


216. Reactive: Setting and Patching Values.


Assignment 7: Practicing Reactive Forms.

  Create a Form with the following Controls and Validators
  1) Project Name (should not be empty)
  2) Mail (should not be a empty and a valid email)
  3) Project Status Dropdown, with three values: 'Stable', 'Critical', 'Finished'
  4) Submit Button

  Add your own Validator which doesn't allow "Test" as a Project Name

  Also implement that Validator as an async Validator (replace the other one)

  Upon submitting the form, simply print the value to the console

  The video explains the example app you're starting with and which tasks should be completed as part of this assignment.

  Make sure to also answer why you implemented the solution you chose to use.

  Questions for this assignment
  Please complete the tasks outlined in the instructions video. Why did you choose the approach you took? Which problems did you encounter?


Resource:
- forms-reactive-assignment-start.zip
- forms-reactive-assignment-solution.zip


Use: forms-reactive-assignment.zip

Now you need to import ReactiveFormsModule in app.module.ts


$ ng new forms-reactive-assignment --routing --no-strict --defaults

Go to the root directory of the application:
$ ng serve

--> look at http://localhost:4200/


How to install:

$ cd /Users/rkremers/Development/workspaceJS/Angular/forms-reactive-start
$ npm install --save bootstrap@3

Now make Angular aware of this styling package.
- angular.json file.

            "styles": [
              "node_modules/bootstrap/dist/css/bootstrap.min.css", !! bootstrap.min.css has been added here.
              "src/styles.css"
            ],

Add ReactiveFormsModule to app.module.ts

$ npm install --save rxjs-compat

Go to the root directory of the application:
$ ng serve --port 4203


Create a new component:

In a second terminal:
$ ng generate component recipes --spec false
--> the option --spec false is outdated.

Instead:

$ ng generate component recipes --skip-tests

Create a new directive:

$ ng generate directive <name>

Create a new service:

$ ng generate service user --skip-tests


Resource:
- https://angular.io/api/forms/SelectControlValueAccessor

^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$

In case of   syncForbiddenNames(control: FormControl): Promise<any> {}

  In case of projectName == 'TestProject' the Custom Validator is visible under:
  - [[Prototype]]: AbstractControl
    - root: FormGroup
      - controls
        - projectName
          - errors
            nameIsForbidden: true

In case of asyncForbiddenName(control: FormControl): Promise<any> | Observable<any> {


===================================================================================================
2022-02-27:

Section 16: Course Project - Forms.

218. Introduction.


Create a new app shopping-app-router-forms


Now you need to import ReactiveFormsModule in app.module.ts


$ ng new shopping-app-router-forms --routing --no-strict --defaults

Go to the root directory of the application:
$ ng serve --port 4203

--> look at http://localhost:4200/


How to install:

$ cd /Users/rkremers/Development/workspaceJS/Angular/forms-reactive-start
$ npm install --save bootstrap@3

Now make Angular aware of this styling package.
- angular.json file.

            "styles": [
              "node_modules/bootstrap/dist/css/bootstrap.min.css", !! bootstrap.min.css has been added here.
              "src/styles.css"
            ],

Add ReactiveFormsModule to app.module.ts

$ npm install --save rxjs-compat


Create a new component:

In a second terminal:
$ ng generate component recipes --spec false
--> the option --spec false is outdated.

Instead:

$ ng generate component recipes --skip-tests

Create a new directive:

$ ng generate directive <name>

Create a new service:

$ ng generate service user --skip-tests


219. TD: Adding the Shopping List Form.

220. Adding Validation to the Form.

221. Allowing the Selection of Items in the List.

Resource:
- https://rxjs.dev/guide/subject
  An RxJS Subject is a special type of Observable that allows values to be multicasted to many Observers


222. Loading the Shopping List items into the Form.

223. Updating existing Items.

If we are in the editing mode (shopping-edit.component: editedItem === true) we should add a new item but update the existing one.

224. Resetting the Form.

225. Allowing the User to Clear (Cancel) the Form.

226. Allowing the Deletion of Shopping List Items.

======================================================
Now the Recipes page will be updated to Reactive Form.
======================================================

227. Creating the Template for the (Reactive) Recipe Edit Form.


recipe-edit.component.
- html
  - has been set up.


228. Creating the Form for Editing Recipes.

229. Syncing HTML with the Form.

- Add AppRoutingModule to app.module.ts.

230. Fixing a Bug.


  In the next lecture, we'll add some code to access the controls of our form array:

    *ngFor="let ingredientCtrl of recipeForm.get('ingredients').controls; let i = index"

  This code will fail with the latest Angular version.

  You can fix it easily though. Outsource the "get the controls" logic into a getter of your component code (the .ts file):

    get controls() { // a getter!
      return (<FormArray>this.recipeForm.get('ingredients')).controls;
    }

  In the template, you can then use:

    *ngFor="let ingredientCtrl of controls; let i = index"

  This adjustment is required due to the way TS works and Angular parses your templates (it doesn't understand TS there).


231. Adding Ingredient Controls to a Form Array.


232. Adding new Ingredient Controls.

233. Validating User Input.

234. Submitting the Recipe Edit Form.

- Todo:
  - Look at Angular rxjs Subject again.


235. Adding a Delete and Clear (Cancel) Functionality.

Todo:
- Manage Recipe | Delete Recipe.
- Edit / New Recipe:
  - Save / Cancel: Move away from recipe-edit component.

236. Redirecting the User (after Deleting a Recipe).

237. Adding an Image Preview.

Test jpeg for a new recipe.
https://images.pexels.com/photos/955137/pexels-photo-955137.jpeg

238. Providing the Recipe Service Correctly.

Until now we provided the recipeService in the recipes.component.ts
This means that if we navigate away from the recipes area the instance of RecipesComponent will be destroyed and so is the instance of the service.

So the provider RecipeService needs to be removed from recipes.component.ts: RecipesCompoent.

Add RecipeService to:

app.module.ts:
  providers: [ShoppingListService, RecipeService],

In this way the RecipeService will not be destroyed when going back to /recipes after moving to /shopping-list.


239. Deleting Ingredients and Some Finishing Touches.


240. Deleting all items in a FormArray.

  Deleting all Items in a FormArray
  As of Angular 8+, there's a new way of clearing all items in a FormArray.

  (<FormArray>this.recipeForm.get('ingredients')).clear();
  The clear() method automatically loops through all registered FormControls (or FormGroups) in the FormArray and removes them.

  It's like manually creating a loop and calling removeAt() for every item.


=================================================================================================
2022-03-02:

Section 17: Using Pips to Transform Output.


241. Introduction & Why Pipes are Useful.

Pipes are a feature that allows transform output in a template.

Example:
username = 'Max'

<p> {{ username }} </p> <!-- String Interpolation -->

Now you want to use Camel Case:

Max

For this you can use a Pipe:

<p>{{ username | uppercase }}</p>

MAX


242. Using Pipes.


Resources:
- pipes-start.zip
- https://angular.io/guide/pipes

Use: pipes-start.zip

$ ng new pipes-start --routing --no-strict --defaults

How to install:

$ cd /Users/rkremers/Development/workspaceJS/Angular/pipes-start
$ npm install --save bootstrap@3

Now make Angular aware of this styling package.
- angular.json file.

            "styles": [
              "node_modules/bootstrap/dist/css/bootstrap.min.css", !! bootstrap.min.css has been added here.
              "src/styles.css"
            ],

Template Driven: Add FormsModule to app.module.ts
Reactive Forms Driven: Add ReactiveFormsModule to app.module.ts
(sometimes it can be handy to use both).

$ npm install --save rxjs-compat

Go to the root directory of the application:
$ ng serve --port 4203


Create a new component:

In a second terminal:
$ ng generate component recipes --spec false
--> the option --spec false is outdated.

Instead:

$ ng generate component recipes --skip-tests

Create a new directive:

$ ng generate directive <name>

Create a new service:

$ ng generate service user --skip-tests


app.component.
- ts:

 // An array holding JS objects
  servers = [
    {
      instanceType: 'medium',
      name: 'Production Server',
      status: 'stable',
      started: new Date(15, 1, 2017)
    },

    ..
  }

- html:

  Use of Pipes: 'uppercase', 'date'.

  <div class="container">
    <div class="row">
      <div class="col-xs-12 col-sm-10 col-md-8 col-sm-offset-1 col-md-offset-2">
        <ul class="list-group">
          <li class="list-group-item" *ngFor="let server of servers" [ngClass]="getStatusClasses(server)">
            <span class="badge">
              {{ server.status }}
            </span>
            <strong>{{ server.name }}</strong> | 
            {{ server.instanceType | uppercase }} | 
            {{ server.started | date }}
          </li>
        </ul>
      </div>


243. Parametrizing Pipes.

app.component.html:

          <strong>{{ server.name }}</strong> | 
          {{ server.instanceType | uppercase }} | 
          <!-- {{ server.started | date: 'fullDate' }} | -->
          {{ server.started | date: 'yyyy-MM-dd, EEEE' }}
        </li>


Testing Environment Server | SMALL | 1920-08-09, Monday stable

  </div>
</div>


244. Where to learn more about Pipes.

Resources:
- https://angular.io/guide/pipes
- https://angular.io/api?query=pipe

--> Taking some time to go through this.


245. Chaining Multiple Pipes.

app.component.html:

    <div class="col-xs-12 col-sm-10 col-md-8 col-sm-offset-1 col-md-offset-2">
      <ul class="list-group">
        <li class="list-group-item" *ngFor="let server of servers" [ngClass]="getStatusClasses(server)">
          <span class="badge">
            {{ server.status }}
          </span>
          <!-- 
            245. Chaining Multiple Pipes.

            Various examples:
            Chaining: server.started | date | uppercase.

            Should be done in the right order: 
            - a date field, like server.started can not be changed by Pipe 'uppercase'.
              Instead server.started shoud first be changed into a string with the right format, 
              after which the string can be handled.

          -->
          <strong>{{ server.name }}</strong> | 
          {{ server.instanceType | uppercase }} | 
          {{ server.started | date: 'shortDate' }} |
          {{ server.started | date | uppercase }} |
          {{ server.started | date: 'yyyy-MM-dd, EEEE' }} |
          {{ server.started | date: 'fullDate' | uppercase}}
        </li>
      </ul>
    </div>


246. Creating a Custom Pipe.


./pips/shorten.pipe.ts:

import { Pipe, PipeTransform } from '@angular/core';
/**
 * Example from: https://angular.io/guide/pipes
 *  
 * Raise the value exponentially
 * Takes an exponent argument that defaults to 2.
 * Usage:
 *   value | exponentialStrength:exponent
 * Example:
 *   {{ 2 | exponentialStrength:10 }}
 *   formats to: 1024
 * 
 * This custom Pipe class has been declared in app.module.ts and is used in app.component.html.
*/
@Pipe({name: 'exponentialStrength'})
export class ExponentialStrengthPipe implements PipeTransform {
  transform(value: number, exponent = 2): number {
    return Math.pow(value, exponent);
  }
}

app.component.html:

          <strong>{{ server.name | shorten }}</strong> |

247. Parameterizing a Custom Pipe.


 * In app.component.html:
 * - use:
 *      - {{ server.name | shorten: 4 }}
 *      - {{ server.name | shorten }}       !! The second input parameter is optional!!
 * 
 */
@Pipe({name: 'shorten'})
export class ShortenPipe implements PipeTransform {
    
  transform(value: string, limit: number): string {
      if (value.length > limit) {
        return value.substring(0, limit) + ' ...';
      }
      return value;
  }
}

248. Example: Creating a Filter Pipe.

Create a new filter on the command-line:
$ ng generate pipe pipes/filter

A new filter is generated:

./pipes/filter.pipe.ts:

import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'filter'
})
export class FilterPipe implements PipeTransform {

  transform(value: unknown, ...args: unknown[]): unknown {
    return null;
  }

}

And has been declared in app.module.ts:

import { FilterPipe } from './pipes/filter.pipe';

@NgModule({
  declarations: [
    AppComponent,
    ExponentialStrengthPipe,
    ShortenPipe,
    FilterPipe
  ],


import { Pipe, PipeTransform } from '@angular/core';

/**
 * 248. Example: Creating a Filter Pipe.
 * Input parameters:
 * - value: servers[] as defined in app.component.ts.
 * - filterString: the name of the servers (server.name) to be filtered.
 * - propertyName: the name of a property of a server.
 * 
 * Use: see app.component.html:
 * <li class="list-group-item" *ngFor="let server of servers | filter: filteredStatus: 'status'" [ngClass]="getStatusClasses(server)">
 * - In this case:
 *  - value: servers[]
 *  - filterString: e.g. stable
 *  - propertyName: 'status' --> server.status.
 */
@Pipe({
  name: 'filter'
})
export class FilterPipe implements PipeTransform {

  transform(value: any, filterString: string, propertyName: string): unknown {
    if (value.length === 0 || filterString === '') {
      return value;
    }
    const resultArray = [];
    for (const item of value) {
      if (item[propertyName] === filterString) {
        resultArray.push(item);
      }
    }
    return resultArray;
  }

}

249. Pure and Impure Pipes (or: How to "fix" the Filter Pipe)

By default it is not possible to dynamically reload the content of an array.
Reason: this would potentially be very damaging to the performance.

This default behaviour can be changed though.
That means: with every change in the page the array would be reloaded.

How to do this:
Add a decorator to the pipe definition: 
- pure: false

Now the pipe will be recalculated each time the data is changed.


250. Understanding the "async" Pipe.

Resources:
- https://angular.io/guide/comparing-observables
  - describes differences between Observables and Promises.

app.component:
- ts:

export class AppComponent {
  title = 'pipes-start';
  appStatus = new Promise(
    (resolve, reject) => {
      setTimeout( () => {
        resolve('stable');
      }, 2000);
    }
  );

- html:

      <br><br>
      <p>App Status: {{ appStatus | async }}</p>
      <hr>

Without the 'async' it will immediately show: App Status: [object Promise]
- It shows an object of type Promise. This is in itself correct: a Promise is an object.
- We know that after 2 seconds this is no longer an object. It is just a string. But Angular does not know.
  This is because Angular does not watch the Promise and therefore does not see whether it transforms into something.
  Angular shows a Promise and that's it.


After reloading:
- Initially       : App Status:
- After 2 seconds : App Status: stable

This is what 'async' does:
- It recognizes that appStatus is a Promise. After 2 seconds it will recognize that something changed and that data was sent through this Promise.


Assignment 8: Practicing Pipes.

Resource:
- pipes-assignment-start.zip

$ ng new pipes-assignment-start --routing --no-strict --defaults

Go to the root directory of the application:
$ ng serve

--> look at http://localhost:4200/


How to install:

$ cd /Users/rkremers/Development/workspaceJS/Angular/pipes-assignment-start
$ npm install --save bootstrap@3

Now make Angular aware of this styling package.
- angular.json file.

            "styles": [
              "node_modules/bootstrap/dist/css/bootstrap.min.css", !! bootstrap.min.css has been added here.
              "src/styles.css"
            ],

Add FormsModule and / or ReactiveFormsModule to app.module.ts

$ npm install --save rxjs-compat

Go to the root directory of the application:
$ ng serve --port 4203


Create a new component:

In a second terminal:
$ ng generate component recipes --spec false
--> the option --spec false is outdated.

Instead:

$ ng generate component recipes --skip-tests

Create a new directive:

$ ng generate directive <name>

Create a new service:

$ ng generate service user --skip-tests

Create a new Pipe with name filter in subdirectory ./pipes:

$ ng generate pipe pipes/filter --skip-tests


Tasks:
1. Build a reverse Pipe.
  - Will reverse an incoming string.
    - In JavaScript a reverse keyword exists. Works on arrays.
2. Build a SortList Pipe.
  - Sorts the list of servers.
    - e.g. sorting on server.name.


$ ng generate pipe pipes/reverseString --skip-tests

app.module.ts:

import { ReverseStringPipe } from './pipes/reverse-string.pipe';

@NgModule({
  declarations: [
    AppComponent,
    ExponentialStrengthPipe,
    ShortenPipe,
    FilterPipe,
    ReverseStringPipe
  ],


./pipes/reverse-string.pipe.ts:

import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'reverseString'
})
export class ReverseStringPipe implements PipeTransform {

  // transform(value: unknown, ...args: unknown[]): unknown {
  transform(value: string): string {
    return value.split("").reverse().join("");
  }
}

$ ng generate pipe pipes/sortList --skip-tests

/**
 * Purpose:
 * Sort a List, consisting of elements of type Server.
 * 
 * Example of use: *ngFor="let server of servers | filter: filteredStatus: 'status' | sortList"
 */
@Pipe({
  name: 'sortList',
  pure: false
})
export class SortListPipe implements PipeTransform {

  /**
   * 
   * @param value: any      : the server list to be sorted.
   * @param propertyName    : the name of the Server item used for sorting.
   * @returns               : the server list sorted based on server.name
   */
  transform(value: any, propertyName: string): unknown {
    if (value.length === 0) {
      console.log('SortListPipe: The value lenghth = 0')
      return value;
    }

    // This works.
    // value.sort(this.compareName);

    // Works too.
    value.sort( (a, b) => {
      if (a[propertyName] > b[propertyName]) {
        return 1;
      } else if (a[propertyName] < b[propertyName]) {
        return -1;
      } else {
        return 0;
      }
    });

    return value;
  }


 compareName(a: any,b: any) {
    if (a.name < b.name )
      return -1;
    if (a.name  > b.name )
     return 1;
    return 0;
 }

}

app.component.html:

        <li class="list-group-item" *ngFor="let server of servers | filter: filteredStatus: 'status' | sortList: 'name'" [ngClass]="getStatusClasses(server)">


===================================================================================================
2022-03-05:

Section 18: Making Http Requests.

251. A New IDE.

252. Module Introduction.

Resources:
- http-01-start.zip

$ ng new shopping-app --no-strict
  ? Would you like to add Angular routing?  N
  Choose CSS styling

$ ng new routing-app --routing --no-strict

Alternatively, explicitly adding routing:
$ ng new routing-app --routing --defaults

Go to the root directory of the application:
$ ng serve

--> look at http://localhost:4200/

I have created: my-second-app

How to install:

$ cd /Users/rkremers/Development/workspaceJS/Angular/shopping-app
$ npm install --save bootstrap@3

This will download bootstrap locally. Not globally.

added 1 package, removed 1 package, and audited 1015 packages in 2s

90 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities

Will install in the node_modules folder.

Now make Angular aware of this styling package.
- angular.json file.

            "styles": [
              "node_modules/bootstrap/dist/css/bootstrap.min.css", !! bootstrap.min.css has been added here.
              "src/styles.css"
            ],

Template Driven: Add FormsModule to app.module.ts
Reactive Forms Driven: Add ReactiveFormsModule to app.module.ts
(sometimes it can be handy to use both).

$ npm install --save rxjs-compat

Go to the root directory of the application:
$ ng serve


Create a new component:

In a second terminal:
$ ng generate component recipes --spec false
--> the option --spec false is outdated.

Instead:

$ ng generate component recipes --skip-tests

Create a new directive:

$ ng generate directive <name>

Create a new service:

$ ng generate service user --skip-tests

Create a new Pipe with name filter in subdirectory ./pipes:

$ ng generate pipe pipes/filter --skip-tests



Http & Backend Interaction.


253. How Does Angular interacti with Backends?

How do I connect Angular to a Database?
- Not directly.
- Http Request, Http Response <==> Server; API (REST, GraphQL) <==> database.
- Data transfer usually in the form of json files.

Todo:
- Check again why ngModel is being used.
  - https://angular.io/api/forms/NgModel


254. Anatomy of a Http Request.

url                 -> /post/1

HTTP verb           -> POST, GET, PUT,....

Headers (Metadata)  -> {"Content-Type": "application/json; charset=utf-8"}

Body                -> {"title": "New Post"}


255. Backend (Firebase) Setup.

Resources:
- https://en.wikipedia.org/wiki/Firebase

https://firebase.google.com
- Needs a Google account (which I have)
- Click 'Get Started'
- Click Create Project
  - Project name: ng-complete-guide

- Create a Database
  - Click at the left: Firestore Database
  - Click: Create database
  - Realtime Database
    - Click: Create Database
    - Realtime Database location: Belgium
    - Start in test mode
      Your data is open by default to enable quick setup. 
      However, you must update your security rules within 30 days to enable long-term client read/write access.

- url: https://ng-complete-guide-f5ed5-default-rtdb.europe-west1.firebasedatabase.app/
- ng-complete-guide-f5ed5-default-rtdb: null
  - The database is now not protected.

General url for the Firebase page:
- https://console.firebase.google.com/project/ng-complete-guide-f5ed5/database/ng-complete-guide-f5ed5-default-rtdb/data


256. Sending a POST Request.

Resources:
- https://angular.io/guide/http

app.module.ts:
import { HttpClientModule } from '@angular/common/http';

app.component.ts:

  @NgModule({
    declarations: [
      AppComponent
    ],
    imports: [
      BrowserModule,
      AppRoutingModule,
      FormsModule,
      HttpClientModule
    ],

  HttpClientModule offers the functionality for the connectivity with a backend (database).

  import { Component, OnInit } from '@angular/core';
  import { HttpClient } from '@angular/common/http';

  @Component({
    selector: 'app-root',
    templateUrl: './app.component.html',
    styleUrls: ['./app.component.css']
  })
  export class AppComponent implements OnInit {
    loadedPosts = [];

    private firebaseUrl: string = 'https://ng-complete-guide-f5ed5-default-rtdb.europe-west1.firebasedatabase.app/';
    private firebasePostEndpoint: string = 'posts.json';

    constructor(private http: HttpClient) { }

    ngOnInit() { }

    /**
     * Firebase test application:
     * - https://console.firebase.google.com/project/ng-complete-guide-f5ed5/database/ng-complete-guide-f5ed5-default-rtdb/data
     * 
     * Technical details:
     * - url to the Firebase database:
     *  - https://ng-complete-guide-f5ed5-default-rtdb.europe-west1.firebasedatabase.app/
     *  - Firebase requires that the url ends with 'postsjson'.
     * 
     * @param postData: { title: string; content: string }
     *  The postData ( string, content) is typed in input field 'title' and textarea 'content'. 
     */
    onCreatePost(postData: { title: string; content: string }) {
      // Send Http request
      console.log(postData);

      /**
       * HttpClient.post(url: string, body: any, options: {
       * headers?: HttpHeaders | {
       *     [header: string]: string | string[];
       * };
       * It is necessary to set up an Observable and subscribe to it.
       * Otherwise Angular will not send the POST request.
       * this.http.post will return an Observable.
       * 
       * In Developer Tool | Network 2 files posts.json will be visible:
       * - The first will contain:
       * Request URL: https://ng-complete-guide-f5ed5-default-rtdb.europe-west1.firebasedatabase.app/posts.json
  Request Method: OPTIONS
  Status Code: 200 OK
  Remote Address: 34.107.226.223:443
  Referrer Policy: strict-origin-when-cross-origin

  this checks whether it is allowd to send a POST request.

  - The second will contain:
  Request URL: https://ng-complete-guide-f5ed5-default-rtdb.europe-west1.firebasedatabase.app/posts.json
  Request Method: POST
  Status Code: 200 OK
  Remote Address: 34.107.226.223:443
  Referrer Policy: strict-origin-when-cross-origin

  This is the actual POST request.

  In Developer Tool | Console will be visible:

  {name: '-MxW-V-sgIweOWMqidlA'}
  name: "-MxW-V-sgIweOWMqidlA"
  [[Prototype]]: Object

       */
      this.http.post(
        this.firebaseUrl + this.firebasePostEndpoint,
        postData).subscribe(responseData => {
          console.log(responseData);
        });
    }

    onFetchPosts() {
      // Send Http request
    }

    onClearPosts() {
      // Send Http request
    }
  }


257. GETting Data.

app.component.ts:

  ngOnInit() {
    /**
     * Since this is a subscription all POST content will be visible in Developer Tool | Console.
     */
    this.fetchPosts();
   }


  /**
   * HttpClient.get(url: string, options: {
    headers?: HttpHeaders | {
        [header: string]: string | string[];
    };

    @param url — The endpoint URL.
    @param options — The HTTP options to send with the request.
    @return — An Observable of the response, with the response body as an ArrayBuffer.
   */
  private fetchPosts() {
    this.http.get(this.firebaseUrl + this.firebasePostEndpoint)
      .subscribe(posts => {
        console.log(posts);
      });
  }


258. Using RxJS Operators to Transform Response Dta.

import { map } from 'rxjs/operators';
(alias) function map<T, R>(project: (value: T, index: number) => R): OperatorFunction<T, R> (+1 overload)
import map

https://www.w3schools.com/react/react_es6_spread.asp

Spread Operator

The JavaScript spread operator (...) allows us to quickly copy all or part of an existing array or object into another array or object.
Example

const numbersOne = [1, 2, 3];
const numbersTwo = [4, 5, 6];
const numbersCombined = [...numbersOne, ...numbersTwo];


  /**
   * HttpClient.get(url: string, options: {
    headers?: HttpHeaders | {
        [header: string]: string | string[];
    };

    '...' is the spread operator.
    The JavaScript spread operator (...) allows us to quickly copy all or
    part of an existing array or object into another array or object.

    @param url — The endpoint URL.
    @param options — The HTTP options to send with the request.
    @return — An Observable of the response, with the response body as an ArrayBuffer.
   */
  private fetchPosts() {
    this.http.get(this.firebaseUrl + this.firebasePostEndpoint)
      .pipe(map(responseData => {
        const postsArray = [];
        for (const key in responseData) {
          if (responseData.hasOwnProperty(key)) {
            postsArray.push({ ...responseData[key], id: key })
          }
        }
        return postsArray;
      })
      )
      .subscribe(posts => {
        console.log(posts);
      });
  }


259. Using Types with the HttpClient.

post.model.ts:

export interface Post { 
    title: string; 
    content: string;
    id?: string 
}

Note: the '?' means that the parameter is optional.

One way to give responseData a type:

  private fetchPosts() {
    this.http.get(this.firebaseUrl + this.firebasePostEndpoint)
      .pipe(
        map( (responseData: { [key: string]: Post}) => {
        const postsArray: Post[] = [];
        for (const key in responseData) {
          if (responseData.hasOwnProperty(key)) {
            postsArray.push({ ...responseData[key], id: key })
          }
        }
        return postsArray;
      })
      )
      .subscribe(posts => {
        console.log(posts);
      });
  }

Another way (recommended): define the response: this.http.get<{ [key: string]: Post}>(this.firebaseUrl + this.firebasePostEndpoint)

  private fetchPosts() {
    this.http.get<{ [key: string]: Post}>(this.firebaseUrl + this.firebasePostEndpoint)
      .pipe(map(responseData => {
        const postsArray = [];
        for (const key in responseData) {
          if (responseData.hasOwnProperty(key)) {
            postsArray.push({ ...responseData[key], id: key })
          }
        }
        return postsArray;
      })
      )
      .subscribe(posts => {
        console.log(posts);
      });
  }

The brackets are also available on this.http.post<> for determining the type of the post or get.


260. Outputting Posts.

app.component.html:

  <div class="row">
    <div class="col-xs-12 col-md-6 col-md-offset-3">
      <p *ngIf="loadedPosts.length < 1">No posts available!</p>
      <ul class="list-group" *ngIf="loadedPosts.length >= 1">
        <li class="list-group-item" *ngFor="let post of loadedPosts">
          <h3>{{ post.title }}</h3>
          <p>{{ post.content }}</p>
        </li>
      </ul>
    </div>
  </div>


261. Showing a Loading Indicator.

app.component
- ts

  isFetching: boolean = false;

    The indicator this.isFetching will indicate during fetching that this process is going on.

  private fetchPosts() {
    this.isFetching = true;
    this.http.get<{ [key: string]: Post}>(this.firebaseUrl + this.firebasePostEndpoint)
      .pipe(map(responseData => {
        const postsArray = [];
        for (const key in responseData) {
          if (responseData.hasOwnProperty(key)) {
            postsArray.push({ ...responseData[key], id: key })
          }
        }
        return postsArray;
      })
      )
      // The returned postsArray will be the input parameter for subscrib() and will be available via parameter 'post'.
      .subscribe(posts => {
        this.isFetching = false;
        console.log(posts);
        this.loadedPosts = posts;
      });
  }
}

- html:

  <div class="row">
    <div class="col-xs-12 col-md-6 col-md-offset-3">
      <p *ngIf="loadedPosts.length < 1 && !isFetching">No posts available!</p>
      <ul class="list-group" *ngIf="loadedPosts.length >= 1 && !isFetching">
        <li class="list-group-item" *ngFor="let post of loadedPosts">
          <h3>{{ post.title }}</h3>
          <p>{{ post.content }}</p>
        </li>
      </ul>
      <p *ngIf="isFetching">Loading...</p>
    </div>
  </div>


262. Using a Service for Http Requests.


Creating service PostService:
$ ng generate service post --skip-tests

post.service.ts
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class PostService {

  constructor() { }
}

Note:
- Because of the declaration "providedIn: 'root' " it is not necessary to declare the service in app.module.ts.
- Instead it could be declared in app.module.ts in: providers: [],


263. Services & Components Working Together.

The Observable functionality has been moved to the service.

post.service.ts:

/**
 * Purpose:
 * Holds the functionality for the HTTP requests.
 * 
 * Best practice:
 * Move the Observable in the service and create the subscription in the component.
 * Unless there is no need to place the subscription in the component.
 */
@Injectable({
  providedIn: 'root'
})
export class PostService {
  private firebaseUrl: string = 'https://ng-complete-guide-f5ed5-default-rtdb.europe-west1.firebasedatabase.app/';
  private firebasePostEndpoint: string = 'posts.json';

  constructor(private http: HttpClient) { }

  createAndStorePost(title: string, content: string) {
    const postData: Post = {title, content};
    this.http.post<{name: string}>(
      this.firebaseUrl + this.firebasePostEndpoint,
      postData).subscribe(responseData => {
        console.log(responseData);
      });
  }

    /**
   * HttpClient.get(url: string, options: {
    headers?: HttpHeaders | {
        [header: string]: string | string[];
    };

    '...' is the spread operator.
    The JavaScript spread operator (...) allows us to quickly copy all or
    part of an existing array or object into another array or object.

    261. Showing a Loading Indicator.
    The indicator this.isFetching will indicate during fetching that this process is going on.

    @param url — The endpoint URL.
    @param options — The HTTP options to send with the request.
    @return — An Observable of the response, with the response body as an ArrayBuffer.
   */
  fetchPosts() {
    return this.http.get<{ [key: string]: Post}>(this.firebaseUrl + this.firebasePostEndpoint)
      .pipe(map(responseData => {
        const postsArray = [];
        for (const key in responseData) {
          if (responseData.hasOwnProperty(key)) {
            postsArray.push({ ...responseData[key], id: key })
          }
        }
        return postsArray;
      })
      );
  }

app.component.ts:

  ngOnInit() {
    /**
     * Since this is a subscription all POST content will be visible in Developer Tool | Console.
     */
    this.isFetching = true;
     this.postService.fetchPosts().subscribe(posts => {
       this.isFetching = false;
       this.loadedPosts = posts;
     });
  }

  onCreatePost(postData: { title: string; content: string }) {
    // Send Http request
    console.log(postData);
    this.postService.createAndStorePost(postData.title, postData.content);
  }


  onFetchPosts() {
    // Send Http GET request
    // The received content will be saved in this.loadedPosts.
    this.isFetching = true;
    this.postService.fetchPosts().subscribe(posts => {
      this.isFetching = false;
      this.loadedPosts = posts;
    });
  }


264. Sending a DELETE Request.


post.service.ts:

  deleteAllPosts() {
    return this.http.delete(this.firebaseUrl + this.firebasePostEndpoint);
  }

app.component:
- ts:

  onClearPosts() {
    // Send Http request
    this.postService.deleteAllPosts().subscribe(() => {
      this.loadedPosts = [];
    });
  }

- html:

(was already present)
      <button
        class="btn btn-danger"
        [disabled]="loadedPosts.length < 1"
        (click)="onClearPosts()"
      >
        Clear Posts
      </button>


265. Handling Errors:

Simulate a Database error:

Go to Firebase:
- https://console.firebase.google.com/project/ng-complete-guide-f5ed5/database/ng-complete-guide-f5ed5-default-rtdb/data
  - Realtime Database
    - Rules

{
  "rules": {
    ".read": "now < 1649109600000",  // 2022-4-5
    ".write": "now < 1649109600000",  // 2022-4-5
  }
}

Change to: ".read": "false"

Fetch Posts:
- Developer Tools | console:
  - HttpErrorResponse {headers: HttpHeaders, status: 401, statusText: 'Unauthorized', url: 'https://ng-complete-guide-f5ed5-default-rtdb.europe-west1.firebasedatabase.app/posts.json', ok: false, …}


  ngOnInit() {
    /**
     * Since this is a subscription all POST content will be visible in Developer Tool | Console.
     */
    this.isFetching = true;
    this.postService.fetchPosts().subscribe(posts => {
      this.isFetching = false;
      this.loadedPosts = posts;
    }, error => {
      /**
       * Here Firebase returns a complete Error Object, visible in the Console with multiple items, like the status.
       * In this object a separate error key may or may not exist. If existing it may contain a more useful 
       * message.
       */
      this.error = error.message;
      console.log(error);
      console.log(error.status);
    });

    /**
     * https://angular.io/guide/observables
     * - This is an example how to implement an Observable in the style recommended by RjJS.
     * Note that the style shown above is deprecated.
     * A difference is that in the new style (but the entire Observable should be rewritten)
     * the error only pops up when the button is pushed instead of immediately in case Firebase can not be read.
     * Notes:
     * - Most online examples are still using the code as given in the course.
     * - Important is to still use an arrow function, so that this points to the component, and not to the observer object.
     */

    this.postService.fetchPosts().subscribe({
      next: (posts) => {
        this.isFetching = false;
        this.loadedPosts = posts;
        console.log('ngOnInit(): this.loadedPosts.length = ' + this.loadedPosts.length + ',  this.isFetching = ' + this.isFetching);
        console.log(this.loadedPosts);
        console.log(this.loadedPosts[0].title + '; ' + this.loadedPosts[0].content );
      },
      error: (error) => {
        this.isFetching = false;
        this.error = error.message;
        console.log(this.error);
      },
      complete() {
        this.isFetching = false;
         console.log('ngOnInit(): this.postService.fetchPosts().subscribe(): Completed');
      }
    });
  }


266. Using Subjcts for Error Handling.

Other method for handling errors: using a Subject.

Todo:
- Study Subject again.
  - https://rxjs.dev/guide/subject

post.service.ts:

  error = new Subject<string>();


  createAndStorePost(title: string, content: string) {
    const postData: Post = { title, content };
    this.http.post<{ name: string }>(this.firebaseUrl + this.firebasePostEndpoint, postData)
      .subscribe(responseData => {
        console.log(responseData);
      }, error => {
        this.error.next(error.message);
      });
  }

app.component.ts:

  private errorSub: Subscription;

  ngOnInit() {
    this.errorSub = this.postService.error.subscribe( errorMessage => {
      this.error = errorMessage;
    });
    ...
  }

  ngOnDestroy(): void {
    this.errorSub.unsubscribe();
  }

267. Using the catchError Operator.

post.service.ts:

import { map, Subject, catchError, throwError } from 'rxjs';


  fetchPosts() {
    return this.http.get<{ [key: string]: Post }>(this.firebaseUrl + this.firebasePostEndpoint)
      .pipe(map(responseData => {
        const postsArray = [];
        for (const key in responseData) {
          if (responseData.hasOwnProperty(key)) {
            postsArray.push({ ...responseData[key], id: key })
          }
        }
        return postsArray;
      }),
      catchError(errorRes => {
        // Send to an analytics server for generic error handling.
        return throwError(errorRes);
      })
      );
  }

catchError: returns an Observable of some kind to which can be subscribed for further handling.


268. Errorhandling & UX.


Now put the Firebase db back to readable:

{
  "rules": {
    ".read": "true",  // 2022-4-5
    ".write": "now < 1649109600000",  // 2022-4-5
  }
}


app.component:
- html:

      <div class="alert alert-danger" *ngIf="error">
        <h1>An Error Occured!</h1>
        <p>{{ error }}</p>
        <!-- Button to get rid of an error message -->
        <button class="btn btn-danger" (click)="onHandleError()">Okay</button>
      </div>

A button has been added to clear the error message.

-ts:

  onHandleError() {
    this.error = null;
  }

And in every errorhandling:
      this.isFetching = false;
This will prevent the error message from popping up again.


269. Setting Headers.

Every HttpClient request (CRUD) has an additional input parameter in which header parameters can be declared.

  After the implementation of 'headers: new HttpHeaders() below in 
  Developer Tool | Network, in the posts.json, looking in the Headers we can see: 'Custom-Header': 'Hello'

post.service.ts:

  fetchPosts() {
    return this.http.get<{ [key: string]: Post }>(this.firebaseUrl + this.firebasePostEndpoint
      ,
      {
        headers: new HttpHeaders({
          'Custom-Header': 'Hello'
        })
      }
    )
    ...

270. Adding Query Params.

270. Adding Query Params.

      return this.http.get<{ [key: string]: Post }>(this.firebaseUrl + this.firebasePostEndpoint
      ,
      {
        headers: new HttpHeaders({
          'Custom-Header': 'Hello'
        }),
        params: new HttpParams().set('print', 'pretty')
      }

  Developer Tool | Network
  --> posts.json?print=pretty
    --> Request URL: https://ng-complete-guide-f5ed5-default-rtdb.europe-west1.firebasedatabase.app/posts.json?print=pretty

  In case of multiple query parameters use the construction below.

      return this.http.get<{ [key: string]: Post }>(this.firebaseUrl + this.firebasePostEndpoint
      ,
      {
        headers: new HttpHeaders({
          'Custom-Header': 'Hello'
        }),
        params: searchParams
      }
    )

  Result:
  --> posts.json?print=pretty&custom=key
      --> Request URL: https://ng-complete-guide-f5ed5-default-rtdb.europe-west1.firebasedatabase.app/posts.json?print=pretty&custom=key
  Note:
  - custom=key will have no effect. It is not recognized by the Firebase db.
  - print=pretty is recognized and it will cause the response in Developer Tool | Network; posts.json | response to be 
  shown in a more readable fashion.


271. Observing Different Types of Responses.

Resources:
- https://angular.io/api/common/http/HttpEventType
- https://angular.io/api/common/http/HttpClient
- https://stackoverflow.com/questions/61295224/what-is-the-difference-between-tap-and-map-in-rxjs

e.g. obtaining response headers, etc.
For that situation you want the full response.
(So in order to trigger this you have to POST content).

Standard:

  createAndStorePost(title: string, content: string) {
    const postData: Post = { title, content };
    // this.http.post<{ name: string }>(this.firebaseUrl + this.firebasePostEndpoint, postData)
    //   .subscribe(
    //     responseData => {
    //     console.log(responseData);
    //   }, error => {
    //     this.error.next(error.message);
    //   });

    this.http.post<{ name: string }>(
      this.firebaseUrl + this.firebasePostEndpoint,
      postData,
      {
        // 'body': this is the default and means that the body-content will be cnverted to a JavaScript object automatically and processed via subscribe().
        // This is the only option that is shown but other options are possible.
        observe: 'body'
      }
    )
      .subscribe({
        next: (posts) => {
          console.log(posts);
        },
        error: (error) => {
          this.error.next(error.message);
        }
      });
  }

Alternative: using observe: 'response'

    this.http.post<{ name: string }>(
      this.firebaseUrl + this.firebasePostEndpoint,
      postData,
      {
        observe: 'response'
      }
    )
      .subscribe({
        next: (posts) => {
          console.log(posts);
        },
        error: (error) => {
          this.error.next(error.message);
        }
      });

When looking in Developer Tool | Console:
- Now is a full HttpResponse visible. That means access to:
  - 

{
    "headers": {
        "normalizedNames": {},
        "lazyUpdate": null
    },
    "status": 200,
    "statusText": "OK",
    "url": "https://ng-complete-guide-f5ed5-default-rtdb.europe-west1.firebasedatabase.app/posts.json",
    "ok": true,
    "type": 4,
    "body": {
        "name": "-MygLgiutf0LZjfSAhKd"
    }
}


If you only want to have the body:

    this.http.post<{ name: string }>(
      this.firebaseUrl + this.firebasePostEndpoint,
      postData,
      {
        observe: 'response'
      }
    )
      .subscribe({
        next: (posts) => {
          console.log(posts.body); !!!! Now only the body will be processed.
        },
        error: (error) => {
          this.error.next(error.message);
        }
      });

import { map, Subject, catchError, throwError, tap } from 'rxjs';

tap: 
- Allows the execution of code without altering the response.

  /**
   * 264. Sending a DELETE Request.
   * 271. Observing Different Types of Responses.
   * @returns 
   */
  deleteAllPosts() {
    return this.http.delete(
      this.firebaseUrl + this.firebasePostEndpoint,
      {
        // Options:
        // observe: 'body'
        // observe: 'response'
        observe: 'events'
      }
    ).pipe(
      tap( event => {
        console.log(event);
      })
    );
  }
}

When looking into Developer Tool | Console we see two output's now:

{
    "type": 0
}

Note:
- Different types of event are possible. They are encoded with numbers.
- In the code (deleteAllPosts() ) we do not need to use the numbers. We can use HttpEventType. This is an Angular supported Enum.
  Enums are only supported in TypeScript, not in JavaScript.



{
    "headers": {
        "normalizedNames": {},
        "lazyUpdate": null
    },
    "status": 200,
    "statusText": "OK",
    "url": "https://ng-complete-guide-f5ed5-default-rtdb.europe-west1.firebasedatabase.app/posts.json",
    "ok": true,
    "type": 4,
    "body": null
}

https://stackoverflow.com/questions/61295224/what-is-the-difference-between-tap-and-map-in-rxjs

In RxJS, when a data is sent to the stream it goes through a series of operators:

- The map operator will simply apply a function to that data and return the result.
- The tap operator however takes a data, apply a function to that data but returns the original data, if the function bothered to return a result, tap just ignores it.


272. Changing the Response Body Type.

As a responseType several options are available: 'json', 'blob', 'text', 'arraybuffer.
- See e.g. https://angular.io/api/common/http/HttpRequest

   * 272. Changing the Response Body Type.
   * 
   * As a responseType several options are available: 'json', 'blob', 'text', 'arraybuffer.
   * - See e.g. https://angular.io/api/common/http/HttpRequest
   * 
   * In case of responseType: 'text' the response will still be null since there is no body content.
   * However in the HttpResponse, etc. is now visible:
   * body: "null" ==> it's treated as a text.
   * 
   * @returns 
   */
  deleteAllPosts() {
    return this.http.delete(
      this.firebaseUrl + this.firebasePostEndpoint,
      {
        // Options:
        // observe: 'body'
        // observe: 'response'
        observe: 'events',
        responseType: 'text'
      }
    ).pipe(
      tap( event => {
        console.log(event);
        if (event.type === HttpEventType.Response) {
          console.log(event.body); // Note that in case of a delete no body is present.
        }
        if (event.type === HttpEventType.Sent) {
          // logging event.body is not possible.
        }
      })
    );
  }


  In this.http.get<{ [key: string]: Post }>() it is stated that the response will be of type json.
  For this reason responseType: 'text' will not match and this will cause an error.
  However there may be situations in  which it is necessary to adapt the response type.

  fetchPosts() {
    let searchParams = new HttpParams();
    searchParams = searchParams.append('print', 'pretty');
    searchParams = searchParams.append('custom', 'key');
    return this.http.get<{ [key: string]: Post }>(this.firebaseUrl + this.firebasePostEndpoint
      ,
      {
        headers: new HttpHeaders({
          'Custom-Header': 'Hello'
        }),
        params: searchParams,
        responseType: 'json'
      }
    )

273. Introducing Interceptors.

Resources:
- https://angular.io/api/common/http/HttpInterceptor

Situation:
- Suppose it is necessary to add specific headers to each outgoing request.

Example:

        headers: new HttpHeaders({
          'Custom-Header': 'Hello'
        }),

In that case you do not want every outgoing request to be set up manually.

auth-interceptor.service.ts:

import { HttpEvent, HttpHandler, HttpInterceptor, HttpRequest } from "@angular/common/http";
import { Injectable } from "@angular/core";
import { Observable } from "rxjs";

export class AuthInterceptorService implements HttpInterceptor {

    intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
        console.log('Request is on its way');
        return next.handle(req);
    }
}

app.module.ts:

import { HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';
import { AuthInterceptorService } from './auth-interceptor.service';

@NgModule(
..
  providers: [
    { provide: HTTP_INTERCEPTORS, 
      useClass: AuthInterceptorService, 
      multi: true 
    }
  ],
..


274. Manipulating Request Objects.


export class AuthInterceptorService implements HttpInterceptor {

    intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
        console.log('Request is on its way');
        // req.url = 'a new url'; // will not work: req.url is immutable.
        // It is possible to clone the request properties.
        // Example: keep the existing headers and append additional ones:
        console.log(req.url);
        const modifiedRequest = req.clone({headers: req.headers.append('Auth', 'xyz')});

        return next.handle(modifiedRequest);
    }
}

Now header Auth: xyz will be added to each outgoing and incoming request:

Accept: application/json, text/plain, */*
Accept-Encoding: gzip, deflate, br
Accept-Language: en-US,en;q=0.9,nl;q=0.8,de;q=0.7

Auth: xyz !!!!

Cache-Control: no-cache
Connection: keep-alive
Content-Length: 45
Content-Type: application/json
Host: ng-complete-guide-f5ed5-default-rtdb.europe-west1.firebasedatabase.app
Origin: http://localhost:4203
Pragma: no-cache
Referer: http://localhost:4203/
sec-ch-ua: " Not A;Brand";v="99", "Chromium";v="99", "Google Chrome";v="99"
sec-ch-ua-mobile: ?0
sec-ch-ua-platform: "macOS"
Sec-Fetch-Dest: empty
Sec-Fetch-Mode: cors
Sec-Fetch-Site: cross-site
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/99.0.4844.74 Safari/537.36

Note:
Instead of headers e.g. response types, etc. can be adapted using the interceptors.


275. Response Interceptors.

Interceptors can be used for requests AND for responses.

Again:
https://stackoverflow.com/questions/61295224/what-is-the-difference-between-tap-and-map-in-rxjs

In RxJS, when a data is sent to the stream it goes through a series of operators:

- The map operator will simply apply a function to that data and return the result.
- The tap operator however takes a data, apply a function to that data but returns the original data, if the function bothered to return a result, tap just ignores it.

In the case of using tap() in an Interceptor there will always be an event (compare this with post.service.ts: deleteAllPosts).

Also the use of map() is possible in order to transform the data.


export class AuthInterceptorService implements HttpInterceptor {

    intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
        console.log('Request is on its way');
        // req.url = 'a new url'; // will not work: req.url is immutable.
        // It is possible to clone the request properties.
        // Example: keep the existing headers and append additional ones:
        console.log(req.url);
        const modifiedRequest = req.clone({headers: req.headers.append('Auth', 'xyz')});

        return next.handle(modifiedRequest).pipe(tap( event => {
            console.log(event);
            if (event.type === HttpEventType.Response) {
                console.log('Response arrived, body data: ');
                console.log(event.body);
            }
        }));
    }
}

When now e.g. executing 'Fetch Posts' in Develop Tool | Console will be visible:

Request is on its way

https://ng-complete-guide-f5ed5-default-rtdb.europe-west1.firebasedatabase.app/posts.json

The following is the event of fetching the content.
{
    "type": 0
}

{
    "headers": {
        "normalizedNames": {},
        "lazyUpdate": null
    },
    "status": 200,
    "statusText": "OK",
    "url": "https://ng-complete-guide-f5ed5-default-rtdb.europe-west1.firebasedatabase.app/posts.json?print=pretty&custom=key",
    "ok": true,
    "type": 4,
    "body": {
        "-MygyzwN5SUlnbGvgk5E": {
            "content": "Test content 1",
            "title": "Test 1"
        },
        "-Myh0wRbqh9wyuSzzGTm": {
            "content": "Test content 2",
            "title": "Test 2"
        }
    }
}

Response arrived, body data:

{
    "-MygyzwN5SUlnbGvgk5E": {
        "content": "Test content 1",
        "title": "Test 1"
    },
    "-Myh0wRbqh9wyuSzzGTm": {
        "content": "Test content 2",
        "title": "Test 2"
    }
}

[
    {
        "content": "Test content 1",
        "title": "Test 1",
        "id": "-MygyzwN5SUlnbGvgk5E"
    },
    {
        "content": "Test content 2",
        "title": "Test 2",
        "id": "-Myh0wRbqh9wyuSzzGTm"
    }
]


276. Multiple Interceptors.

The order in which Interceptors are provided in app.module.ts is important because that is the order in which they will be executed.

auth-interceptor.service.ts:

@Injectable({
    providedIn: 'root'
})
export class AuthInterceptorService implements HttpInterceptor {

    intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
        // req.url = 'a new url'; // will not work: req.url is immutable.
        // It is possible to clone the request properties.
        // Example: keep the existing headers and append additional ones:
        const modifiedRequest = req.clone({ headers: req.headers.append('Auth', 'xyz') });

        return next.handle(modifiedRequest);
    }
}

logging-interceptor.service.ts:

@Injectable({
    providedIn: 'root'
  })
export class LoggingInterceptorService implements HttpInterceptor {
    intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
        console.log('Outgoing request');
        console.log(req.url);
        console.log(req.headers);
        return next.handle(req).pipe(tap(event => {
            if (event.type === HttpEventType.Response) {
                console.log('Incoming response');
                console.log(event.body);
            }
        }));
    }
}

app.module.ts:

@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,
    AppRoutingModule,
    FormsModule,
    HttpClientModule
  ],
  providers: [
    { provide: HTTP_INTERCEPTORS, 
      useClass: AuthInterceptorService, 
      multi: true 
    },
    { provide: HTTP_INTERCEPTORS, 
      useClass: LoggingInterceptorService, 
      multi: true 
    }    
  ],
  bootstrap: [AppComponent]
})


277. Wrap Up.

278. Useful Resources & Links.

Useful Resources:

Official Docs: https://angular.io/guide/http

===================================================================================================
2022-03-21:

Section 19: Course Project - Http.

Using: shopping-app-router-forms

$ ng serve --port 4202

279. Module Introduction.


280. Backend (Firebase) Setup.


https://firebase.google.com
- Needs a Google account (which I have)
- Click 'Get Started'
- Click Create Project
  - Project name: ng-course-recipe-book

- Create a Database
  - Click at the left: Firestore Database
  - Click: Create database
  - Realtime Database
    - Click: Create Database
    - Realtime Database location: Belgium
    - Start in test mode
      Your data is open by default to enable quick setup. 
      However, you must update your security rules within 30 days to enable long-term client read/write access.

- url: https://ng-course-recipe-book-375da-default-rtdb.europe-west1.firebasedatabase.app/
- ng-course-recipe-book-375da-default-rtdb: null
  - The database is now not protected.

General url for the Firebase page:
- https://ng-course-recipe-book-375da-default-rtdb.europe-west1.firebasedatabase.app/database/ng-course-recipe-book-375da-default-rtdb/data


281. Setting Up the DataStorage Service.


app.module.ts:
..
import { HttpClientModule } from '@angular/common/http';

  imports: [
    BrowserModule,
    FormsModule,
    ReactiveFormsModule,
    HttpClientModule,
    AppRoutingModule
  ],

data-storage.service.ts:

import { HttpClient } from "@angular/common/http";
import { Injectable } from "@angular/core";

/**
 * 281. Setting Up the DataStorage Service.
 * 
 * @Injectable is normally optional, but it is required if injecting another service.
 */
@Injectable({
    providedIn: 'root'
  })
export class DataStorageService {

    constructor(private http: HttpClient) {}
    
}

282. Storing Recipes.

When storing multiple tupels in the Firebase database at once Firebase will not add id' to the tupels.
Instead it will assume that we will take care of it.


data-storage.service.ts:
..
@Injectable({
    providedIn: 'root'
  })
export class DataStorageService {

    private firebaseUrl: string = 'https://ng-course-recipe-book-375da-default-rtdb.europe-west1.firebasedatabase.app/';
    private firebasePostEndpoint: string = 'recipes.json';
  
    constructor(private http: HttpClient, private recipeService: RecipeService) {}

    /**
     * 282. Storing Recipes.
     * In this case no response will be set up: the website user is not interested in this information.
     */
    storeRecipes() {
        const recipes: Recipe[] = this.recipeService.getRecipes();
        this.http.put(
            this.firebaseUrl + this.firebasePostEndpoint,
            recipes)
            .subscribe(
                response => {
                    console.log(response);
                }
            );
    }
}

header.component:
- html:

                        <li><a style="cursor: pointer;" (click)="onSaveData()">Save Data</a></li>

- ts:

    constructor(private dataStorageService: DataStorageService){}

    /**
     * 282. Storing Recipes.
     */
    onSaveData() {
        this.dataStorageService.storeRecipes();
    }


283. Fetching Recipes.

On the website we can delete all recipes.


data-storage.service.ts:

    /**
     * 283. Fetching Recipes.
     * 
     * If now button 'Fetch Data' is clicked we see an array with the saved recipes in Developer Tool | Console.
     */
    fetchRecipes() {
        this.http.get<Recipe[]>(this.firebaseUrl + this.firebasePostEndpoint)
        .subscribe( recipes => {
            console.log(recipes);
            this.recipeService.setRecipes(recipes);
        });
    }

header.component:
- html:

                        <li><a style="cursor: pointer;" (click)="onFetchData()">Fetch Data</a></li>

- ts:

    /**
     * 283. Fetching Recipes.
     */
    onFetchData() {
        this.dataStorageService.fetchRecipes();
    }


284. Transforming Response Data.


https://wallpaperaccess.com/full/767048.jpg

            /**
             * map() from rxjs and <array>.map() are different methods.
             * In the following case:
             * (method) Array<Recipe>.map<unknown>(callbackfn: (value: Recipe, index: number, array: Recipe[]) => unknown, thisArg?: any): unknown[]
Calls a defined callback function on each element of an array, and returns an array that contains the results.
             */


Firebase removes empty entities, so that we have to add an empty array manually in those cases where we might get null when fetching data.

Max handles this in the course project for the ingredients array, but the same should also be done for recipes array, since it might be that the user deletes all recipes.


     * 284. Transforming Response Data.
     * Now a potential bug is fixed:
     * If for a given recipe no ingredients have been given the recipe in the Firebase db will have no ingredients array.
     * This will be fixed by passing on an empty Ingredients array.
     * For this rxjs map() and not tap() is used since the data will be changed.
     * The result of the action is that the presented recipes will always have an ingredients array.
     */
    fetchRecipes() {
        this.http.get<Recipe[]>(this.firebaseUrl + this.firebasePostEndpoint)
            /**
             * map() from rxjs and <array>.map() are different methods.
             * In the following case:
             * (method) Array<Recipe>.map<unknown>(callbackfn: (value: Recipe, index: number, array: Recipe[]) => unknown, thisArg?: any): unknown[] 
             * Calls a defined callback function on each element of an array, and returns an array that contains the results.
             */
        .pipe(map( recipes => {

            return recipes.map(recipe => {
                // Below the JS spread operator is used.
                return {...recipe, ingredients: recipe.ingredients ? recipe.ingredients : []};
            });
        }))
        .subscribe( recipes => {
            console.log(recipes);
            this.recipeService.setRecipes(recipes);
        });
    }

If Header button 'Fetch Data' is clicked:

{
    "description": "A juicy pizza! (Without ingredients to test that situation)",
    "imagePath": "https://wallpaperaccess.com/full/767048.jpg",
    "name": "Pizza",
    "ingredients": []
}
--> "ingredients" array does not have elements, but the fetchRecipes() method will nonetheless add an empty array.


285. Resolving Data Before Loading.

Todo:
- Study the Resolver functionality again.


A Resolver is functionality, treated in the Router Section, that ensures that correct data is loaded.

data-storage.service.ts:

    fetchRecipes() {
        return this.http.get<Recipe[]>(this.firebaseUrl + this.firebasePostEndpoint)
            /**
             * map() from rxjs and <array>.map() are different methods.
             * In the following case:
             * (method) Array<Recipe>.map<unknown>(callbackfn: (value: Recipe, index: number, array: Recipe[]) => unknown, thisArg?: any): unknown[] 
             * Calls a defined callback function on each element of an array, and returns an array that contains the results.
             */
            .pipe(
                map(recipes => {

                    return recipes.map(recipe => {
                        // Below the JS spread operator is used.
                        return { ...recipe, ingredients: recipe.ingredients ? recipe.ingredients : [] };
                    });
                }),
                // tap() allows code without altering the data that is being returned.
                tap(recipes => {
                    console.log(recipes);
                    this.recipeService.setRecipes(recipes);
                })
            );
    }

Note: 
- the fetchRecipes() method does not use a .subscribe() method anymore, because the resolver in data-storage.service.ts, class DataStorageService, will take
care of that via a Resolver.



recipes-resolver.service.ts

@Injectable({
    providedIn: 'root'
  })
export class RecipesResolverService implements Resolve<Recipe[]> {

    constructor(private dataStorageService: DataStorageService) {}

    /**
     * 285. Resolving Data Before Loading.
     * 
     * Note:
     * this.dataStorageService.fetchRecipes() is not subscribed.
     * The reason is that the resolver will do that for me.
     * 
     * @param route 
     * @param state 
     * @returns 
     */
    resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Recipe[] | Observable<Recipe[]> | Promise<Recipe[]> {
        return this.dataStorageService.fetchRecipes();
    }

}

header.component.ts:

    /**
     * 283. Fetching Recipes.
     * 
     * 285. Resolving Data Before Loading.
     * Due to using the RecipesResolver class now 
     * this.dataStorageService.fetchRecipes() should be this.dataStorageService.fetchRecipes().subscribe();
     * However this is redundant.
     */
    onFetchData() {
        this.dataStorageService.fetchRecipes().subscribe();
    }


286. Fixing a Bug with the Resolver.


recipes-resolver.service.ts:

     * 286. Fixing a Bug with the Resolver.
     * Only fetch data from the database if no recipes are available as yet.
     * Otherwise return the already present recipes.
     * This prevents that changes during the editing of recipes will be overwritten.
     * 
     * @param route 
     * @param state 
     * @returns 
     */
    resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Recipe[] | Observable<Recipe[]> | Promise<Recipe[]> {
        const recipes = this.recipeService.getRecipes();
        if (recipes.length === 0) {
            return this.dataStorageService.fetchRecipes();
        } else {
            return recipes;
        } 
    }

Todo:
- Study Resolvers again.
  - https://angular.io/api/router/Resolve
- Study how the editing of the recipes is implemented.


===================================================================================================
2022-03-22:

Section: Authentication & Route Protection in Angular.

287. Module Introduction.

288. How Authentication works.


Client  => Send Authentication Data => Server
        <=        Token             <=

Authentication has to happen in the Server because all data in the browser is publicly available.

Angular uses One Page Technology. 
- That means that pages are not rendered
- Client and Server are decoupled and use REST API's to communicate.
- The server will validate the username / password and it this is okay will send the client a token.
  - This token, which is a string, that also contains meta-data, is encoded, not encrypted.
  - Tokens are generated, using a specific algorithm and a specific secret which only the server knows.
  - Therefore only the server can validate incoming tokens.
- The client stores the token and attaches the token to any messsage that is sent to the server.
  - So the token needs to be attached via a header item or a query parameter to any message sent to the server.
- The client can not generate the token because it does not know the algorithm.


289. Adding the Auth Page.

$ ng generate component ./auth --skip-tests

CREATE src/app/auth/auth.component.css (0 bytes)
CREATE src/app/auth/auth.component.html (19 bytes)
CREATE src/app/auth/auth.component.ts (267 bytes)
UPDATE src/app/app.module.ts (1874 bytes)

Generated:
app.module.ts:

import { AuthComponent } from './auth/auth.component';

@NgModule({
  declarations: [
    AppComponent,
    HeaderComponent,
    RecipesComponent,
    RecipeListComponent,
    RecipeDetailComponent,
    RecipeItemComponent,
    ShoppingListComponent,
    ShoppingEditComponent,
    DropdownDirective,
    RecipeStartComponent,
    RecipeEditComponent,
    AuthComponent !!! Added when generating the Auth component.
  ],
..

app-routing.module.ts:
- Added a path for the component Authcomponent.

const appRoutes: Routes = [
    // { path: '', component: HeaderComponent},
    { path: '', redirectTo: '/recipes', pathMatch: 'full'},
    { path: 
        'recipes', 
        component: RecipesComponent,
        // Angular will run the Resolvers before loading the actual content.
        children: [
            { path: '', component: RecipeStartComponent},
            { path: 'new', component: RecipeEditComponent },
            { path: ':id', component: RecipeDetailComponent, resolve: [RecipesResolverService] },
            { path: ':id/edit', component: RecipeEditComponent, resolve: [RecipesResolverService] }
        ]
    },
    { path: 'shopping-list', component: ShoppingListComponent},
    { path: 'auth', component: AuthComponent}
];

auth.component.html:

<div class="row">
    <!-- Again: these classes are bootstrap classes -->
    <div class="col-xs-12 col-md-6 col-md-offset-3">
        <form>
            <div class="form-group">
                <label for="email">E-mail</label>
                <input type="email" id="email" class="form-control"/>
            </div>
            <div class="form-group">
                <label for="password">Password</label>
                <input type="password" id="password" class="form-control"/>
            </div>
            <div>
                <button class="btn btn-primary">Sign Up</button> | 
                <button class="btn btn-primary">Switch to Login</button>
            </div>
        </form>
    </div>
</div>

header.component.html:

            <ul class="nav navbar-nav">
                <!-- 
                    "active" is a bootstrap component.
                    routerLinkActive is an Angular attribute.
                -->
                <li routerLinkActive="active"><a routerLink="/recipes">Recipes</a></li>
                <li routerLinkActive="active"><a routerLink="/auth">Authenticate</a></li>   !!! Added a link to reach the Authenticate page.
                <li routerLinkActive="active"><a routerLink="/shopping-list">Shopping List</a></li>
            </ul>

290. Switching between Auth Modes.


auth.component:
- ts:

  isLoginMode: boolean = true;

  onSwitchMode() {
    this.isLoginMode = !this.isLoginMode;
  }

- html:

            <div>
                <!--
                    Here again String Interpolation is used.
                    Everything between the curly brackets is JS code.
                    The first button will submit the form. The second will just switch between Form Modes.
                -->
                <button type="submit" class="btn btn-primary">
                    {{ isLoginMode ? 'Login' : 'Sign Up' }}
                </button> | 
                <button type="button" class="btn btn-primary" (click)="onSwitchMode()">
                    {{ isLoginMode ? 'Sign Up' : 'Login' }}
                </button>
            </div>

291. Handling Form Input.

Here the template driven approach is used, but the reactive approach is also correct.

auth.component:
- ts:

  onSubmit(form: NgForm) {
    console.log(form.value);
    form.reset();
  }

- html:

<div class="row">
    <!-- Again: these classes are bootstrap classes -->
    <div class="col-xs-12 col-md-6 col-md-offset-3">
        <!-- Template Driven: Get access to the Angular Form object by connecting ngForm to local reference authForm. -->
        <form #authForm="ngForm" (ngSubmit)="onSubmit(authForm)">
            <div class="form-group">
                <label for="email">E-mail</label>
                <input type="email" id="email" class="form-control" ngModel name="email" required email />
            </div>
            <div class="form-group">
                <label for="password">Password</label>
                <!-- The password should have a minimum length of 6 -->
                <input type="password" id="password" class="form-control" ngModel name="password" required
                    minlength="6" />
            </div>
            <div>
                <!--
                    Here again String Interpolation is used.
                    Everything between the curly brackets is JS code.
                    The first button will submit the form. The second will just switch between Form Modes.
                -->
                <button type="submit" class="btn btn-primary" [disabled]="!authForm.valid">
                    {{ isLoginMode ? 'Login' : 'Sign Up' }}
                </button> |
                <button type="button" class="btn btn-primary" (click)="onSwitchMode()">
                    {{ isLoginMode ? 'Sign Up' : 'Login' }}
                </button>
            </div>
        </form>
    </div>
</div>


292. Preparing the Backend.

Now in Firebase:

Rules:
auth != null

Originaly:
{
  "rules": {
    ".read": "now < 1650405600000",  // 2022-4-20
    ".write": "now < 1650405600000",  // 2022-4-20
  }
}

From now on:
{
  "rules": {
    ".read": "auth != null",
    ".write": "auth != null",
  }
}

Now when going to /recipes and Manage | Fetch Data an error will be shown in DV | Console:

GET https://ng-course-recipe-book-375da-default-rtdb.europe-west1.firebasedatabase.app/recipes.json 401 (Unauthorized)

{
    "headers": {
        "normalizedNames": {},
        "lazyUpdate": null
    },
    "status": 401,
    "statusText": "Unauthorized",
    "url": "https://ng-course-recipe-book-375da-default-rtdb.europe-west1.firebasedatabase.app/recipes.json",
    "ok": false,
    "name": "HttpErrorResponse",
    "message": "Http failure response for https://ng-course-recipe-book-375da-default-rtdb.europe-west1.firebasedatabase.app/recipes.json: 401 Unauthorized",
    "error": {
        "error": "Permission denied"
    }
}

Now in Firebase:
- go to Authentication
- Get Started
- Choose Email/Password
  - Click Enable
  - Click Save
- Users, identified by Email / Password, can be added under tab 'Users'.


293. Make sure you got Recipes in your backend!


294. Preparing the Signup Request.

Google: Firebase auth rest api

--> https://firebase.google.com/docs/reference/rest/auth

The Authentication API is different from the database API.
We will need two methods:
- https://firebase.google.com/docs/reference/rest/auth#section-create-email-password
  - https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=[API_KEY]
- https://firebase.google.com/docs/reference/rest/auth#section-sign-in-email-password

For the API_KEY go in Firebase to:
- Project Oveview:
  - Project Settings
    Web API Key: AIzaSyDTzJI66MpyZKI0nzOIAlMWSRTvO3cb9Hc

https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=[API_KEY]
-->
https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=AIzaSyDTzJI66MpyZKI0nzOIAlMWSRTvO3cb9Hc


$ ng generate service ./auth/auth --skip-tests

auth.service.ts:

/**
 * 294. Preparing the Signup Request.
 * https://firebase.google.com/docs/reference/rest/auth#section-create-email-password
 * - Here the definition of the Response Payload is described.
 */
interface AuthResponseData {
  idToken: string;
  email: string;
  refreshToken: string;
  expiresIn: string;
  localId: string;
}

@Injectable({
    providedIn: 'root'
  })
export class AuthService {
  private FirebaseAuthUrl = 'https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=AIzaSyDTzJI66MpyZKI0nzOIAlMWSRTvO3cb9Hc';

  constructor(private httpClient: HttpClient) { }

  /**
   * 294. Preparing the Signup Request.
   * https://firebase.google.com/docs/reference/rest/auth#section-create-email-password
   * 
   * Returns: Observable with format defined via the interface AuthResponseData.
   */
  signup(email: string, password: string) {
    return this.httpClient.post<AuthResponseData>(
      this.FirebaseAuthUrl,
      {
        email: email,
        password: password,
        returnSecureToken: true
      }
    );
  }
}


295.Sending the Signup Request.

auth.component.ts:

  constructor(private authService: AuthService) { }

  onSubmit(form: NgForm) {
    console.log(form.value);
    if (!form.valid) {
      return;
    }
    const email = form.value.email;
    const password = form.value.password;

    if (this.isLoginMode) {
      //
    } else {
      this.authService.signup(email, password).subscribe(
        resData => {
          console.log(resData);
        }, error => {
          console.log(error);
        }
      )
    };
    form.reset();
  }

If we now fill in for Sign Up:
- Email: test@test.com
- Password: 123456

We receive the following in the logging:

{
    "kind": "identitytoolkit#SignupNewUserResponse",
    "idToken": "eyJhbGciOiJSUzI1NiIsImtpZCI6ImIwNmExMTkxNThlOGIyODIxNzE0MThhNjdkZWE4Mzc0MGI1ZWU3N2UiLCJ0eXAiOiJKV1QifQ.eyJpc3MiOiJodHRwczovL3NlY3VyZXRva2VuLmdvb2dsZS5jb20vbmctY291cnNlLXJlY2lwZS1ib29rLTM3NWRhIiwiYXVkIjoibmctY291cnNlLXJlY2lwZS1ib29rLTM3NWRhIiwiYXV0aF90aW1lIjoxNjQ3OTYxNjIxLCJ1c2VyX2lkIjoiaU1YVWUwcTFPOGMydk0wRDN3eWlBNWp6Rmo4MiIsInN1YiI6ImlNWFVlMHExTzhjMnZNMEQzd3lpQTVqekZqODIiLCJpYXQiOjE2NDc5NjE2MjEsImV4cCI6MTY0Nzk2NTIyMSwiZW1haWwiOiJ0ZXN0QHRlc3QuY29tIiwiZW1haWxfdmVyaWZpZWQiOmZhbHNlLCJmaXJlYmFzZSI6eyJpZGVudGl0aWVzIjp7ImVtYWlsIjpbInRlc3RAdGVzdC5jb20iXX0sInNpZ25faW5fcHJvdmlkZXIiOiJwYXNzd29yZCJ9fQ.VRCn2sM-17s8tGll39sLlSAzJOJV32UVdmmyLQ1AtKuZnp2D2RfCwvmiQtjACT_DTztctNTnr5jTENqrXNvAyr23bhWd9ULEvHDgrobj3C02X9A2hDRHPOWfe3LL8jTmMG4ebwVYiNplBzqChI9HZfJd5vVPpcwetOzjhTCMWlnVzxtUtPtrcyabgBGp-JIk790PiDFe1h4KzvTp5E4UkSlyEtJ4cmxhwL67sTa2mbUG-znouXcBO4sCVSE3oNJDV31e1-KvyuFAEE80ARBatRPpXQ2C7nmeYD3AlqEFrt2wgeIt2fBwqRPSApI1UvMn6mKdHn0R6iAoDiETd45qTw",
    "email": "test@test.com",
    "refreshToken": "AIwUaOkvckwUuyun03bxEB4L6JjHyif6j2pkdHW6LqQOcEIvlW4kDIvm9plPeSrn8JvsSuNT65BUnajfqGlJ2MEwj6FB8CWzF0sdypo3ullCft_1sA4IZ8oOU3XuaS0zEcoRzK-zP1zV2rehXL287U-UfYqgljm-nAOVz2HHHY66pUpsRY3NAOYQ9DCxD49IQeKfQMr6ga1GgG50IBFN0gJWeBbgmG-cPGxy-_80r0sG3354Ac3SsTM",
    "expiresIn": "3600",
    "localId": "iMXUe0q1O8c2vM0D3wyiA5jzFj82"
}

--> 
- kind
- idToken
- email
- refreshToken
- expiresIn: 3600 === 1 hour !!!!
- localId

When looking at the database under users the account with email test@test.com is visible.

When we try again to sign up using the same Email we receive the following error because the email account already exists.


{
    "headers": {
        "normalizedNames": {},
        "lazyUpdate": null
    },
    "status": 400,
    "statusText": "OK",
    "url": "https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=AIzaSyDTzJI66MpyZKI0nzOIAlMWSRTvO3cb9Hc",
    "ok": false,
    "name": "HttpErrorResponse",
    "message": "Http failure response for https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=AIzaSyDTzJI66MpyZKI0nzOIAlMWSRTvO3cb9Hc: 400 OK",
    "error": {
        "error": {
            "code": 400,
            "message": "EMAIL_EXISTS",
            "errors": [
                {
                    "message": "EMAIL_EXISTS",
                    "domain": "global",
                    "reason": "invalid"
                }
            ]
        }
    }
}


296. Addig a Loading Spinner & Error Handling Logic.

Google: css loading spinner

--> https://loading.io/css/
  - Here you can find beautiful loading spinners.
  - Copy the ring:

.lds-ring {
  display: inline-block;
  position: relative;
  width: 80px;
  height: 80px;
}
.lds-ring div {
  box-sizing: border-box;
  display: block;
  position: absolute;
  width: 64px;
  height: 64px;
  margin: 8px;
  border: 8px solid #fff;
  border-radius: 50%;
  animation: lds-ring 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite;
  border-color: #fff transparent transparent transparent;
}
.lds-ring div:nth-child(1) {
  animation-delay: -0.45s;
}
.lds-ring div:nth-child(2) {
  animation-delay: -0.3s;
}
.lds-ring div:nth-child(3) {
  animation-delay: -0.15s;
}
@keyframes lds-ring {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

And template: <div class="lds-ring"><div></div><div></div><div></div><div></div></div>

$ ng generate component ./shared/loading-spinner/loading-spinner --skip-tests
CREATE src/app/shared/loading-spinner/loading-spinner/loading-spinner.component.css (0 bytes)
CREATE src/app/shared/loading-spinner/loading-spinner/loading-spinner.component.html (30 bytes)
CREATE src/app/shared/loading-spinner/loading-spinner/loading-spinner.component.ts (310 bytes)
UPDATE src/app/app.module.ts (2013 bytes)

loading-spinner.component
- css:

Contains the css-ring definition mentioned above

- ts:

import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-loading-spinner',
  template: '<div class="lds-ring"><div></div><div></div><div></div><div></div></div>', !!! Note: template, NOT templateURL. the content is as mentioned above.
  styleUrls: ['./loading-spinner.component.css']
})
export class LoadingSpinnerComponent implements OnInit {

  constructor() { }

  ngOnInit(): void {
  }

}

auth.component:
- ts:

  error: string = null;

        }, error => {
          console.log(error);
          this.error = 'An Error Occurred!';
          this.isLoading = false;
        }

- html:

        <div class="alert alert-danger" *ngIf="error">
            <p>{{ error }}</p>
        </div>
        <div *ngIf="isLoading" style="text-align: center;">
            <app-loading-spinner></app-loading-spinner>
        </div>


297. Improving Error Handling.

Currently we will have an error because we are trying to sign up multiple times.


When signing up again with the same account we receive an error message from the Firebase db:

{
    "headers": {
        "normalizedNames": {},
        "lazyUpdate": null
    },
    "status": 400,
    "statusText": "OK",
    "url": "https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=AIzaSyDTzJI66MpyZKI0nzOIAlMWSRTvO3cb9Hc",
    "ok": false,
    "name": "HttpErrorResponse",
    "message": "Http failure response for https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=AIzaSyDTzJI66MpyZKI0nzOIAlMWSRTvO3cb9Hc: 400 OK",
    "error": {
        "error": {
            "code": 400,
            "message": "EMAIL_EXISTS",
            "errors": [
                {
                    "message": "EMAIL_EXISTS",
                    "domain": "global",
                    "reason": "invalid"
                }
            ]
        }
    }
}


auth.service.ts:

  signup(email: string, password: string) {
    return this.httpClient.post<AuthResponseData>(
      this.FirebaseAuthUrl,
      {
        email: email,
        password: password,
        returnSecureToken: true
      }
    ).pipe(catchError(errorRes => {
      let errorMessage = 'An unknonwn error occurred!';
      if (!errorRes.error || ! errorRes.error.error) {
        return throwError(errorMessage);
      }
      switch(errorRes.error.error.message) {
        case 'EMAIL_EXISTS':
          errorMessage = 'This email with value ' + email + ' exists already';
      }
      return throwError(errorMessage);
    }));
  }

auth.component.ts:

  onSubmit(form: NgForm) {
    console.log(form.value);
    if (!form.valid) {
      return;
    }
    const email = form.value.email;
    const password = form.value.password;

    this.isLoading = true;
    if (this.isLoginMode) {
      //
    } else {
      this.authService.signup(email, password).subscribe(
        resData => {
          console.log(resData);
          this.isLoading = false;
        }, 
        /**
         * 297. Improving Error Handling.
         * Note that the value of errorMessage is determined in authService.signup where the 
         * error is actually caught.
         * 
         * @param errorMessage 
         */
        errorMessage => {
          console.log(errorMessage);
          this.error = errorMessage;
          this.isLoading = false;
        }
      )
    };
    form.reset();
  }


298. Sending Login Requests.

Resource:
- https://firebase.google.com/docs/reference/rest/auth#section-sign-in-email-password
  - Endpoint
    - https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=[API_KEY]

Check in detail:
- auth.service.ts
- auth.component.ts


299. Login Error Handling.


auth.service.ts:

  login(email: string, password: string) {
    return this.httpClient.post<AuthResponseData>(this.FirebaseSignInUrl + this.webApiKey,
      {
        email: email,
        password: password,
        returnSecureToken: true
      }).pipe(catchError(errorRes => this.handleError(errorRes)));
  }

  Note:

.pipe(catchError(errorRes => this.handleError(errorRes)));

Can also be:

.pipe(catchError(this.handleError));

  private handleError(errorRes: HttpErrorResponse) {
    let errorMessage = 'An unknonwn error occurred!';
    if (!errorRes.error || ! errorRes.error.error) {
      return throwError(errorMessage);
    }
    switch(errorRes.error.error.message) {
      case 'EMAIL_EXISTS':
        errorMessage = 'This email exists already';
        break;
      case 'EMAIL_NOT_FOUND':
        errorMessage = 'This email does not exist';
        break;
      case 'INVALID_PASSWORD':
        errorMessage = 'This password is not correct';
        break;
    }
    return throwError(errorMessage);
  }


300. Creating & Storing the User Data.

Resource:
- https://firebase.google.com/docs/reference/rest/auth#section-sign-in-email-password

Request Body Payload
  - Property Name       Type    Description
    - email             string  The email for the user to create.
    - password          string  The password for the user to create.
    - returnSecureToken boolean Whether or not to return an ID and refresh token. Should always be true.

Response Payload
  - Property Name   Type    Description
    - idToken       string  A Firebase Auth ID token for the newly created user.
    - email         string  The email for the newly created user.
    - refreshToken  string  A Firebase Auth refresh token for the newly created user.
    - expiresIn     string  The number of seconds in which the ID token expires.
    - localId       string  The uid of the newly created user.


user.model.ts:

export class User {

    constructor(
        public email: string,
        public id: string,
        private _token: string,
        private _tokenExpirationDate: Date
    ) {}

    get token() {
        if (!this._tokenExpirationDate || new Date() > this._tokenExpirationDate) {
            // In this case the token is not valid anymore.
            return null;
        }
        return this._token;
    }
}

auth.service.ts:

  /**
   * 300. Creating & Storing the User Data.
   * 
   * https://firebase.google.com/docs/reference/rest/auth#section-sign-in-email-password
   * 
   * Here a new user is created and logged in.
   * 
   * @param email The email for the newly created user.
   * @param userId localId. The uid of the newly created user.
   * @param token A Firebase Auth ID token for the newly created user.
   * @param expiresIn The number of seconds in which the ID token expires.
   */
  private handleAuthentication(email: string, userId: string, token: string, expiresIn: number) {
    const expirationDate = new Date(
      /**
       * Date().getTime() = time in msec since 1970.
       * expiresIn = time in sec. 
       *  - Is a string but in this case should be a number. Converted via the '+' in front of resData.expiresIn.
       */
      new Date().getTime() + expiresIn * 1000
    );
    const user = new User(
      email,
      userId,
      token,
      expirationDate
    );
    // Here the user is set / emitted as our (new) user.
    this.user.next(user);
  }

  login(email: string, password: string) {
    return this.httpClient.post<AuthResponseData>(this.FirebaseSignInUrl + this.webApiKey,
      {
        email: email,
        password: password,
        returnSecureToken: true
      }).pipe(catchError(errorRes => this.handleError(errorRes)),
        tap(resData => {
          this.handleAuthentication(
            resData.email,
            resData.localId,
            resData.idToken,
            +resData.expiresIn);
        }));
  }

Logging in:
Developer Tool: Console:

{
    "kind": "identitytoolkit#VerifyPasswordResponse",
    "localId": "iMXUe0q1O8c2vM0D3wyiA5jzFj82",
    "email": "test@test.com",
    "displayName": "",
    "idToken": "eyJhbGciOiJSUzI1NiIsImtpZCI6IjQ2NDExN2FjMzk2YmM3MWM4YzU5ZmI1MTlmMDEzZTJiNWJiNmM2ZTEiLCJ0eXAiOiJKV1QifQ.eyJpc3MiOiJodHRwczovL3NlY3VyZXRva2VuLmdvb2dsZS5jb20vbmctY291cnNlLXJlY2lwZS1ib29rLTM3NWRhIiwiYXVkIjoibmctY291cnNlLXJlY2lwZS1ib29rLTM3NWRhIiwiYXV0aF90aW1lIjoxNjQ4NTkwMzcyLCJ1c2VyX2lkIjoiaU1YVWUwcTFPOGMydk0wRDN3eWlBNWp6Rmo4MiIsInN1YiI6ImlNWFVlMHExTzhjMnZNMEQzd3lpQTVqekZqODIiLCJpYXQiOjE2NDg1OTAzNzIsImV4cCI6MTY0ODU5Mzk3MiwiZW1haWwiOiJ0ZXN0QHRlc3QuY29tIiwiZW1haWxfdmVyaWZpZWQiOmZhbHNlLCJmaXJlYmFzZSI6eyJpZGVudGl0aWVzIjp7ImVtYWlsIjpbInRlc3RAdGVzdC5jb20iXX0sInNpZ25faW5fcHJvdmlkZXIiOiJwYXNzd29yZCJ9fQ.BSQF6d9q3suAyRYzacM7x58_3jmgwkJFD1XwsAC_jGifklOkzheNjlqnhIWRyevLIRVN59Yd4tmiu4VOwxtCqVCbSGYJvcI9otIwoXJaq346QmrZ2ThqI3MQqx0MnYN0NBNw6D2nbd_jXSTRGxeNun1OxqGrpP_xLW7IriQXpYHjZYG10Vtw1XiEXrKTXf8Z7sSXPkwp_JAz1VwCTLYVp72PDDVmXY3MZqHAteN5m5qC0D3sPS1c1kJB-FzlWH6j1dR_zZuEP_i2DTp53VpUgnSqaofjVCVameZ-or-9VpEIK1QzBZ-cF3jUo161k6sfDzeVZp7wBPCEqQCsIJy14A",
    "registered": true,
    "refreshToken": "AIwUaOkzQMW08r0_JeoqBcaw3zDWBIM41vKWu5p0VLIfeOHA9hDWSdKvA9iooOgM3Ep-vHO98hpGUCRIGU2n7Y4GVJpWsW-7sbUxYXmEFlcVeXoF4ZAoqBaq3u5R-mP68mg6pOU927H82MoZSuialpe2p9Och__8XiCwG59y8lB9DyFh-oFcRMRaaODtIl6P9bnzBOjQwNJwFxJilEq6nj8s9RSVOS7oWn8W_w-S-X-R3buNWCm_wso",
    "expiresIn": "3600"
}


301. Reflecting the Auth State in the UI.

The user will be forwarded to a different route (so not { path: 'auth', component: AuthComponent} ) once the user is logged in.
This can be done in auth.service.ts or in auth.component.ts.
Up to personal preference.

Now when logging in I go to the /Recipies page.

Login:
{
    "kind": "identitytoolkit#VerifyPasswordResponse",
    "localId": "iMXUe0q1O8c2vM0D3wyiA5jzFj82",
    "email": "test@test.com",
    "displayName": "",
    "idToken": "eyJhbGciOiJSUzI1NiIsImtpZCI6IjQ2NDExN2FjMzk2YmM3MWM4YzU5ZmI1MTlmMDEzZTJiNWJiNmM2ZTEiLCJ0eXAiOiJKV1QifQ.eyJpc3MiOiJodHRwczovL3NlY3VyZXRva2VuLmdvb2dsZS5jb20vbmctY291cnNlLXJlY2lwZS1ib29rLTM3NWRhIiwiYXVkIjoibmctY291cnNlLXJlY2lwZS1ib29rLTM3NWRhIiwiYXV0aF90aW1lIjoxNjQ4NjMwNjc3LCJ1c2VyX2lkIjoiaU1YVWUwcTFPOGMydk0wRDN3eWlBNWp6Rmo4MiIsInN1YiI6ImlNWFVlMHExTzhjMnZNMEQzd3lpQTVqekZqODIiLCJpYXQiOjE2NDg2MzA2NzcsImV4cCI6MTY0ODYzNDI3NywiZW1haWwiOiJ0ZXN0QHRlc3QuY29tIiwiZW1haWxfdmVyaWZpZWQiOmZhbHNlLCJmaXJlYmFzZSI6eyJpZGVudGl0aWVzIjp7ImVtYWlsIjpbInRlc3RAdGVzdC5jb20iXX0sInNpZ25faW5fcHJvdmlkZXIiOiJwYXNzd29yZCJ9fQ.Hr3numrr5NJ58RmB021viuXWMxPcH2K8RHu6CKwRui6ybrPbV32xll-vzqNVUSfkE2WaubzYnDia1vFqJ-O8B3F9b_-8XCCerZD1pq9L_tjf4M4F_VMHo-m1NglsAn339LN22VifPAhiylHhQsWBYDdeKLGJzxZooh75XsM9AD_Di3ULCWyNqzHL6neU8zl1X_GN3Uk-M2vLrW93en3GXEoKRjKp2nJDXoy6Ra9xVtnmMUUX8kNCT2HsC5uFto3cccJMKdbBGO2Lvbc0kKgw6ZGIMBBlEK0ySXv0JqQKw-FcBI8bgUYDDBAlcbTue7A4kTVyoLCPqXJDBcdT8hwU1Q",
    "registered": true,
    "refreshToken": "AIwUaOkPpOE1NbfWq3oRRs095YF-Rtqo7yE50p92G3ZhrCRHduB2TEN2YxyNUBMBqZH88Ko0bx9_RtKRyu2mkkLbVUHQiBFpHwAqkqG6-04DWs1KEPpyQ4NPoKBNQKqNvyksx56R3j95RePlzNUbmt4ytpSziyaBNfTFdyg1VRlYpih_qsQ2SBQzKMQWckLDYghfvEY1mHPuSgD4T7onRzJfxY2vNGz-1HAtc4NZVEBSWAXBuazOjSQ",
    "expiresIn": "3600"
}

The functionality works for both Login and Signup.

New setup:
- In header.component.html:
  - the recipes should not be visible if we are not logged in.
  - the shoppinglist should always be visible.
  - the authenticate should not be visible if we are logged in.
  - The saving / fetching functionality should not be activated when not logged in.
  - A logout button.

Users:
- test@test.com
- test2@test.com
- pwd: 123456

Relevant:
- auth.compontent
- header.component

Functionality is added in order to enable login.


302. Adding the Token to Outgoing Requests.

We have received a token from Firebase as part of the login.
Now we need to add the token to outgoing requests. Otherwise Firebase will not understand that our request is legitimate.

Resources:
- https://www.thecodehubs.com/what-is-subject-and-behavior-subject-in-angular-13/
- https://rxjs.dev/api/operators/exhaustMap

What is a Subject?

The subject is a special type of Observable in the RxJs Library with the help of that we can send our data to other components or services. 
A Subject is like an Observable but it is multicast to many observers which means the subject is at the same time an Observable and an Observer.

Syntax:
  subject = new Subject();

What is a Behavior Subject?

Behavior Subject is similar to a subject but:
1. we can set the initial value.
2. It has an extra feature, i.e. it preserves the last emitted value. 
  That means if a value was emitted earlier and if a subscription was added after the value was emitted, then the subscription will give the last value that was emitted.

Syntax:
  const subject = new BehaviorSubject(0); //0 is the initial value.



data-storage.service.ts:


    /**
     * 283. Fetching Recipes.
     * 
     * If now button 'Fetch Data' is clicked we see an array with the saved recipes in Developer Tool | Console.
     * 
     * 284. Transforming Response Data.
     * Now a potential bug is fixed:
     * If for a given recipe no ingredients have been given the recipe in the Firebase db will have no ingredients array.
     * This will be fixed by passing on an empty Ingredients array.
     * For this rxjs map() and not tap() is used since the data will be changed.
     * The result of the action is that the presented recipes will always have an ingredients array.
     * 
     * 302. Adding the Token to Outgoing Requests.
     * 
     */
    fetchRecipes() {
        return this.authService.user.pipe(
            // take(1) tells Angular that the function will only take one value from the observable.
            // this means that it is not necessary to manually unsubscribe.
            take(1),
            /**
             * The exhaustMap function waits for the first Observable to complete.
             * It will then create a new Observable which will replace the first Observable.
             * So in this case the BehaviorSubject user is replaced by the http Observable.
             * https://rxjs.dev/api/operators/exhaustMap
             */
            exhaustMap(user => {
                return this.http.get<Recipe[]>(
                    this.firebaseUrl + this.firebasePostEndpoint,
                    {
                        // Note that user.token is the getter method for _token.
                        params: new HttpParams().set('auth', user.token)
                    }
                );
            }),
            // The map operator will apply a function to that data and return the result
            map(recipes => {

                return recipes.map(recipe => {
                    // Below the JS spread operator is used.
                    console.log('DataStorageService.fetchRecipes:')
                    console.log(recipe);
                    return {
                        ...recipe,
                        ingredients: recipe.ingredients ? recipe.ingredients : []
                    };
                });
            }),
            // The tap operator takes a data, apply a function to that data but returns the original data, 
            // if the function bothered to return a result, tap just ignores it
            tap(recipes => {
                this.recipeService.setRecipes(recipes);
            })
        );
    }

will now become:


{
    "kind": "identitytoolkit#VerifyPasswordResponse",
    "localId": "iMXUe0q1O8c2vM0D3wyiA5jzFj82",
    "email": "test@test.com",
    "displayName": "",
    "idToken": "eyJhbGciOiJSUzI1NiIsImtpZCI6IjQ2NDExN2FjMzk2YmM3MWM4YzU5ZmI1MTlmMDEzZTJiNWJiNmM2ZTEiLCJ0eXAiOiJKV1QifQ.eyJpc3MiOiJodHRwczovL3NlY3VyZXRva2VuLmdvb2dsZS5jb20vbmctY291cnNlLXJlY2lwZS1ib29rLTM3NWRhIiwiYXVkIjoibmctY291cnNlLXJlY2lwZS1ib29rLTM3NWRhIiwiYXV0aF90aW1lIjoxNjQ4NjQ0NTI2LCJ1c2VyX2lkIjoiaU1YVWUwcTFPOGMydk0wRDN3eWlBNWp6Rmo4MiIsInN1YiI6ImlNWFVlMHExTzhjMnZNMEQzd3lpQTVqekZqODIiLCJpYXQiOjE2NDg2NDQ1MjYsImV4cCI6MTY0ODY0ODEyNiwiZW1haWwiOiJ0ZXN0QHRlc3QuY29tIiwiZW1haWxfdmVyaWZpZWQiOmZhbHNlLCJmaXJlYmFzZSI6eyJpZGVudGl0aWVzIjp7ImVtYWlsIjpbInRlc3RAdGVzdC5jb20iXX0sInNpZ25faW5fcHJvdmlkZXIiOiJwYXNzd29yZCJ9fQ.dr7W-koXkGsLfS9Q6t07aLmixWyKbguHmqpetnO-94wu6V2MYulQkG99UUaOCwi0f15d-iWXnkNbjh0TH12AQk_pmneBni-WR6fcQAnF7hDynElcF7OfuWDVeb0K_NaCiZ9_3ITD5XQf8a6B2pYkDFGDCu_bAijLtEkrk2oVJh1nMxQvC5UmHunuwNxgZj-JpgR9ZU5z2snRos4soLSTQwU2wubTN1j6ed5wCQ3RP2mgaIiw-Qjm5xwftiyXgJeqNug2by--oQVC6XVNAm6Sv-uxT79Vgdj_uN0ilZWMYK8dn70WIXVphwFMXyhy9jy13I2scudja-e35jyH8bhBcQ",
    "registered": true,
    "refreshToken": "AIwUaOm6eIalU2omL3HSY9GmhHyBacmN9GsQwI36HVUnTXJPJcvRVUvlEkXqrvRpzeYNwuU_9LcfEMRm2ccI4pfWgX6FjQ0c9scOpTKJ33kbrjAnkoc2oP9jEHnd0QL5M1lDIrLksKRyBsR-Wt8kVa-T5Ai6sbuEHE-tJneUTRTd49ZkwI8Nxagsytzr9jdtfLa3-arpnGBLxubPw16U0lCMmSEqb3Fy0WCs88xbXspp-bu4Gu0jaxk",
    "expiresIn": "3600"
}



303. Attaching the token with an interceptor.

Resources:
- https://angular.io/guide/http


All CRUD actions, specified in data-storage.service.ts, will be handled in the same way.
For this an interceptor will be used.

https://angular.io/api/common/http/HttpInterceptor


  The Angular HTTP Interceptor is introduced along with the new HTTPClientModule. 
  The Interceptor helps us to modify the HTTP Request by intercepting it before the Request is sent to the back end. 
  The Interceptor can be useful for adding custom headers to the outgoing request, logging the incoming response, etc.

  Image result for angular interceptor
  Interceptor is a special Angular Service that can be used to intercept all the request and response calls and modify them to our requirement.

  Although interceptors are capable of modifying requests and responses, the HttpRequest and HttpResponse instance properties are readonly, rendering them largely immutable.


auth-interceptor.service.ts:

/**
 * 303. Attaching the token with an interceptor.
 * 
 * In this case we do not use providedIn: 'root'.
 * We have to provide the service in a way that Angular understands it.
 * This is done in app.module.ts.
 * 
 * Purpose:
 * Add the user.token to all outgoing requests.
 * 
 */
@Injectable()
export class AuthInterceptorService implements HttpInterceptor {

    constructor(private authService: AuthService) { }

    intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
        return this.authService.user.pipe(
            // take(1) tells Angular that the function will only take one value from the observable.
            // this means that it is not necessary to manually unsubscribe.
            take(1),
            /**
             * The exhaustMap function waits for the first Observable to complete.
             * It will then create a new Observable which will replace the first Observable.
             * So in this case the BehaviorSubject user is replaced by the http Observable.
             * https://rxjs.dev/api/operators/exhaustMap
             * 
             * https://angular.io/guide/http
             * 
             * The HttpRequest and HttpResponse instance properties are readonly, rendering them largely immutable.
             * If you must alter a request, clone it first and modify the clone before passing it to next.handle().
             */
            exhaustMap(user => {
                /**
                 * The user can be null.
                 * The user is declared as such in AuthService.
                 * When signing up this will be the case. 
                 * For this situation pass the request without a user token. 
                 * This could be further modified e.g. for specific url's.
                 */
                if (!user) {
                    return next.handle(req);
                }
                const modifiedReq = req.clone({
                    // Note that user.token is the getter method for _token.
                    params: new HttpParams().set('auth', user.token)
                });
                return next.handle(modifiedReq);
            })
        );
    }
}

app.mdule.ts:

  providers: [
    ShoppingListService, 
    RecipeService, 
    /**
     * 303. Attaching the token with an interceptor.
     * Set multi: true to allow for multiple interceptors, even if at the moment only one is used.
     */
    {
      provide: HTTP_INTERCEPTORS, 
      useClass: AuthInterceptorService, 
      multi: true
    }
  ],


data-storage.service.ts has been rewritten.

     * 303. Attaching the token with an interceptor.
     * 
     * Before this functionality is executed Interceptor AuthInterceptorService will add the authentication token
     * that has been provided by Firebase when logging in.
     * 
     */
    fetchRecipes() {
        return this.http.get<Recipe[]>(
            this.firebaseUrl + this.firebasePostEndpoint
        ).pipe(
            // The map operator will apply a function to that data and return the result
            map(recipes => {

                return recipes.map(recipe => {
                    // Below the JS spread operator is used.
                    console.log('DataStorageService.fetchRecipes:')
                    console.log(recipe);
                    return {
                        ...recipe,
                        ingredients: recipe.ingredients ? recipe.ingredients : []
                    };
                });
            }),
            // The tap operator takes a data, apply a function to that data but returns the original data, 
            // if the function bothered to return a result, tap just ignores it
            tap(recipes => {
                this.recipeService.setRecipes(recipes);
            })
        );
    }


304. Adding Logout.

auth.service.ts:

  logout() {
    this.user.next(null);
  }

header.component:
- ts:

    onLogout() {
        this.authService.logout();
        this.router.navigate(['/auth']);
    }

- html:

            ..
            <ul class="nav navbar-nav navbar-right">
                <li *ngIf="isAuthenticated">
                    <a style="cursor: pointer;" (click)="onLogout()">Logout</a>
                </li>

                ..


305. Adding Auto-login.

Resources:
- https://javascript.plainenglish.io/how-to-persist-state-with-localstorage-in-angular-42a4a47ed123


At the moment once we are logged in if we reload the page we will lose our credentials, because the token will be lost.
Thus the token needs to be persisted.

For this we can use cookies or browser local storage.

auth.service.ts:

  private handleAuthentication(email: string, userId: string, token: string, expiresIn: number) {
    const expirationDate = new Date(
      /**
       * Date().getTime() = time in msec since 1970.
       * expiresIn = time in sec. 
       *  - Is a string but in this case should be a number. Converted via the '+' in front of resData.expiresIn.
       */
      new Date().getTime() + expiresIn * 1000
    );
    const user = new User(
      email,
      userId,
      token,
      expirationDate
    );
    // Here the user is set / emitted as our (new) user.
    this.user.next(user);
    /**
     * 305. Adding Auto-login.
     * Adding this will store the user properties in the Local Storage once logged in.
     * This will be visible in: Developer Tool | Application | Storage | Local Storage: http://localhost:<portnumber> 
     */
    localStorage.setItem('userData', JSON.stringify(user));
  }

  /**
   * 305. Adding Auto-login.
   * Added AuthService.autoLogin().
   * This will ensure that once logged in or signup we remain logged even if the web page is reloaded.
   */
  autoLogin() {
    const userData: {
      email: string;
      id: string;
      _token: string;
      _tokenExpirationDate: string;
    } = JSON.parse(localStorage.getItem('userData'));
    if (!userData) {
      // There is no data: the user (still) needs to log in.
      return;
    }
    const loadedUser = new User(
      userData.email,
      userData.id,
      userData._token,
      new Date(userData._tokenExpirationDate)
    );

    if (loadedUser.token) {
      this.user.next(loadedUser);
    }
  }

app.compoonent:
- ts:

/**
 * 305. Adding Auto-login.
 * Added AuthService.autoLogin().
 * This will ensure that once logged in or signup we remain logged even if the web page is reloaded.
 */
@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent implements OnInit{
  title = 'shopping-app';

  constructor(private authService: AuthService) {}

  ngOnInit(): void {
    this.authService.autoLogin();
  }

}


$ ng serve --port 4203

After having logged in (test@test.com / 123456) in the web page:

After login in Developer Tool | Application | Storage | Local Storage: http://localhost:4203

{
    "email": "test@test.com",
    "id": "iMXUe0q1O8c2vM0D3wyiA5jzFj82",
    "_token": "eyJhbGciOiJSUzI1NiIsImtpZCI6IjQ2NDExN2FjMzk2YmM3MWM4YzU5ZmI1MTlmMDEzZTJiNWJiNmM2ZTEiLCJ0eXAiOiJKV1QifQ.eyJpc3MiOiJodHRwczovL3NlY3VyZXRva2VuLmdvb2dsZS5jb20vbmctY291cnNlLXJlY2lwZS1ib29rLTM3NWRhIiwiYXVkIjoibmctY291cnNlLXJlY2lwZS1ib29rLTM3NWRhIiwiYXV0aF90aW1lIjoxNjQ4NzMxMTcxLCJ1c2VyX2lkIjoiaU1YVWUwcTFPOGMydk0wRDN3eWlBNWp6Rmo4MiIsInN1YiI6ImlNWFVlMHExTzhjMnZNMEQzd3lpQTVqekZqODIiLCJpYXQiOjE2NDg3MzExNzEsImV4cCI6MTY0ODczNDc3MSwiZW1haWwiOiJ0ZXN0QHRlc3QuY29tIiwiZW1haWxfdmVyaWZpZWQiOmZhbHNlLCJmaXJlYmFzZSI6eyJpZGVudGl0aWVzIjp7ImVtYWlsIjpbInRlc3RAdGVzdC5jb20iXX0sInNpZ25faW5fcHJvdmlkZXIiOiJwYXNzd29yZCJ9fQ.JvL4SI0xKYXbL34NtDuyV0cyhHK0rCTMFrc6hJVCPSpf2KbKkhf0tDu3m4PebZrQEHIfeLicZnPkVzREG14nHVBhExkjcgu4ASgmM1OCSCdVSoG0Y9UVdMqSXZBDDfhYS_wx2FqngL3nb_wzOeLftLd9hFW5RQUTXOFeCNjEjT72VyGkh-kUtywvrx3UUuk0nl-ExMQnuiGLx9L6NDPNp43LROd_WzXikJ_kYD5QkPjXTCAFTObqpjleUs8nLLGDLSOdeUh_SHlOi-ACoStmFFmnuyvgw1XLCr_EmGDkTInWetGlqWYCAroxpmS1dtnoaINF8b6txDMlnZufqCWpKg",
    "_tokenExpirationDate": "2022-03-31T13:52:51.556Z"
}


How to handle JavaScript localStorage:

https://javascript.plainenglish.io/how-to-persist-state-with-localstorage-in-angular-42a4a47ed123

Background

  localStorage is a system that allows you to access and store data using the browsers’ Document object.

  The data is stored in form of a key-value pair and the keys and values use UTF-16 DOMString format.

  Data stored via localStorage is persisted across browser sessions.

Anatomy of localStorage

localStorage basically has four main functions, which we will implement in our service wrapper.

  - localStorage.setItem('key', 'value')  - allows you to store an item in the browser storage
  - localStorage.getItem('key')           - allows you to read the value for the specified key item from the browser storage.
  - localStorage.removeItem('key')        - allows you to remove/delete the item with the specified key from the browser storage.
  - localStorage.clear()                  - removes all the items in the storage


306. Adding Auto-Logout.

Our Firebase token will expire after one hour.

  /**
   * 306. Adding Auto-Logout.
   * This method needs to be called every time a new user is admitted to the application.
   * 
   * @param expirationDuration in milliseconds. The value will be received from the Firebase setting.
   *        (normally 3600 sec).
   */
  autoLogout(expirationDuration: number) {
    console.log('expirationDuration = ' + expirationDuration);
    this.tokenExpirationTimer = setTimeout(() => {
      this.logout();
    },
      expirationDuration
    );
  }

This method will be used when:
- reloading
- when a new customer has logged in


  private handleAuthentication(email: string, userId: string, token: string, expiresIn: number) {

    // This functionality will be reached if logged in and thus the userData will be available.
    if (loadedUser.token) {
      this.user.next(loadedUser);
      const expirationDuration = new Date(userData._tokenExpirationDate).getTime() - new Date().getTime();
      console.log('expirationDuration = ' + expirationDuration);
      this.autoLogout(expirationDuration);
    }

  autoLogin() {

    // Here the user is set / emitted as our (new) user.
    this.user.next(user);
    this.autoLogout(expiresIn * 1000);


{
  "rules": {
    ".read": false,
    ".write": false
  }
}

{
  "rules": {
    ".read": "auth != null",  // 2022-4-20
    ".write": "auth != null",  // 2022-4-20
  }
}


307. Adding an Auth Guard.

Todo:
- Reread about Angual Guard.

Angular guard
Angular route guards are interfaces provided by angular which when implemented allow us to control the accessibility of a route based on condition provided in class implementation of that interface. 
Five types of route guards are provided by angular : CanActivate.

https://angular.io/api/router/CanActivate

Interface that a class can implement to be a guard deciding if a route can be activated. 
If all guards return true, navigation continues. 
If any guard returns false, navigation is cancelled. 
If any guard returns a UrlTree, the current navigation is cancelled and a new navigation begins to the UrlTree returned from the guard.

UrlTree:

Using the UrlTree is only relevant if we have multiple guards applied to the same path.

In this case, when navigating "manually" by router.navigate() to different urls from inside these guards, it is not clear which guard wins in a specific situation.

With UrlTree we have a clearly defined hierarchy of guards.

See https://medium.com/angular-in-depth/new-in-angular-v7-1-updates-to-the-router-fd67d526ad05:

"Prior to this change, when multiple guards were executed during navigation, it was possible for each of them to start a navigation by calling navigateByUrl. In such scenarios, it was unclear as to which guard’s navigation should win.

With this change, the guard with the highest priority that returns a UrlTree will cancel the current navigation, and a redirect will be made to the URL represented by the returned UrlTree."

Jost



auth.guard.ts:

/**
 * 307. Adding an Auth Guard.
 * This implementation of CanActivate ensures that when not logged in every route will be redirected to '/auth'.
 * So the other routes will be protected against non-authenticated access.
 * So it is only possible to login and not to reach other urls defined in app-routing.module.ts.
 * This Guard is declared in app-routing.module.ts.
 * 
 */
@Injectable({
    providedIn: 'root'
})
export class AuthGuard implements CanActivate {

    constructor(
        private authService: AuthService,
        private router: Router) {}
    
    canActivate(
        route: ActivatedRouteSnapshot, 
        state: RouterStateSnapshot
        ): 
        boolean | 
        UrlTree | 
        Observable<boolean | UrlTree> | 
        Promise<boolean | UrlTree> {

        return this.authService.user.pipe(
            // We want to look only at the latest instance of the User.
            // Listen to this instance only once. Therefore we don't have an ongoing listener.
            take(1),
            map(user => {
                const isAuth = !!user;
                if (isAuth) {
                    return true;
                }
                // If no user is present, i.e. we are logged out, all urls should be redirected to the login url.
                return this.router.createUrlTree(['/auth']);
            })
        );
    }
}

app-routing.module.ts:

const appRoutes: Routes = [
    // { path: '', component: HeaderComponent},
    { path: '', redirectTo: '/recipes', pathMatch: 'full'},
    { path: 
        'recipes', 
        component: RecipesComponent,
        canActivate: [AuthGuard],
        // Angular will run the Resolvers before loading the actual content.
        children: [
            { path: '', component: RecipeStartComponent},
            { path: 'new', component: RecipeEditComponent },
            { path: ':id', component: RecipeDetailComponent, resolve: [RecipesResolverService] },
            { path: ':id/edit', component: RecipeEditComponent, resolve: [RecipesResolverService] }
        ]
    },
    { path: 'shopping-list', component: ShoppingListComponent},
    { path: 'auth', component: AuthComponent}
];


308. Wrap Up.


309. Useful Resources & Links
Useful Docs:

Firebase Auth REST API Docs: https://firebase.google.com/docs/reference/rest/auth

More on JWT: https://jwt.io


===================================================================================================
2022-04-03:

Section 21: Dynamic Components.

310. Module Introduction.

Dynamic Components are components that are created at runtime.

- e.g.:
  - An overlay over the entire screen.
  - An error popup
  - etc.

311. Adding an Alert Modal Component.

shared
  alert
    alert.component.css

.backdrop {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.75);
    z-index: 50;
}

.alert-box {
    position: fixed;
    top: 30vh;
    left: 20vw;
    width: 60vw;
    padding: 16px;
    z-index: 100;
    background: white;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.26);
}
.alert-box-actions{
    text-align: right;
}

    alert.component.ts

@Component({
    selector: 'app-alert',
    templateUrl: './alert.component.html',
    styleUrls: ['./alert.component.css']
})
export class AlertComponent {
    // @Input() because it needs to be set from outside.
    @Input() message: string;
}

    alert.component.html:

<div class="backdrop"></div>
<div class="alert-box">
    <p> {{ message }}</p>
    <div class="alert-box-actions">
        <button class="btn btn-primary">Close</button>
    </div>
</div>


app.module.ts:

    LoadingSpinnerComponent,
    AlertComponent
  ],

auth.component:
- html

    <div class="col-xs-12 col-md-6 col-md-offset-3">
        <!-- <div class="alert alert-danger" *ngIf="error">
            <p>{{ error }}</p>
        </div> -->
        <app-alert [message]="error" *ngIf="error"></app-alert>

- ts:

  error: string = null;


312. Understanding the Different Approaches.

What are Dynamic Component?
- Should only be visible if necessary.
  - Typically: Loaded Programmatically
    - *ngIf
      - Component embedded via the selector (declaratively)
      - *ngIf controls whether the component is added to the DOM.
  - Aternatively: Dynamic Component Loader
    - Deprecated
    - Component created and added to the DOM via code (imperatively).
      - So this is what is handled programmatically via *ngIf.
    - Component is managed & added by the developer.


313. Using ngIf.

alert.component:
- ts:

/**
 * 311. Adding an Alert Modal Component.
 * 313. Using ngIf.
 */
@Component({
    selector: 'app-alert',
    templateUrl: './alert.component.html',
    styleUrls: ['./alert.component.css']
})
export class AlertComponent {
    // @Input() because it needs to be set from outside. 
    // In this case 
    // - auth.compoonent.ts: error declared and receiving a value.
    // - auth.component.html: uses the <app-alert> and here the property 'error' is used as input for the component.
    // Will contain a message shown via this alert.
    @Input() message: string;
    // @Output() because it needs to be listenable from the outside.
    // Data can be transmitted in this way but now it only needs to send that the alert needs to be closed.
    @Output() close = new EventEmitter<void>();

    onClose() {
        this.close.emit();
    }
}

- html:

<div class="backdrop" (click)="onClose()"></div>
<div class="alert-box">
    <p> {{ message }}</p>
    <div class="alert-box-actions">
        <button class="btn btn-primary" (click)="onClose()">Close</button>
    </div>
</div>

auth.component:
- html:

        <!--
            311. Adding an Alert Modal Component.
            313. Using ngIf.  
            An alert component will show an error and can be closed via a button.
            The alert message can be handed over via property binding.
        -->
        <app-alert [message]="error" *ngIf="error" (close)="onHandleError()"></app-alert>

- ts:

  /**
   * 313. Using ngIf.
   * Setting error = null means that the error message (via the popup) will disappear.
   * (because of *ngIf in auth.component.html in <app-alert>).
   */
  onHandleError() {
    this.error = null;
  }

The setup implemented in § 311, 313 is the recommended method to handle incorrect input.
- An alert-component is setup.
- It will receive the necessary input: the error message.
- It will be directed via *ngIf and close() methods.

In the logging the following can be seen when clicking on alert-component.html 'Close' button:

- alert.component.ts:24 AlertComponent.onClose: emitting
  -> The component is closed.
- auth.component.ts:83 AuthComponent.onHandleError: setting this.error = null
  -> The this.error, containing the error message coming from the Firebase DB, is set to null.
      This means the *ngIf="error" in auth.component.html will be false and therefore the
      decorator <app-alert> will become invisible.
      Nu the correct username / password can be filled in.



In the following a deprecated method will be shown.

314. Preparing Programmatic Creation.

Using:
- ComponentFactoryResolver.

315. Creating a Component Programmatically.

Using:
- ng-Template.


316. Understanding entryComponents.


317. Data Binding & Event Binding.


318. Wrap Up.

319. Useful Resources & Links.

Official Docs: https://angular.io/guide/dynamic-component-loader


===================================================================================================
2022-03-05:

Section 22: Angular Modules & Optimizing Angular Apps.

320. Module Introduction.

321. What are Modules?

Modules are ways of bundling Angular building blocks:
- AppModule
  - Components
  - Directives
  - Service
  - Pipes

Angular needs to be informed what code is present and this needs to be bundled in modules.
Every Angular app needs to have at least one module: the AppModule.

- Angular analyzes NgModules to understand the application and it's features.
- Angular modules define all building blocks the app uses: Components, Directives, Services.
- An app requires at least one module (AppModule) but may be split into multiple modules.
- Core Angular features are included in Angular modules (e.g. FormsModule) to load them only when needed.
- You can't use a feature / building block without including it in a module.

322. Analyzing the AppModule.

An @NgModule decorator is present in at least:
- app.module.ts
- app-routing.module.ts

Services are provided by:
- Adding them to 'providers' in app.module.ts or
- Adding the following decorator:

@Injectable({
  providedIn: 'root'
})

This ensures that the service will be available application-wide. This is the preferred methhod of providing a service.

bootstrap: [AppComponent]

Indicates which Component will be available from the start.

index.html:

Typically here only one component will be used.

<body>
  <app-root></app-root>
</body>

It is possible to have multiple components / decorators in index.html which is the reason why boostrap in app.module is an array.
However each component would then be detached from the other components.
So there would be multiple root-component trees in your application. Which is rarely what is wanted.


  entryComponents: [
    AlertComponent
  ]

This informs Angular to be aware of the component(s) when it needs to be created (See Section 21: Dynamic components; because it's generally out of date I did not implement this)

AppRoutingModule:
- Exists to hold our configuration.
- It will keep the AppModule leaner and more focussed.
  - This is in general the reason to create more modules.
    (Think of it as a library)


@NgModule({
    imports: [RouterModule.forRoot(appRoutes)],
    exports: [RouterModule]
  })


Every module works on it's own. They do not communicate with each other.
Therefore we need to export in this case RouterModule so that it is available in AppModule.

When we import a module we import everything a module is exporting.

The larger the application becomes the more you would like to split the code.
In this way you will have leaner modules that are easier to understand and also in order to enhance performance. 
Not because splitting components will enhance performance, but this will be an important step to enhance the performance.


323. Getting Started with Feature Modules.


Instead of having one module (AppModule) we could split that module into multiple modules.

AppModule
  - AppComponent
  - ProductListComponent
  - ProductComponent
  - OrdersComponent
  - HighlightDirective

--> 
AppModule
  - AppComponent

ProductsModule
  - ProductListComponent
  - ProductComponent

OrdersModule
  - OrdersComponent
  - HighlightDirective

ProductsModule and OrdersModule are called Feature Modules.

Looking at our course project:
- We have  three main features:
  - cecipes
  - shopping-list
  - auth

The header content belongs to the AppComponent.
The shared content is used wherever appropriate. So will be shared across different features.


$ ng new shopping-app-modules --routing --no-strict

How to install:

$ cd /Users/rkremers/Development/workspaceJS/Angular/shopping-app-modules
$ npm install --save bootstrap@3

Now make Angular aware of this styling package.
- angular.json file.

            "styles": [
              "node_modules/bootstrap/dist/css/bootstrap.min.css", !! bootstrap.min.css has been added here.
              "src/styles.css"
            ],

Template Driven: Add FormsModule to app.module.ts
Reactive Forms Driven: Add ReactiveFormsModule to app.module.ts
(sometimes it can be handy to use both).

$ npm install --save rxjs-compat

Go to the root directory of the application:
$ ng serve --port 4204

--> look at http://localhost:4204/


324. Splitting Modules Correctly.


recipes.module.ts:

@NgModule({
    declarations: [
        RecipesComponent,
        RecipeListComponent,
        RecipeDetailComponent,
        RecipeItemComponent,
        RecipeStartComponent,
        RecipeEditComponent    
    ],
    imports: [
        CommonModule,
        ReactiveFormsModule,
        RouterModule
    ]
})
export class RecipesModule {

}

app.module.ts:

@NgModule({
  declarations: [
    AppComponent,
    HeaderComponent,
    ShoppingListComponent,
    ShoppingEditComponent,
    DropdownDirective,
    AuthComponent,
    LoadingSpinnerComponent,
    AlertComponent
  ],
  /**
   * 324. Splitting Modules Correctly.
   * The BrowserModule can only be imported once. 
   * This is a special module because it also has some startup features.
   * In all other modules use the CommonModule.
   */
  imports: [
    BrowserModule,
    FormsModule,
    ReactiveFormsModule,
    HttpClientModule,
    AppRoutingModule,
    RecipesModule
  ],
  /**
   * 324. Splitting Modules Correctly.
   * Services need to be imported once and after that will be available for all modules.
   * So also for the RecipesModule.
   */
  providers: [
    ShoppingListService, 
    RecipeService, 
    /**
     * 303. Attaching the token with an interceptor.
     * Set multi: true to allow for multiple interceptors, even if at the moment only one is used.
     */
    {
      provide: HTTP_INTERCEPTORS, 
      useClass: AuthInterceptorService, 
      multi: true
    }
  ],
  bootstrap: [AppComponent],
  entryComponents: [
    AlertComponent
  ]
})
export class AppModule { }


325. Adding Routes to Feature Modules.


Note:

After this the button 'Manage Recipe' in recipe-detail.component.html does not function anymore.

Explanation:

  Jost — Teaching Assistant
  1 upvote
  1 year ago


  During the many iterations in these lectures it may always be that something doesn't fully work in an intermediate state, and has to be fixed later.

  To make the dropdown work in the recipe module as well, it would be required to add it to the recipe module's declarations array.

  The problem is that you can declare a component, directive or pipe only once in your app.

  Thus this second dropdown can't work in this intermediate state, and it doesn't work in the related zip either.

  This problem will be solved later by implementing a shared module where such things can be declared and which then can be imported in multiple other modules without causing errors:

  https://www.udemy.com/course/the-complete-guide-to-angular-2/learn/lecture/14466500


recipes-routing.module.ts:

/**
 * 325. Adding Routes to Feature Modules.
 */
const routes: Routes = [
    { path: 
        'recipes', 
        component: RecipesComponent,
        /**
         * 307. Adding an Auth Guard.
         * This implementation of CanActivate ensures that when not logged in every route will be redirected to '/auth'.
         */
        canActivate: [AuthGuard],
        // Angular will run the Resolvers before loading the actual content.
        children: [
            { path: '', component: RecipeStartComponent},
            { path: 'new', component: RecipeEditComponent },
            { path: ':id', component: RecipeDetailComponent, resolve: [RecipesResolverService] },
            { path: ':id/edit', component: RecipeEditComponent, resolve: [RecipesResolverService] }
        ]
    },

];

recipes.module.ts:

@NgModule({
    declarations: [
        RecipesComponent,
        RecipeListComponent,
        RecipeDetailComponent,
        RecipeItemComponent,
        RecipeStartComponent,
        RecipeEditComponent    
    ],
    imports: [
        CommonModule,
        ReactiveFormsModule,
        RouterModule,
        RecipesRoutingModule
    ],
    exports: [
        RecipesComponent,
        RecipeListComponent,
        RecipeDetailComponent,
        RecipeItemComponent,
        RecipeStartComponent,
        RecipeEditComponent 
    ]
})
export class RecipesModule {

}

app-routing.module.ts:

const appRoutes: Routes = [
    { path: '', redirectTo: '/recipes', pathMatch: 'full'},
    { path: 'shopping-list', component: ShoppingListComponent},
    { path: 'auth', component: AuthComponent}
];

@NgModule({
    imports: [RouterModule.forRoot(appRoutes)],
    exports: [RouterModule]
  })
  export class AppRoutingModule { }


326. Component Declarations.

Currently RecipesComponents is declared in both recipes.module.ts and in recipes-routing.module.ts:

@NgModule({
    declarations: [
        RecipesComponent,
..

const routes: Routes = [
    { path: 
        'recipes', 
        component: RecipesComponent,
...

Now that we define in recipe-routing.modules which components should be used and this is imported in recipes.module.ts
it is no longer necessary to export these components in recipes.module.ts.
Because we are only using them internally in the recipes module.

Now:

recipes.routing.module.ts:

As above

recipes.module.ts:

@NgModule({
    declarations: [
        RecipesComponent,
        RecipeListComponent,
        RecipeDetailComponent,
        RecipeItemComponent,
        RecipeStartComponent,
        RecipeEditComponent    
    ],
    imports: [
        RouterModule,
        CommonModule,
        ReactiveFormsModule,
        RecipesRoutingModule
    ]
})
export class RecipesModule {

}


Notes regarding Routing Module:

  Jost — Teaching Assistant
  2 upvotes
  1 year ago


  Hi!

  The usage of RouterModule is rather complex, since this module has several tasks.

  In RouterModule several directives are declared, which are needed in multiple components in connection with routing (like RouterOutlet, RouterLink, RouterLinkActive etc.).

  Additionally RouterModule should provide the services which manage the different routes arrays of the feature modules. And last but not least: RouterModule should provide an instance of the Router service itself.

  ● The problem

  This dual role, declaring directives and providing services, - actually nothing special for a module - causes a problem in the case of RouterModule:

  1. We know that a directive (like a component) can be declared only once in an app, in the declarations array of one particular module, not more often. That means we have to import RouterModule in multiple modules of our app, in order to make the routing directives mentioned above available in all places where they are needed.

  2. But this could involve the risk of getting multiple instances of the services, if those would be provided in the usual manner in a providers array directly in the @NgModule annotation of RouterModule.

  And this should not happen: It’s clear that the services which are responsible for the routes arrays of the different feature modules, as well as the Router instance itself, have to be singletons.

  ● The solution:

  The basic version of the RouterModule contains only the directives mentioned above which are needed for routing in the components. Nothing more. This simple version of RouterModule can be imported in as many modules as required without any risk.

  If you call RouterModule.forChild(myChildRoutes) in a feature module, this method returns an enhanced RouterModule, which contains not only these directives, but additionally the services which are required for handling myChildRoutes.

  You will import this modified version only once in the routing module of that feature module. And important: The original RouterModule will not be modified; you will export the unmodified RouterModule version from the routing module, which then can be used in the related feature module for accessing the directives in multiple places.

  And RouterModule.forRoot(myRootRoutes) acts similarly. This method returns an enhanced version of RouterModule as well (again without modifying the original RouterModule), containing the directives, the providers for myRootRoutes, and in this case also the provider for the Router instance itself.

  This version of the RouterModule should only be imported once in your app (in app-routing.module.ts), and you will get an error, if you try to use it in a lazy loaded module (since then you would get a new instance of the Router, and that has to be avoided under any circumstances). And of course you will export the unmodified RouterModule version from app-routing.module.ts for the import and further usage in app.module.ts.

  Here an overview of the different RouterModule versions and their content:

  RouterModule             directives     -----                            -----
   (unmodified version)
  RouterModule             directives     providers for myChildRoutes1     -----
   .forChild(myChildRoutes1)
  RouterModule             directives     providers for myChildRoutes2     -----
   .forChild(myChildRoutes2)
  RouterModule             directives     providers for myRootRoutes       Router
   .forRoot(myRootRoutes, myOptions)
  Note: In the table can be seen that RouterModule.forRoot() has an optional second parameter, an object, where e.g. a preloading strategy could be defined.

  Jost



327. The ShoppingList Feature Module.


shopping-list-routing.module.ts:

  const routes: Routes = [
      { path: 'shopping-list', component: ShoppingListComponent}
  ]
  @NgModule({
      imports: [RouterModule.forChild(routes)],
      exports: [RouterModule]
  })
  export class ShoppingListRoutingModule {}

shopping-list.module.ts:

  @NgModule({
      declarations: [
          ShoppingListComponent,
          ShoppingEditComponent    
      ],
      imports: [
          BrowserModule,
          CommonModule,
          FormsModule,
          ReactiveFormsModule,
          ShoppingListRoutingModule
      ]
  })
  export class ShoppingListModule {

  }

app-routing.module.ts:

  const appRoutes: Routes = [
      { path: '', redirectTo: '/recipes', pathMatch: 'full'},
      { path: 'auth', component: AuthComponent}
  ];

  @NgModule({
      imports: [RouterModule.forRoot(appRoutes)],
      exports: [RouterModule]
    })
  export class AppRoutingModule { }


app.module.ts:

  @NgModule({
    declarations: [
      AppComponent,
      HeaderComponent,
      DropdownDirective,
      AuthComponent,
      LoadingSpinnerComponent,
      AlertComponent
    ],
    /**
     * 324. Splitting Modules Correctly.
     * The BrowserModule can only be imported once. 
     * This is a special module because it also has some startup features.
     * In all other modules use the CommonModule.
     */
    imports: [
      BrowserModule,
      FormsModule,
      ReactiveFormsModule,
      HttpClientModule,
      RecipesModule,
      ShoppingListModule,
      /**
       * AppRoutingModule should always be added at the end of the imports in order
       * to prevent import inconsistencies.
       */
      AppRoutingModule
    ],
    /**
     * 324. Splitting Modules Correctly.
     * Services need to be imported once and after that will be available for all modules.
     * So also for the RecipesModule.
     */
    providers: [
      ShoppingListService, 
      RecipeService, 
      /**
       * 303. Attaching the token with an interceptor.
       * Set multi: true to allow for multiple interceptors, even if at the moment only one is used.
       */
      {
        provide: HTTP_INTERCEPTORS, 
        useClass: AuthInterceptorService, 
        multi: true
      }
    ],
    bootstrap: [AppComponent],
    entryComponents: [
      AlertComponent
    ]
  })
  export class AppModule { }


328. Understanding Shared Modules.


Shared Modules:
- ProductsModule
  - ModalComponent
  - DropdownDirective
  - FormsModule
  - ProductsComponent
- SalesModule
  - ModalComponent
  - DropdownDirective
  - FormsModule
  - SalesComponent

Shared Modules are modules that are shared across multiple other modules:
These shared modules can be placed under a separate Module that will be imported in the other modules.
This avoids code duplication and provides for a leaner model.


Note:
Modules can be declared only once.
Multiple declarations of the same module are not allowed and will lead to errors.

Missing:

description: "A juicy pizza! (Without ingredients to test that situation)"
imagePath: "https://wallpaperaccess.com/full/767048.jpg"
name: "Pizza"

Okay: has returned now.
I think the delete button may not function correctly anymore.


329. Understanding the Core Module.

AppModule
- AppComponent
- ProductsService
- AnalyticsService

-->
AppModule
- AppComponent

CoreModule
- ProductsService
- AnalyticsService


All modules are created in the same way, with @NgModule.

In our case: 
- app.module.ts:

The services:

  /**
   * 324. Splitting Modules Correctly.
   * Services need to be imported once and after that will be available for all modules.
   * So also for the RecipesModule.
   */
  providers: [
    ShoppingListService, 
    RecipeService, 
    /**
     * 303. Attaching the token with an interceptor.
     * Set multi: true to allow for multiple interceptors, even if at the moment only one is used.
     */
    {
      provide: HTTP_INTERCEPTORS, 
      useClass: AuthInterceptorService, 
      multi: true
    }
  ],

could be provided via a CoreModule in order to keep the application leaner.

The preferred way to handle services is to use:

@Injectable({
  providedIn: 'root'
})

The services will be available application wide and the effect is the same, keeping the application leaner.


core.module.ts:

  @NgModule({
  /**
   * 324. Splitting Modules Correctly.
   * Services need to be imported once and after that will be available for all modules.
   * So also for the RecipesModule.
   * 
   * 329. Understanding the Core Module.
   * 
   * Services do not need to be exported. This is only necessary for modules.
   */
      providers: [
          ShoppingListService,
          RecipeService,
          /**
           * 303. Attaching the token with an interceptor.
           * Set multi: true to allow for multiple interceptors, even if at the moment only one is used.
           */
          {
              provide: HTTP_INTERCEPTORS,
              useClass: AuthInterceptorService,
              multi: true
          }
      ],
  })
  export class CoreModule { }

app.module.ts:

  @NgModule({
    declarations: [
      AppComponent, 
      HeaderComponent, 
      AuthComponent
    ],
    /**
     * 324. Splitting Modules Correctly.
     * The BrowserModule can only be imported once. 
     * This is a special module because it also has some startup features.
     * In all other modules use the CommonModule.
     */
    imports: [
      BrowserModule,
      FormsModule,
      ReactiveFormsModule,
      HttpClientModule,
      RecipesModule,
      ShoppingListModule,
      SharedModule,
      CoreModule,
      /**
       * AppRoutingModule should always be added at the end of the imports in order
       * to prevent import inconsistencies.
       */
      AppRoutingModule
    ],
    bootstrap: [AppComponent]
  })
  export class AppModule { }


330. Adding an Auth Feature Module.

auth.module.ts:

/**
 * 330. Adding an Auth Feature Module.
 * It is possible to create a separate auth-routing.module.ts and declare that in RouterModule.forChild([]).
 * However it is also possible to declare the path for AuthComponent directly in the auth.module.ts file 
 * as is done here.
 * 
 * The SharedModule module is imported here AND in the app.module.ts.
 * Reason:
 * We need the LoadingSpinnerComponent. This component is declared in the SharedModule.
 * We can not declare a Component twice so we need to import the SharedModule. 
 */
@NgModule({
    declarations: [
        AuthComponent
    ],
    imports: [
        CommonModule,
        FormsModule,
        RouterModule.forChild([
            { path: 'auth', component: AuthComponent }
        ]),
        SharedModule
    ]
})
export class AuthModule {}


app.module.ts:

@NgModule({
  declarations: [
    AppComponent, 
    HeaderComponent
  ],
  /**
   * 324. Splitting Modules Correctly.
   * The BrowserModule can only be imported once. 
   * This is a special module because it also has some startup features.
   * In all other modules use the CommonModule.
   * 
   * 330. Adding an Auth Feature Module.
   */
  imports: [
    BrowserModule,
    ReactiveFormsModule,
    HttpClientModule,
    AuthModule,
    RecipesModule,
    ShoppingListModule,
    SharedModule,
    CoreModule,
    /**
     * AppRoutingModule should always be added at the end of the imports in order
     * to prevent import inconsistencies.
     */
    AppRoutingModule
  ],
  bootstrap: [AppComponent]
})
export class AppModule { }


331. Understanding Lazy Loading.

Lazy Loading:
- Only load modules that are actually needed.


332. Implementing Lazy Loading.

Until now when looking at Development Tool | Network:
- A number of files is visible that are quite large
  - e.g. vendor.js: 2.5 MB.
  - In order to see this correctly:
    - Development Tool | Network: click 'Disable cache'. 

How do we add Lazy Loading:
When we start with the application we only need the Auth module. We can't even access the other modules.
We can access the Shopping List but there is no need to download anything.

recipes-routing.module.ts:

Take away:

    { path: 
        'recipes', 

--> 
    { path: 
        '', 

And add this to the app-routing.module.ts:

const appRoutes: Routes = [
    { path: '', redirectTo: '/recipes', pathMatch: 'full'},
    { path: 'recipes'}
];


Error:

Type 'string' is not assignable to type 'LoadChildrenCallback'


https://stackoverflow.com/questions/70313032/type-string-is-not-assignable-to-type-loadchildrencallback

For dynamic imports you'll need to update this

{ path: 'Supplier', loadChildren: '../Supplier/CustomerApp.SupplierModule#CustomerAppSupplierModule' },

To this:

{ 
   path: 'Supplier',
   loadChildren: () => import('../Supplier/CustomerApp.SupplierModule').then(x => x.CustomerAppSupplierModule)
},

Also double check that in your tsconfig.json you have this line "module": "esnext"

{
...
"compilerOptions": {
    ...
    "module": "esnext"
    ...
    }
}


Also:
- https://angular.io/guide/lazy-loading-ngmodules#lazy-loading-basics

- https://www.typescriptlang.org/tsconfig#module

    // "module": "es2020",
    "module": "esnext",


ESNext
import { valueOfPi } from "./constants";
export const twoPi = valueOfPi * 2;
 
Try
ES2020
import { valueOfPi } from "./constants";
export const twoPi = valueOfPi * 2;


After adding Lazy Loading it is necessary to restart the application.

Once Lazy Loading is installed the RecipesModule should not be imported anymore in app.module.ts.
If this is forgotten the application will not work properly anymore.

After logging in you will be redirected to /recipes.
Now the RecipesModule will be loaded.
This is visible in Developer Tool | Network where after loading src_app_recipes_recipes_module_ts.js is loaded. This module is much smaller.
Everything regarding recipes (like jpeg's) is now loaded as necessary.
Lazy Loading should be used if a module is not loaded immediately and / or not that often. Otherwise it's of no use.


333. More Lazy Loading.

Now the ShoppingList and Auth will be Lazy Loaded.

You will see in Developer Tool | Network that now only content is loaded when actually required.

app-routing.module.ts:

  const appRoutes: Routes = [
    { path: '', redirectTo: '/recipes', pathMatch: 'full' },
    /**
     * 332. Implementing Lazy Loading.
     * 
     * Meaning of 'loadChildren':
     * Only load the code when someons wants to visit this path.
     * When creating the RecipesModule the Angular naming convention is followed. 
     * But this is not enforced. Therefore we have to tell Angular what the name of the Module class is.
     * 
     * Angular 13: 
     * - https://angular.io/guide/lazy-loading-ngmodules#lazy-loading-basics
     * 
     * After logging in you will be redirected to /recipes.
     * Now the RecipesModule will be loaded.
     * Because of 'loadChildren' it will only be loaded at that point, not sooner.
     * This is visible in Developer Tool | Network where after loading src_app_recipes_recipes_module_ts.js is loaded. This module is much smaller.
     * Everything regarding recipes (like jpeg's) is now loaded as necessary.
     * Lazy Loading should be used if a module is not loaded immediately and / or not that often. Otherwise it's of no use.
     * After implementing Lazy Loading the application needs to be reloaded.
     * 
     * The next path is an old version. Does not work anymore in Angular 13.
     * { path: 'recipes', loadChildren: './recipes/recipes.module#RecipesModule'},
     * 
     * Note: here 'import' is a promise. Hence the possible use of 'next()'.
     */
    {
      path: 'recipes',
      loadChildren: () => import('./recipes/recipes.module').then(m => m.RecipesModule)
    },
    {
      path: 'shopping-list',
      loadChildren: () => import('./shopping-list/shopping-list.module').then(m => m.ShoppingListModule)
    },
    {
      path: 'auth',
      loadChildren: () => import('./auth/auth.module').then(m => m.AuthModule)
    }
  ];

  @NgModule({
    imports: [RouterModule.forRoot(appRoutes)],
    exports: [RouterModule]
  })
  export class AppRoutingModule { }


app.module.ts:

  @NgModule({
    declarations: [
      AppComponent, 
      HeaderComponent
    ],
    /**
     * 324. Splitting Modules Correctly.
     * The BrowserModule can only be imported once. 
     * This is a special module because it also has some startup features.
     * In all other modules use the CommonModule.
     * 
     * 330. Adding an Auth Feature Module.
     * 332. Implementing Lazy Loading.
     * Once Lazy Loading is installed the RecipesModule should not be imported anymore in app.module.ts.
     * If this is forgotten the application will not work properly anymore.
     * 
     */
    imports: [
      BrowserModule,
      ReactiveFormsModule,
      HttpClientModule,
      // AuthModule, // Is Lazyloaded.
      // RecipesModule, // Is Lazyloaded.
      // ShoppingListModule, // Is Lazyloaded.
      SharedModule,
      CoreModule,
      /**
       * AppRoutingModule should always be added at the end of the imports in order
       * to prevent import inconsistencies.
       */
      AppRoutingModule
    ],
    bootstrap: [AppComponent]
  })
  export class AppModule { }

shopping-list.routing.module.ts:

  /**
   * 333. More Lazy Loading.
   * The path will now be used in app-routing.module.ts for Lazy Loading
   */
  const routes: Routes = [
      // { path: 'shopping-list', component: ShoppingListComponent} // Original path before Lazy Loading.
      {path: '', component: ShoppingListComponent}
  ]
  @NgModule({
      imports: [RouterModule.forChild(routes)],
      exports: [RouterModule]
  })
  export class ShoppingListRoutingModule {}

auth.module.ts:

  @NgModule({
      declarations: [
          AuthComponent
      ],
      imports: [
          CommonModule,
          FormsModule,
          RouterModule.forChild([
              { path: '', component: AuthComponent }
          ]),
          SharedModule
      ]
  })
  export class AuthModule {}

(no auth-routing.module.ts exists because the path is declared in auth.module.ts to show alternative method)

recipes-routing.module.ts:

  /**
   * 325. Adding Routes to Feature Modules.
   */
  const routes: Routes = [
      {
          path:
          // This should be the first path, because we start at /recipes.
              '',
          component: RecipesComponent,
          /**
           * 307. Adding an Auth Guard.
           * This implementation of CanActivate ensures that when not logged in every route will be redirected to '/auth'.
           */
          canActivate: [AuthGuard],
          // Angular will run the Resolvers before loading the actual content.
          children: [
              { path: '', component: RecipeStartComponent },
              { path: 'new', component: RecipeEditComponent },
              { path: ':id', component: RecipeDetailComponent, resolve: [RecipesResolverService] },
              { path: ':id/edit', component: RecipeEditComponent, resolve: [RecipesResolverService] }
          ]
      },

  ];

  @NgModule({
      imports: [RouterModule.forChild(routes)],
      exports: [RouterModule]
  })
  export class RecipesRoutingModule { }


334.Preloading Lazy-Loaded Code.


Currently, with Lazy Loading installed, code is installed when needed. 
This might cause a slight delay.
This could become a problem with large applications.
So some Lazy Loaded modules could be pre-loaded.

app-routing.modules.ts:

/**
 * 334.Preloading Lazy-Loaded Code.
 * With {preloadingStrategy: PreloadAllModules} Angular is informed:
 * - Lazy Loading is being used.
 * - Load modules as soon as possible.
 *  - When the application is idle the modules can already be loaded so when actually needed the application will react faster.
 */
@NgModule({
  imports: [RouterModule.forRoot(appRoutes, {preloadingStrategy: PreloadAllModules})],
  exports: [RouterModule]
})


335. Modules & Services.


Modules                               Services                                                  Method of injecting             Comment:

AppModule                             Service available app-wide; singleton                     Use root injector               should be the default
AppComponent (or other Components)    Service available in component-tree; singleton app-wide   Use component-specific injector If service is only relevant for component tree
Eager-loaded Module                   Service available app-wide; singleton app-wide            Use root injector               Avoid this.
Lazy-loaded Module                    Service available in loaded module; singleton             Use child injector              Use if service should be scoped
                                      If the service is provided both in the lazy-loaded module                                 to loaded module
                                      and in the app.module
                                      the lazy-loaded module will have a separate instance.

As a rule:
- Services should be available application-wide.
- Moderne methode:

Use decorator:
@Injectable({
  providedIn: 'root'
})

- Andere methode:
  - Declare in app.module.ts in @NgModule.

An eagerly loaded module is a module that has been imported into the AppModule, e.g. like CoreModule.


336. Loading Services Differently.

Creation of a dummy service: LoggingService.

$ ng generate service logging --skip-tests
CREATE src/app/logging.service.ts (136 bytes)

logging.service.ts:

/**
 * 336. Loading Services Differently.
 * 
 * Creation of a dummy service: LoggingService.
 * The @Injectable below ensures that the service is available throughout the application.
 * 
 */
@Injectable({
  providedIn: 'root'
})
export class LoggingService {
  private lastlog: string;

  constructor() { }

  printlog(message: string): void {
    console.log(message);
    console.log(this.lastlog);
    this.lastlog = message;
  }
}


@Injectable({
  providedIn: 'root'
})

has the same effect as:

app.module.ts:

@NgModule({
  declarations: [
    AppComponent, 
    HeaderComponent
  ],
  /**
   * 324. Splitting Modules Correctly.
   * The BrowserModule can only be imported once. 
   * This is a special module because it also has some startup features.
   * In all other modules use the CommonModule.
   * 
   * 330. Adding an Auth Feature Module.
   * 332. Implementing Lazy Loading.
   * Once Lazy Loading is installed the RecipesModule should not be imported anymore in app.module.ts.
   * If this is forgotten the application will not work properly anymore.
   * 
   */
  imports: [
    BrowserModule,
    ReactiveFormsModule,
    HttpClientModule,
    // AuthModule, // Is Lazyloaded.
    // RecipesModule, // Is Lazyloaded.
    // ShoppingListModule, // Is Lazyloaded.
    SharedModule,
    CoreModule,
    /**
     * AppRoutingModule should always be added at the end of the imports in order
     * to prevent import inconsistencies.
     */
    AppRoutingModule
  ],
  bootstrap: [AppComponent],
  providers: [LoggingService] !!!! Now the LoggingService is provided, like with @Injectable({ providedIn: 'root'}), throughout the application.
})

If provided in the CoreModule:
- Again one instance that is available throughout the application.

If provided in the AppModule as above (Eagerly Loaded) AND provided in the ShoppingListModule (not eagerly loaded, but Lazy Loaded).
- Now we have two different instances of the LoggingService. As described in § 335.
- One should be very careful to create two instances of a module since it can lead to strange, unexpected behaviour.

This is also the case if provided in a module that itself is called not in the AppModule but in a different module.

e.g.:
Provide the LoggingService in the SharedModule. This module is itself imported in the AppModule and therefore an eagerly loaded module.
But SharedModule is also imported into the ShoppingListModule.
Here SharedModule is eagerly loaded but the ShoppingListModule is lazy loaded.
--> 2 instances of LoggingService.

So if you import a module in the AppModule and / or in an Eagerly Loaded module, but also in a Lazily Loaded Module, a second instance of the module will be created.


337. Ahead-of-Time Compilation.

Resources:
- https://angular.io/cli/build

  $ ng build --prod is now deprecated. Use "--configuration production" instead.
    Option "--prod" is deprecated: No need to use this option as this builder defaults to configuration "production".

Ahead-of-Time (AoT) vs Just-in-Time (JiT) Compilation.

Some additional info:

Below are the bundles which you might get by running ng serve. After running ng build --prod - which optimizes the bundle size - you will get a combined bundle, 
like Max explained above.

● runtime.js (always very small) is an internal webpack loader.
● main.js contains your own app code.
● polyfills.js contains the polyfills for legacy browsers etc.
● scripts.js contains the scripts you configured in the scripts section of your angular.json (if so)
● styles.js contains the styles you configured in the styles section of your angular.json (if so)
● vendor.js contains the npm modules you are referencing in your app.

The bundles with module names contain the lazy loaded modules (see section 22 of this course).

Jost


When we prepare the code for production we want to optimize it and put it in a bundle as small as possible.
- quit ng serve --port 4204
- ng build --prod
  - Does not spin up a development server where you can see it but it builds the app into a few files that you can then deploy.
  - This command already uses Ahead of Time compilation.

$ ng build --prod
Option "--prod" is deprecated: No need to use this option as this builder defaults to configuration "production".
✔ Browser application bundle generation complete.
An unhandled exception occurred: Transform failed with 1 error:
error: Invalid version: "15.2-15.3"
See "/private/var/folders/t4/7fbd31bn2gx7547s9lscm9h00000gp/T/ng-hnY3iz/angular-errors.log" for further details.

[error] HookWebpackError: Transform failed with 1 error:
error: Invalid version: "15.2-15.3"
    at makeWebpackError (/Users/rkremers/Development/workspaceJS/Angular/shopping-app-modules/node_modules/webpack/lib/HookWebpackError.js:48:9)
    at /Users/rkremers/Development/workspaceJS/Angular/shopping-app-modules/node_modules/webpack/lib/Compilation.js:3055:12
    at eval (eval at create (/Users/rkremers/Development/workspaceJS/Angular/shopping-app-modules/node_modules/tapable/lib/HookCodeFactory.js:33:10), <anonymous>:98:1)
    at processTicksAndRejections (node:internal/process/task_queues:96:5)
-- inner error --
Error: Transform failed with 1 error:
error: Invalid version: "15.2-15.3"
    at failureErrorWithLog (/Users/rkremers/Development/workspaceJS/Angular/shopping-app-modules/node_modules/esbuild/lib/main.js:1557:15)
    at /Users/rkremers/Development/workspaceJS/Angular/shopping-app-modules/node_modules/esbuild/lib/main.js:1346:29
    at /Users/rkremers/Development/workspaceJS/Angular/shopping-app-modules/node_modules/esbuild/lib/main.js:637:9
    at handleIncomingPacket (/Users/rkremers/Development/workspaceJS/Angular/shopping-app-modules/node_modules/esbuild/lib/main.js:734:9)
    at Socket.readFromStdout (/Users/rkremers/Development/workspaceJS/Angular/shopping-app-modules/node_modules/esbuild/lib/main.js:604:7)
    at Socket.emit (node:events:390:28)
    at addChunk (node:internal/streams/readable:315:12)
    at readableAddChunk (node:internal/streams/readable:289:9)
    at Socket.Readable.push (node:internal/streams/readable:228:10)
    at Pipe.onStreamRead (node:internal/stream_base_commons:199:23)


rkremers@BKWI_C02ZX41RMD6R:~$ node -v
v16.13.1
rkremers@BKWI_C02ZX41RMD6R:~$ npm -v
8.1.2
rkremers@BKWI_C02ZX41RMD6R:~$ npm list -g @angular/cli
/usr/local/lib
└── @angular/cli@13.1.2

$ ng version

     _                      _                 ____ _     ___
    / \   _ __   __ _ _   _| | __ _ _ __     / ___| |   |_ _|
   / △ \ | '_ \ / _` | | | | |/ _` | '__|   | |   | |    | |
  / ___ \| | | | (_| | |_| | | (_| | |      | |___| |___ | |
 /_/   \_\_| |_|\__, |\__,_|_|\__,_|_|       \____|_____|___|
                |___/
    

Angular CLI: 13.1.2
Node: 16.13.1
Package Manager: npm 8.1.2
OS: darwin x64

Angular: 
... 

Package                      Version
------------------------------------------------------
@angular-devkit/architect    0.1301.2 (cli-only)
@angular-devkit/core         13.1.2 (cli-only)
@angular-devkit/schematics   13.1.2 (cli-only)
@schematics/angular          13.1.2 (cli-only)


$ npx browserslist
chrome 100
edge 99
edge 98
firefox 98
firefox 91
ios_saf 15.4
ios_saf 15.2-15.3
ios_saf 15.0-15.1
ios_saf 14.5-14.8
ios_saf 14.0-14.4
safari 15.4
safari 15.2-15.3
safari 15.1
safari 15
safari 14.1
safari 14

https://github.com/angular/angular-cli/issues/22606
- Solution: update to the latest ng version (13.2).

https://stackoverflow.com/questions/43931986/how-to-upgrade-angular-cli-to-the-latest-version

$ npm uninstall -g @angular/cli
$ npm install -g @angular/cli@latest

$ ng version
Your global Angular CLI version (13.3.3) is greater than your local version (13.1.4). The local Angular CLI version is used.

To disable this warning use "ng config -g cli.warnings.versionMismatch false".

     _                      _                 ____ _     ___
    / \   _ __   __ _ _   _| | __ _ _ __     / ___| |   |_ _|
   / △ \ | '_ \ / _` | | | | |/ _` | '__|   | |   | |    | |
  / ___ \| | | | (_| | |_| | | (_| | |      | |___| |___ | |
 /_/   \_\_| |_|\__, |\__,_|_|\__,_|_|       \____|_____|___|
                |___/
    

Angular CLI: 13.1.4
Node: 16.13.1
Package Manager: npm 8.1.2
OS: darwin x64

Angular: 13.1.3
... animations, common, compiler, compiler-cli, core, forms
... platform-browser, platform-browser-dynamic, router

Package                         Version
---------------------------------------------------------
@angular-devkit/architect       0.1301.4
@angular-devkit/build-angular   13.1.4
@angular-devkit/core            13.1.4
@angular-devkit/schematics      13.1.4
@angular/cli                    13.1.4
@schematics/angular             13.1.4
rxjs                            7.4.0
typescript                      4.5.5

If I am not in /Users/rkremers/Development/workspaceJS/Angular/shopping-app-modules

$ ng version

     _                      _                 ____ _     ___
    / \   _ __   __ _ _   _| | __ _ _ __     / ___| |   |_ _|
   / △ \ | '_ \ / _` | | | | |/ _` | '__|   | |   | |    | |
  / ___ \| | | | (_| | |_| | | (_| | |      | |___| |___ | |
 /_/   \_\_| |_|\__, |\__,_|_|\__,_|_|       \____|_____|___|
                |___/
    

Angular CLI: 13.3.3
Node: 16.13.1
Package Manager: npm 8.1.2
OS: darwin x64

Angular: 
... 

Package                      Version
------------------------------------------------------
@angular-devkit/architect    0.1303.3 (cli-only)
@angular-devkit/core         13.3.3 (cli-only)
@angular-devkit/schematics   13.3.3 (cli-only)
@schematics/angular          13.3.3 (cli-only)
    
--> So in order to make the application work again I need to update the local version in /Users/rkremers/Development/workspaceJS/Angular/shopping-app-modules.

/Users/rkremers/Development/workspaceJS/Angular/shopping-app-modules
$ npm install --save-dev @angular/cli@latest

$ ng version

     _                      _                 ____ _     ___
    / \   _ __   __ _ _   _| | __ _ _ __     / ___| |   |_ _|
   / △ \ | '_ \ / _` | | | | |/ _` | '__|   | |   | |    | |
  / ___ \| | | | (_| | |_| | | (_| | |      | |___| |___ | |
 /_/   \_\_| |_|\__, |\__,_|_|\__,_|_|       \____|_____|___|
                |___/
    

Angular CLI: 13.3.3
Node: 16.13.1
Package Manager: npm 8.1.2
OS: darwin x64

Angular: 13.1.3
... animations, common, compiler, compiler-cli, core, forms
... platform-browser, platform-browser-dynamic, router

Package                         Version
---------------------------------------------------------
@angular-devkit/architect       0.1301.4
@angular-devkit/build-angular   13.1.4
@angular-devkit/core            13.1.4
@angular-devkit/schematics      13.3.3
@angular/cli                    13.3.3
@schematics/angular             13.3.3
rxjs                            7.4.0
typescript                      4.5.5

$ ng update @angular/core @angular/cli


$ ng new shopping-app-aot --routing --no-strict

$ ng version

     _                      _                 ____ _     ___
    / \   _ __   __ _ _   _| | __ _ _ __     / ___| |   |_ _|
   / △ \ | '_ \ / _` | | | | |/ _` | '__|   | |   | |    | |
  / ___ \| | | | (_| | |_| | | (_| | |      | |___| |___ | |
 /_/   \_\_| |_|\__, |\__,_|_|\__,_|_|       \____|_____|___|
                |___/
    

Angular CLI: 13.3.3
Node: 16.13.1
Package Manager: npm 8.1.2
OS: darwin x64

Angular: 13.3.3
... animations, cli, common, compiler, compiler-cli, core, forms
... platform-browser, platform-browser-dynamic, router

Package                         Version
---------------------------------------------------------
@angular-devkit/architect       0.1303.3
@angular-devkit/build-angular   13.3.3
@angular-devkit/core            13.3.3
@angular-devkit/schematics      13.3.3
@schematics/angular             13.3.3
rxjs                            7.5.5
typescript                      4.6.3


How to install:

$ cd /Users/rkremers/Development/workspaceJS/Angular/shopping-app-aot
$ npm install --save bootstrap@3

Now make Angular aware of this styling package.
- angular.json file.

            "styles": [
              "node_modules/bootstrap/dist/css/bootstrap.min.css", !! bootstrap.min.css has been added here.
              "src/styles.css"
            ],

Template Driven: Add FormsModule to app.module.ts
Reactive Forms Driven: Add ReactiveFormsModule to app.module.ts
(sometimes it can be handy to use both).

$ npm install --save rxjs-compat

Go to the root directory of the application:
$ ng serve --port 4205

--> look at http://localhost:4205/


The effect of $ ng build

In the application a new folder 'dist/' has been created.

/Users/rkremers/Development/workspaceJS/Angular/shopping-app-aot
rkremers@BKWI_C02ZX41RMD6R:shopping-app-aot (master *%)$ ls -la
total 1616
drwxr-xr-x   20 rkremers  staff     640 Apr 15 00:17 .
drwxr-xr-x   26 rkremers  staff     832 Apr 14 23:56 ..
-rw-r--r--@   1 rkremers  staff    6148 Apr 15 00:13 .DS_Store
drwxr-xr-x    3 rkremers  staff      96 Apr 15 00:16 .angular
-rw-r--r--    1 rkremers  staff     600 Apr 14 23:56 .browserslistrc
-rw-r--r--    1 rkremers  staff     274 Apr 14 23:56 .editorconfig
drwxr-xr-x   12 rkremers  staff     384 Apr 14 23:57 .git
-rw-r--r--    1 rkremers  staff     548 Apr 14 23:56 .gitignore
drwxr-xr-x    5 rkremers  staff     160 Apr 14 23:56 .vscode
-rw-r--r--    1 rkremers  staff    1068 Apr 14 23:56 README.md
-rw-r--r--    1 rkremers  staff    3078 Apr 15 00:13 angular.json
drwxr-xr-x    3 rkremers  staff      96 Apr 15 00:17 dist  !!!!!!!!
-rw-r--r--    1 rkremers  staff    1433 Apr 14 23:56 karma.conf.js
drwxr-xr-x  604 rkremers  staff   19328 Apr 15 00:16 node_modules
-rw-r--r--    1 rkremers  staff  774498 Apr 15 00:13 package-lock.json
-rw-r--r--    1 rkremers  staff    1135 Apr 15 00:13 package.json
drwxr-xr-x   12 rkremers  staff     384 Apr 15 00:14 src
-rw-r--r--    1 rkremers  staff     287 Apr 14 23:56 tsconfig.app.json
-rw-r--r--    1 rkremers  staff     538 Apr 14 23:56 tsconfig.json
-rw-r--r--    1 rkremers  staff     333 Apr 14 23:56 tsconfig.spec.json

$ cd dist/shopping-app-aot/
rkremers@BKWI_C02ZX41RMD6R:shopping-app-aot (master *%)$ ls -l
total 1408
-rw-r--r--  1 rkremers  staff   10674 Apr 15 00:17 36.1cb09f1beb60fa8a.js
-rw-r--r--  1 rkremers  staff   14068 Apr 15 00:17 3rdpartylicenses.txt
-rw-r--r--  1 rkremers  staff    5109 Apr 15 00:17 54.6600087614a2ffda.js
-rw-r--r--  1 rkremers  staff    4553 Apr 15 00:17 826.6e49300344b27ed9.js
-rw-r--r--  1 rkremers  staff     948 Apr 15 00:17 favicon.ico
-rw-r--r--  1 rkremers  staff   45404 Apr 15 00:17 glyphicons-halflings-regular.009b407a9881be10.ttf
-rw-r--r--  1 rkremers  staff   23424 Apr 15 00:17 glyphicons-halflings-regular.4ba85deaf3670942.woff
-rw-r--r--  1 rkremers  staff   20127 Apr 15 00:17 glyphicons-halflings-regular.7a0f4b092e86cb52.eot
-rw-r--r--  1 rkremers  staff  108738 Apr 15 00:17 glyphicons-halflings-regular.85f0466cb4ab3a4d.svg
-rw-r--r--  1 rkremers  staff   18028 Apr 15 00:17 glyphicons-halflings-regular.b70781972ce7320b.woff2
-rw-r--r--  1 rkremers  staff    1165 Apr 15 00:17 index.html
-rw-r--r--  1 rkremers  staff  285204 Apr 15 00:17 main.1fb045d791768be2.js
-rw-r--r--  1 rkremers  staff   33830 Apr 15 00:17 polyfills.2b8bc08835e8acc9.js
-rw-r--r--  1 rkremers  staff    2862 Apr 15 00:17 runtime.3cb54d6b50ed15f6.js
-rw-r--r--  1 rkremers  staff  114421 Apr 15 00:17 styles.054a699817434cef.css

This is the code, but now bundled and decreased in size.
They are significantly smaller than the files visible in Chrome Development Tools | Network

Reason:
- The Angular compiler is removed from the final bundle.


338. Wrap Up.

339. Useful Resources & Links.

Useful Resources:

Official Docs: https://angular.io/guide/ngmodules

NgModules FAQ: https://angular.io/guide/ngmodule-faq


===================================================================================================
2022-04-14:

Section 23: Deploying an Angular App.

340. Module Introduction.

Now it will be shown how to bundle the code and send it to a server.
It will be shipped to a server from where it can be accessed from outside by any user.


341. Deployment Preparation & Steps.

Deployment Preparation.
- Use & Check environment variables.
- Polish & test code.
  - e.g. Lazy Loading.
  - Real world and systematic testing.
- ng build
  - Provides ahead-of-time compilation
- Deploy build artifacts (generated files) to static host
  - A static host is a webserver that can host HTML, JS, CSS but is not capable of running any server side language, like Java, php or node.js.
  - Because it's only HTML, JS, CSS!


342. Using Environment Variables.

shopping-app-aot/
  src/
    environments
      environment.prod.ts
      environment.ts

In these files environment parameters can be placed.

environment.ts
/**
 * 342. Using Environment Variables.
 */
export const environment = {
  production: false,
  firebaseApiKey: 'AIzaSyDTzJI66MpyZKI0nzOIAlMWSRTvO3cb9Hc'
};


environment.prod.ts
/**
 * 342. Using Environment Variables.
 */
export const environment = {
  production: true,
  firebaseApiKey: 'AIzaSyDTzJI66MpyZKI0nzOIAlMWSRTvO3cb9Hc'
};

Example:

auth.service.ts:

/**
 * 342. Using Environment Variables.
 * The environment will be determined for you depending on the type of environment.
 * e.g. Angular will distinguish between production and non-production environment.
 */
import {environment} from '../../environments/environment';

  private webApiKey = environment.firebaseApiKey;

   * The following url's are available in the firebase google reference:
   * - https://firebase.google.com/docs/reference/rest/auth#section-create-email-password
   */
  private FirebaseAuthUrl = 'https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=';
  private FirebaseSignInUrl = 'https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=';
  // The webApiKey value is available in the Settings of the Firebase Realtime Database.
  private webApiKey = 'AIzaSyDTzJI66MpyZKI0nzOIAlMWSRTvO3cb9Hc';


343. Deployment Example: Firebase Hosting.

Building the application:
$ ng build

- Compiles the code to JavaScript
- Compiles the templates to JavaScript instructions.

--> In the end only JavaScript code is contained that runs in the browser.

After this script a folder ~/dist is available that contains all code en possibly some assets.

$ ng build            
✔ Browser application bundle generation complete.
✔ Copying assets complete.
✔ Index html generation complete.

Initial Chunk Files           | Names                              |  Raw Size | Estimated Transfer Size
main.18a99b44889f6936.js      | main                               | 278.64 kB |                72.85 kB
styles.054a699817434cef.css   | styles                             | 111.74 kB |                15.33 kB
polyfills.2b8bc08835e8acc9.js | polyfills                          |  33.04 kB |                10.62 kB
runtime.f8d766c0a74e68c3.js   | runtime                            |   2.79 kB |                 1.32 kB

                              | Initial Total                      | 426.21 kB |               100.11 kB

Lazy Chunk Files              | Names                              |  Raw Size | Estimated Transfer Size
36.1cb09f1beb60fa8a.js        | recipes-recipes-module             |  10.42 kB |                 2.83 kB
54.6600087614a2ffda.js        | auth-auth-module                   |   4.99 kB |                 1.67 kB
826.6e49300344b27ed9.js       | shopping-list-shopping-list-module |   4.45 kB |                 1.50 kB

Build at: 2022-04-15T14:55:46.086Z - Hash: 57498bded079c996 - Time: 11410ms

How to deploy the built content.

A static webhost is necessary.

Google: 
- static website hosts
- static website hosting aws --> Free Amazon Websites
- static website hosting firebase --> https://firebase.google.com/docs/hosting

1. Install the Firebase CLI
- https://firebase.google.com/docs/cli#install-cli-mac-linux

How you update the CLI version depends on your operating system and how you installed the CLI.
Windows
macOS
Linux

    automatic install script: Run curl -sL https://firebase.tools | upgrade=true bash
    standalone binary: Download the new version, then replace it on your system
    npm: Run npm install -g firebase-tools

I ran the first option but the course leader used the third one.


$ curl -sL https://firebase.tools | upgrade=true bash
Password:
-- Checking for existing firebase-tools on PATH...
-- Checking your machine type...
-- Downloading binary from https://firebase.tools/bin/macos/latest
######################################################################## 100.0%# #=O#- #                                                                     
-- Setting permissions on binary...
-- Checking your PATH variable...
-- firebase-tools@10.6.0 is now installed
-- All Done!

Firebase is a Google functionality so I will need my Google account to log in.

$ firebase login
i  Firebase optionally collects CLI usage and error reporting information to help improve our products. Data is collected in accordance with Google's privacy policy (https://policies.google.com/privacy) and is not used to identify you.

? Allow Firebase to collect CLI usage and error reporting information? Yes
i  To change your data collection preference at any time, run `firebase logout` and log in again.

Visit this URL on this device to log in:
https://accounts.google.com/o/oauth2/auth?client_id=563584335869-fgrhgmd47bqnekij5i8b5pr03ho849e6.apps.googleusercontent.com&scope=email%20openid%20https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fcloudplatformprojects.readonly%20https%3A%2F%2Fwww.googleapis.com%2Fauth%2Ffirebase%20https%3A%2F%2Fwww.googleapis.com%2Fauth%2Fcloud-platform&response_type=code&state=274337724&redirect_uri=http%3A%2F%2Flocalhost%3A9005

Waiting for authentication...

✔  Success! Logged in as robkremers2014@gmail.com

$ firebase login
Already logged in as robkremers2014@gmail.com

Now go to the Angular project folder:
$ /Users/rkremers/Development/workspaceJS/Angular/shopping-app-aot

Run:
$ firebase init

Firebase now will ask which features are to be used.
- Choose: 
  Hosting: Configure files and deploy Firebase Hosting Sites # Course leader.

My options:
  Hosting: Configure files for Firebase Hosting and (optionally) set up GitHub Action deploys
  Hosting: Set up GitHub Action deploys

You're about to initialize a Firebase project in this directory:

  /Users/rkremers/Development/workspaceJS/Angular/shopping-app-aot

? Which Firebase features do you want to set up for this directory? Press Space to select features, then Enter to confirm your choices. Hosting: Configure files for Firebase Hosting and (optionally) set up GitHub Action deploys

=== Project Setup

First, let's associate this project directory with a Firebase project.
You can create multiple project aliases by running firebase use --add, 
but for now we'll just set up a default project.

? Please select an option: Use an existing project
? Select a default Firebase project for this directory: ng-course-recipe-book-375da (ng-course-recipe-book)
i  Using project ng-course-recipe-book-375da (ng-course-recipe-book)

=== Hosting Setup

Your public directory is the folder (relative to your project directory) that
will contain Hosting assets to be uploaded with firebase deploy. If you
have a build process for your assets, use your build's output directory.

? What do you want to use as your public directory? (public) 
This should be: 
- /Users/rkremers/Development/workspaceJS/Angular/shopping-app-aot/dist/shopping-app-aot
  - Here the built application resides.
? Configure as a single-page app (rewrite all urls to /index.html)? (y/N) y
? Set up automatic builds and deploys with GitHub? No
? File dist/shopping-app-aot/index.html already exists. Overwrite? No
i  Skipping write of dist/shopping-app-aot/index.html

i  Writing configuration info to firebase.json...
i  Writing project information to .firebaserc...

✔  Firebase initialization complete!

Next step: Deploy the application:
$ firebase deploy
- This will deploy the content of the folder /Users/rkremers/Development/workspaceJS/Angular/shopping-app-aot/dist/shopping-app-aot to firebase.

$ firebase deploy

=== Deploying to 'ng-course-recipe-book-375da'...

i  deploying hosting
i  hosting[ng-course-recipe-book-375da]: beginning deploy...
i  hosting[ng-course-recipe-book-375da]: found 15 files in dist/shopping-app-aot
✔  hosting[ng-course-recipe-book-375da]: file upload complete
i  hosting[ng-course-recipe-book-375da]: finalizing version...
✔  hosting[ng-course-recipe-book-375da]: version finalized
i  hosting[ng-course-recipe-book-375da]: releasing new version...
✔  hosting[ng-course-recipe-book-375da]: release complete

✔  Deploy complete!

Project Console: https://console.firebase.google.com/project/ng-course-recipe-book-375da/overview
Hosting URL: https://ng-course-recipe-book-375da.web.app

Or once used:
https://ng-course-recipe-book-375da.web.app/auth

344. Server Routing vs Browser Routing.

Server Routing vs Browser Routing
When deploying your Angular app, it's really important to make sure that your server (like S3) is configured to always serve the index.html file.

Here's why: https://academind.com/learn/angular/angular-q-a/#how-to-fix-broken-routes-after-deployment

===================================================================================================
2022-04-15:

Section: 24: Bonus: Working with NgRx in our Project

345. Module Introduction.

NgRx is maintained by the official Angular team.

346. What is Application State?


Application state:

  Application:
    - Components:
      - SigninComponent
        - Uses AuthService to authenticate User
      - HomeComponent
      - NewTrainingComponent
      - CurrentTrainingComponent
    - Services:
      - AuthService
        - Authentication check before accessing TrainsService
      - TrainingService
        - Fetch excercises to NewTrainingComponent
        - Store excercises from CurrentTrainingComponent
        - Store & Fetch from the Backend

When the application refreshes the Application State will be lost.
When an page is reloaded a new app is started and the old app is lost and the memory is cleared.
In order to save the state a backend is used. Here the state is persisted.

If the application grows and grows eventually a situation may be reached where it is hard to tell what the current state actually is.

RxJS:
- Allows us to create a streamlined State Experience.

(User) Event in UI / App
--> State Changing Event
  --> Observable
    --> Operators
      --> Listener
        --> Update UI.

Example:
recipe.service.ts:

recipeChanged = new Subject<Recipe[]>();
- Used to handle the recipes throughout the application.


347. What is NgRx?


Issues with RxJs Approach.
- State can be updated anywhere
- State is (possibly) mutable.
- Handling side effects (e.g. Http calls) is unclear.

Angular:
- No specific design pattern is enforced.

Redux to the Rescue.
- https://redux.js.org/usage/structuring-reducers/structuring-reducers
  At its core, Redux is really a fairly simple design pattern: all your "write" logic goes into a single function, 
  and the only way to run that logic is to give Redux a plain object that describes something that has happened. 
  The Redux store calls that write logic function and passes in the current state tree and the descriptive object, 
  the write logic function returns some new state tree, and the Redux store notifies any subscribers that the state tree has changed.

- State management pattern.
- Library to help manage that pattern.
- Setup:
  - There is one central Store in the application that holds the Application State.
  - The Services and Components can still interact with each other but they receive the State (i.e. the data) from that Store.
  - It may be necessary to change State. In order to change the State Actions may be needed.
  - The result of Actions will be sent to Reducers
    - Reducers reduce / combine State.
    - The reduced State is sent to the Store where the State is saved (immutably).
  - Actions support Side Effects (do something, e.g. Http requests) wich can lead to a new Action.
    - In the past e.g. asynchronous code was always a problem. You must not and you can not send an HTTP request from inside a Reducer function.
    - Redux provides a solution for thhis problem.
- RxJs is Angular's implementation of Redux.
  - Angular has a Redux library of it's own.
  - RxJs comes with some specific differences.
    - e.g. RxJs comes with injectable services.
    - The State is managed as one large Observable.
    - Supports TypeScript.
  - A different part of the State Management Library is Side Effects. RxJs gives tools that makes working with Side Effects easier.
- Asynchronous code was always a problem.
  - Reducers only may execute synchronous code.
  - This means that you can not send Http requests from inside a Reducer. So the question with Reduceers was how / where to handle Http requests.
  - RxJs ships with a built in solution.


348. Getting Started with Reducers.

In the recipes app as it is now the State is managed with Services.
This is okay.

In this module the application will be adapted using RxJs Redux design pattern.
I'll make once again a copy of the recipes app.


$ ng new shopping-app-redux --routing --no-strict

Go to the root directory of the application:
$ ng serve

--> look at http://localhost:4200/

How to install:

$ cd /Users/rkremers/Development/workspaceJS/Angular/shopping-app-redux
$ npm install --save bootstrap@3

Now make Angular aware of this styling package.
- angular.json file.

            "styles": [
              "node_modules/bootstrap/dist/css/bootstrap.min.css", !! bootstrap.min.css has been added here.
              "src/styles.css"
            ],

Template Driven: Add FormsModule to app.module.ts
Reactive Forms Driven: Add ReactiveFormsModule to app.module.ts
(sometimes it can be handy to use both).

$ npm install --save rxjs-compat

New: 
$ npm install --save @ngrx/store

added 1 package, removed 1 package, and audited 931 packages in 2s

104 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
(2022-04-15: I have just updated the latesst version of Angular)

- This is the core of ngrx. Later more packages will be installed.

$ ng --version

     _                      _                 ____ _     ___
    / \   _ __   __ _ _   _| | __ _ _ __     / ___| |   |_ _|
   / △ \ | '_ \ / _` | | | | |/ _` | '__|   | |   | |    | |
  / ___ \| | | | (_| | |_| | | (_| | |      | |___| |___ | |
 /_/   \_\_| |_|\__, |\__,_|_|\__,_|_|       \____|_____|___|
                |___/
    

Angular CLI: 13.3.3
Node: 16.13.1
Package Manager: npm 8.1.2
OS: darwin x64

Angular: 13.3.3
... animations, cli, common, compiler, compiler-cli, core, forms
... platform-browser, platform-browser-dynamic, router

Package                         Version
---------------------------------------------------------
@angular-devkit/architect       0.1303.3
@angular-devkit/build-angular   13.3.3
@angular-devkit/core            13.3.3
@angular-devkit/schematics      13.3.3
@schematics/angular             13.3.3
rxjs                            7.5.5
typescript                      4.6.3
    

Now a Reducer will be implemented.

Additional Resources:
- https://inveritasoft.com/blog/angular-using-ngrx-schematics-and-ngrx-entity-to-speed-up-your-startup

shopping-list.reducer.ts:
  import { Ingredient } from "../shared/ingredient.model";

  /**
   * 348. Getting Started with Reducers.
   * 
   * The values of import parameters state and action are provided by NgRx.
   * We can start with initial values. See shopping-list.service.ts where this also happens.
   * 
   * It makes sense to do this here too when we switch from services to Redux.
   * The initialState should be a JS object.
   * 
   * The parameter initialState is a JS object, not a TS object. Therefore the type of the parameter will be infirmed automatically.
   * Notice that the const initialState is used as input parameter. Again: this is a JS file and we are not in a class.
   */

  const initialState = {
      ingredients: [
          new Ingredient("Apples", 5),
          new Ingredient("Tomatoes", 10)
      ]
  };

/**
 * 348. Getting Started with Reducers.
 * Here an advanced JS feature is used: add a default value to the input parameters of the function.
 * 
 * @param state 
 * @param action 
 * @returns 
 */
  export function shoppingListReducer(state = initialState, action) { 
      
  }


349. Adding Logic to the Reducer.

350. Understanding & Adding Actions.

shopping-list.actions.ts
import { Action } from "@ngrx/store";
import { Ingredient } from "../../shared/ingredient.model";

/**
 * 350. Understanding & Adding Actions.
 * Constants are generally defined in a separate file.
 * Here the Action for the store is defined.
 */
export const ADD_INGREDIENT = 'ADD_INGREDIENT';

export class AddIngredient implements Action {
    readonly type: string = ADD_INGREDIENT;
    payload: Ingredient;
}

shopping-list.reducer.ts

import { Action } from "@ngrx/store";
import { Ingredient } from "../../shared/ingredient.model";
import { ADD_INGREDIENT } from "./shopping-list.actions";

/**
 * 348. Getting Started with Reducers.
 * 
 * The values of import parameters state and action are provided by NgRx.
 * We can start with initial values. See shopping-list.service.ts where this also happens.
 * 
 * It makes sense to do this here too when we switch from services to Redux.
 * The initialState should be a JS object.
 * 
 * The parameter initialState is a JS object, not a TS object. Therefore the type of the parameter will be infirmed automatically.
 * Notice that the const initialState is used as input parameter. Again: this is a JS file and we are not in a class.
 * 
 * 349. Adding Logic to the Reducer.
 * 
 * Note that Action is imported from @ngrx/store.
 * State changes within NgRx always have to be immutable. This means that you must not change the existing State.
 * Instead return a new State.
 * 
 * 350. Understanding & Adding Actions.
 * Constants are generally defined in a separate file. In this case in shopping-list.actions.ts.
 * 
 */

const initialState = {
    ingredients: [
        new Ingredient("Apples", 5),
        new Ingredient("Tomatoes", 10)
    ]
};

export function shoppingListReducer (state = initialState, action: Action) { 
    switch(action.type) {
        case ADD_INGREDIENT: 
            return {
                /**
                 * ...state pulls out all content of the old state and adds these properties to the new State.
                 * Hence in this case we return a copy of the old State.
                 * Rule of Thumb: as a safety precaution always copy the old State and change as intended.
                 * Adding 'action is just a first step. Needs to be expanded.
                 */
                ...state,
                ingredients: [...state.ingredients, action]
            };
    }
}

351. Setting Up the NgRx Store.

  shopping-list.reducer.ts:

  import { Ingredient } from "../../shared/ingredient.model";
  import * as ShoppingListActions from "./shopping-list.actions";

  const initialState = {
      ingredients: [
          new Ingredient("Apples", 5),
          new Ingredient("Tomatoes", 10)
      ]
  };

  export function shoppingListReducer(
      state = initialState,
      action: ShoppingListActions.AddIngredient
  ) {
      switch (action.type) {
          case ShoppingListActions.ADD_INGREDIENT:
              return {
                  /**
                   * ...state pulls out all content of the old state and adds these properties to the new State.
                   * Hence in this case we return a copy of the old State.
                   * Rule of Thumb: as a safety precaution always copy the old State and change as intended.
                   * Adding 'action is just a first step. Needs to be expanded.
                   */
                  ...state,
                  ingredients: [...state.ingredients, action.payload]
              };
      }
  }

app.module.ts:

import { StoreModule } from '@ngrx/store';

@NgModule({
  declarations: [
    AppComponent, 
    HeaderComponent
  ],
  /**
   * 324. Splitting Modules Correctly.
   * The BrowserModule can only be imported once. 
   * This is a special module because it also has some startup features.
   * In all other modules use the CommonModule.
   * 
   * 330. Adding an Auth Feature Module.
   * 332. Implementing Lazy Loading.
   * Once Lazy Loading is installed the RecipesModule should not be imported anymore in app.module.ts.
   * If this is forgotten the application will not work properly anymore.
   * 
   * 351. Setting Up the NgRx Store.
   * Add the ShoppingListReducer to the AppModule.
   * When adding StoreModule Angular needs to be informed which Reducers will be available.
   * Note: what is made available is a function. Not a class or Module!
   */
  imports: [
    BrowserModule,
    ReactiveFormsModule,
    HttpClientModule,
    // AuthModule, // Is Lazyloaded.
    // RecipesModule, // Is Lazyloaded.
    // ShoppingListModule, // Is Lazyloaded.
    StoreModule.forRoot({shoppingList: shoppingListReducer}), !!!!! Here the Reducer is added !!!!
    SharedModule,
    CoreModule,
    /**
     * AppRoutingModule should always be added at the end of the imports in order
     * to prevent import inconsistencies.
     */
    AppRoutingModule
  ],
  bootstrap: [AppComponent],
  providers: [LoggingService]
})
export class AppModule { }


352. Selecting State.

Resources:
- https://ngrx.io/guide/store

NgRx gives an injectable store. This is not available when using Angular Redux.

Todo:
- Go through this again and take notes.
  - 2022-05-17: done and see in detail the shopping-list notes regarding the reducer.


353. Dispatching Actions.

Where will the store content be changed, i.e. where will the dispatched Action be necessary?
- ShoppingEditComponent.
  - onSubmit()
    - update ingredient
    - add ingredient


354. Multiple Actions.

Resources:
- https://ngrx.io/docs
- https://ngrx.io/guide/store
  - 2022-04-28: studying.

Why use NgRx Store for State Management?

NgRx Store provides state management for creating maintainable, explicit applications through the use of single state and actions in order to express state changes. 
In cases where you don't need a global, application-wide solution to manage state, consider using NgRx ComponentStore which provides a solution for local state management.


Recommended by the website. Study this in advance to NgRx.
- https://rxjs.dev/
  - Reactive Extensions Library for JavaScript
- https://redux.js.org/
  - Redux is a predictable state container for JavaScript apps.

https://rxjs.dev/guide/overview

RxJS is a library for composing asynchronous and event-based programs by using observable sequences. 
It provides one core type, the Observable, satellite types (Observer, Schedulers, Subjects) and 
operators inspired by Array methods (map, filter, reduce, every, etc) to allow handling asynchronous events as collections.

Is already extensively being used in the applications.

https://redux.js.org/introduction/getting-started

The whole global state of your app is stored in an object tree inside a single store. 
The only way to change the state tree is to create an action, an object describing what happened, and dispatch it to the store. 
To specify how state gets updated in response to an action, you write pure reducer functions that calculate a new state based on the old state and the action.

Example:

import { createStore } from 'redux'

/**
 * This is a reducer - a function that takes a current state value and an
 * action object describing "what happened", and returns a new state value.
 * A reducer's function signature is: (state, action) => newState
 *
 * The Redux state should contain only plain JS objects, arrays, and primitives.
 * The root state value is usually an object. It's important that you should
 * not mutate the state object, but return a new object if the state changes.
 *
 * You can use any conditional logic you want in a reducer. In this example,
 * we use a switch statement, but it's not required.
 */
function counterReducer(state = { value: 0 }, action) {
  switch (action.type) {
    case 'counter/incremented':
      return { value: state.value + 1 }
    case 'counter/decremented':
      return { value: state.value - 1 }
    default:
      return state
  }
}

// Create a Redux store holding the state of your app.
// Its API is { subscribe, dispatch, getState }.
let store = createStore(counterReducer)

// You can use subscribe() to update the UI in response to state changes.
// Normally you'd use a view binding library (e.g. React Redux) rather than subscribe() directly.
// There may be additional use cases where it's helpful to subscribe as well.

store.subscribe(() => console.log(store.getState()))

// The only way to mutate the internal state is to dispatch an action.
// The actions can be serialized, logged or stored and later replayed.
store.dispatch({ type: 'counter/incremented' })
// {value: 1}
store.dispatch({ type: 'counter/incremented' })
// {value: 2}
store.dispatch({ type: 'counter/decremented' })
// {value: 1}


---------------------------------------------------------------------------------------------------
2022-05-09:

Study the Angular NGRX store:
- Fireship: Angular ngrx Redux Quick Start Tutorial
  - https://www.youtube.com/watch?v=f97ICOaekNU

https://ngrx.io/guide/store

Store

Store is a controlled state container designed to help write performant, consistent applications on top of Angular.

Key concepts

- Actions       : describe unique events that are dispatched from components and services.
- State changes : are handled by pure functions called reducers that take the current state and the latest action to compute a new state.
- Selectors     : are pure functions used to select, derive and compose pieces of state.
- State         : is accessed with the Store, an observable of state and an observer of actions.


Actions

  Actions are one of the main building blocks in NgRx. 
  Actions express unique events that happen throughout your application. 
  From user interaction with the page, external interaction through network requests, and direct interaction with device APIs, these and more events are described with actions.

Reducers

  Reducers in NgRx are responsible for handling transitions from one state to the next state in your application. 
  Reducer functions handle these transitions by determining which actions to handle based on the action's type.

  There are a few consistent parts of every piece of state managed by a reducer.

      - An interface or type that defines the shape of the state.
      - The arguments including the initial state or current state and the current action.
      - The functions that handle state changes for their associated action(s).

  Each reducer function is a listener of actions.

Note:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax
  Spread syntax (...)
    - Spread syntax can be used when all elements from an object or array need to be included in a list of some kind. 



354. Multiple Actions.

355. Preparing Update & Delete Actions.

356. Updating & Deleting Ingredients.

357. Expanding the state.

358. Managing More State from NgRx.

359. Removing Redundant Component State Management.

360. First Summary & Clean Up.

It is quite time-consuming to set up Actions and a reducer.
However once this has been done it is quite easy to add additional actions.

361. One Root State.

362. Setting Up Auth Reducer & Actions.

363. Dispatching Auth Actions.

In general you can dispatch from wherever it is necessary.
For the moment we will dispatch from auth.service.ts (instead of dispatching from a component).

In auth.service.ts:
- at all places where this.user.next() is called the state is (to be) updated.


364. Auth Finished (For Now...)

365. An Important Note on Actions.

Any action that is dispatched will always reach all reducers.
As defined in app.reducer.ts.
There are scenarios in which in one reducer multiple Actions have to be used.
Therefore it is important to always copy the entire state when returning and also to return a default state.
It also means that e.g. the Action identifiers (LOGIN, LOGOUT) are unique throughout the application.
(they may also reach the shoppingListReducer).
In order to keep them unique a technique called prefixing is recommended. The typical pattern is like:
export const LOGOUT = '[Auth] Logout'; (see auth.actions.ts).


366. Exploring NgRx Effects.

What are side effects?
- Parts in the code where some logic is executed that is of course important for the application but not so important for the immediate update of the current state.

Example:
- auth.service.ts:

  login(email: string, password: string) {
    return this.httpClient.post<AuthResponseData>(this.FirebaseSignInUrl + this.webApiKey,
      {
        email: email,
        password: password,
        returnSecureToken: true
      }).pipe(
        /**
         * An Observable completes whenever an error is thrown.
         */
        catchError(errorRes => this.handleError(errorRes)
        ),
        /**
         * The use of tap allows actions without changing the response.
         */
        /**
         * So in case an error is thrown the functionality in tap() is never executed.
         * The entire Observable dies and a new Observable is started when the service function, in this case signup(),
         * is called again.
         */
        tap(resData => {
          this.handleAuthentication(
            resData.email,
            resData.localId,
            resData.idToken,
            +resData.expiresIn);
        })
      );
  }

The first part is not important for the signup process.
So we can split the code into two or even three parts.
- Start signup
- Signup
- Signup error.

NgRx has a special package that will help dealing with the side effects.
Install as follows:

$ npm install --save @ngrx/effects

Note: this fails.
How to do this (it's legacy):

$ npm install --legacy-peer-deps --save @ngrx/effects
Does not work either.

$ npm install --legacy-peer-deps --save @ngrx/effects
npm ERR! code E404
npm ERR! 404 Not Found - GET https://registry.npmjs.org/@nrgx%2feffects - Not found
npm ERR! 404 
npm ERR! 404  '@nrgx/effects@*' is not in this registry.
npm ERR! 404 You should bug the author to publish it (or use the name yourself!)
npm ERR! 404 
npm ERR! 404 Note that you can also install from a
npm ERR! 404 tarball, folder, http url, or git url.


https://blog.logrocket.com/handling-side-effects-angular-redux-application/

$ npm install --save @ngrx/effects @ngrx/store rxjs

After this restart:
$npm start


367. Defining the First Effect.


Create a new file: shopping-app-redux/src/app/auth/store/auth.effects.ts

You organize the effects in classes.


368. Effects & Error Handling.

An Observable completes whenever an error is thrown.

shopping-app-redux/src/app/auth/store/auth.effects.ts is being filled in. See for details the content of the file.


369. Login via NgRx Effects.

Effects Class AuthEffects is registered in app.module.ts:

    EffectsModule.forRoot([AuthEffects]),

Used in auth.components:

    if (this.isLoginMode) {
      // authObs = this.authService.login(email, password);
      this.store.dispatch(new AuthActions.LoginStart({email: email, password: password}));
    } else {
      authObs = this.authService.signup(email, password);
    }

For the moment nothing works anymore :-)


370. Managing UI State in NgRx.

Redirecting will now be seen as a Side Effect as well.


371. Finishing the Login Effect.

Adapted:
- auth.effects.ts
- auth.actions.ts
- auth.reducer.ts
- auth.component.ts


372. Preparing Other Auth Actions.

Now add an Effect for signing up.

373. Adding SignUp.

374. Further Auth Effects.

The Loading Spinner is currently missing.

In auth.service.ts when logging out (method logout()) the method navigates to /auth.
This should now become an Effect, set up in auth.effects.ts.

auth.service.ts:
- methods signup() and login() are not used anymore.
  - Therefore method handleAuthentication() is not used anymore and therefore localStorage will not be used anymore.
    - So after a reload of the app the application will automatically be logged out.


375. Adding Auto-Login with NgRx.

Handle the localStorage via auth.effects.ts.


src/app/app.component.ts:31:30 - error TS2351: This expression is not constructable.
  Type 'String' has no construct signatures.

31     this.store.dispatch( new AuthActions.AUTO_LOGIN);

===================================================================================================
2022-06-04:

I cannot get de application working anymore so I'll have to create a new app based on ngrx-07-localstorage-effects.


$ ng new shopping-app-redux-2 --routing --no-strict

Go to the root directory of the application:
$ ng serve

--> look at http://localhost:4200/

How to install:

$ cd /Users/rkremers/Development/workspaceJS/Angular/shopping-app-redux
$ npm install --save bootstrap@3

Now make Angular aware of this styling package.
- angular.json file.

            "styles": [
              "node_modules/bootstrap/dist/css/bootstrap.min.css", !! bootstrap.min.css has been added here.
              "src/styles.css"
            ],

Template Driven: Add FormsModule to app.module.ts
Reactive Forms Driven: Add ReactiveFormsModule to app.module.ts
(sometimes it can be handy to use both).

$ npm install --save rxjs-compat

New: 
$ npm install --save @ngrx/store

added 1 package, removed 1 package, and audited 931 packages in 2s

104 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
(2022-04-15: I have just updated the latesst version of Angular)

- This is the core of ngrx. Later more packages will be installed.

$ ng --version

$ npm install --save @ngrx/effects @ngrx/store rxjs

Angular CLI: 13.3.7
Node: 16.13.1
Package Manager: npm 8.1.2
OS: darwin x64

Angular: 13.3.11
... animations, common, compiler, compiler-cli, core, forms
... platform-browser, platform-browser-dynamic, router

Package                         Version
---------------------------------------------------------
@angular-devkit/architect       0.1303.7
@angular-devkit/build-angular   13.3.7
@angular-devkit/core            13.3.7
@angular-devkit/schematics      13.3.7
@angular/cli                    13.3.7
@schematics/angular             13.3.7
rxjs                            7.5.5
typescript                      4.6.4

After this if necessary:

$ npm start


--> I'm getting an error.
Fixed.

In the meantime: comparing shopping-app-redux with shopping-app-redux-2 I could find the error. So I'll continue with shopping-app-redux.

---------------------------------------------------------------------------------------------------
2022-06-05:

286. Adding Auto-Logout.

287. Finishing the Auth Effects.

388. Using the Store Devtools.

  Adding some logging using NgRx tools.

  Google: redux devtools extension

  --> https://github.com/zalmoxisus/redux-devtools-extension
    --> Moved to:  https://github.com/reduxjs/redux-devtools

  Redux DevTools

  Developer Tools to power-up Redux development workflow or any other architecture which handles the state change (see integrations).

  It can be used as a browser extension (for Chrome, Edge and Firefox), as a standalone app or as a React component integrated in the client app.

  https://github.com/reduxjs/redux-devtools/tree/main/extension#installation
  - When using Chrome:
    - From Chrome Web Store:
      - Redux DevTools

  Once installed as Chrome Extension you can install a special package in the project.

  Stop ng serve.

  $ npm install --save-dev @ngrx/store-devtools
  - Use '--save-dev' because it is only intended for development.

  Restart ng serve
  $ ng serve --port 4202  

  Add to app.module.ts:

  import { StoreDevtoolsModule} from '@ngrx/store-devtools';
  import {environment} from "../environments/environment"; // Note: in production it would be a different environment file: environment.prod.ts.

  imports: [
  ..
      // Here logging is restricted to only production.
      StoreDevtoolsModule.instrument({logOnly: environment.production}),
  ..
  ]

  After Chrome restart you should find under Development Tools the Redux tab.

  Now you have a detailed log of what's happening in your application.

  You'll get a detailed overview of what NgRx is doing behind the scenes.


389. The Router Store.

  Another package that may come in handy:

  Stop ng serve

  $ npm install --save @ngrx/router-store

  This is also an official package, part of the NgRx suite.
  Helps with reacting to routing actions.
  It dispatches some actions automatically based on the Angular router. That would allow to write specific code in the reducer or NgRx effects
  that runs when such a routing occurs.

  Now in Development Tool | Redux more detailed content will be visible.


390. Getting Started with NgRx for Recipes.

Continue here later.

Repeat the film in order to try and find the error.
If nothing helps:
- ngrx-10-fetch-recipes-effect 

shopping-app-redux/src/app/
  recipes/
    store/
      recipe.actions.ts
      recipe.effects.ts
      recipe.reducer.ts

  shared/
    data-storage.service.ts

  store/
    app.reducer.ts

391. Fetching Recipe Detail Data.

shopping-app-redux/src/app/
  recipes/
    recipe-detail/
      recipe-detail.component.ts
    /recipe-edit/
      recipe-edit.component.ts
    recipe-list/
      recipe-list.component.ts


392. Fetching Recipes & Using the Resolver.

At this point after reloading the fetched data is gone.
In order to make this work the class RecipesResolverService in recipes-resolver.service.ts needs to be updated.

shopping-app-redux/src/app/
  app.module.ts
  recipes/
    recipes-resolver.service.ts
    store/
      recipe.effects.ts

Note that in ecipes-resolver.service.ts also:

Actions, ofType are used.

They are not limited to the effects.ts files.


393. Fixing the Auth Redirect.


shopping-app-redux/src/app/
  auth/
    store/
      auth.actions.ts


394. Update, Delete and Add Recipes.

shopping-app-redux/src/app/
  recipes/
    recipe-detail/
      recipe-detail.component.html
    recipe-edit/
      recipe-edit.component.ts
    store/
      recipe.actions.ts
      recipe.reducer.ts
  shared/
    data-storage.service.ts


395. Storing Recipes via Effects.

hopping-app-redux/src/app/
  header/
    header.component.ts
  recipes/
    store/
      recipe.actions.ts
      recipe.effects.ts
 

396. Cleanup Work.

shopping-app-redux/src/app/
  core.module.ts


397. Wrap Up.

Despite all this only the surface of NgRx has been scratched. See below for further information.

Check:
- https://ngrx.io/
- https://ngrx.io/docs
- https://github.com/ngrx/platform/tree/master/projects/example-app


298. Alternative NgRx Syntax.

https://www.udemy.com/course/the-complete-guide-to-angular-2/learn/lecture/14466642#questions/7350498
- Links to all Resources for this NgRx chapter.

399. Useful Resources & Links.


===================================================================================================
2022-06-06:

Section: 24. Preview: Standalone Components.


345. Module Introduction.

Angular 14 introduces a new feature: Standalone Components.

Building Components without @NgModule.

- What & Why?
- Basic Standalone Components
- Adding Services, Routing & Lazy Loading

It has been introduced in Preview mode. That means that it is not stable yet.


346. Starting Setup & Why We Want Standalone Components.

Resource:
- 01-starting-project.zip


Upgrading to Angular 14:
- https://www.itsolutionstuff.com/post/how-to-upgrade-from-angular-13-to-angular-14-version-exampleexample.html
- https://update.angular.io/?l=2&v=13.0-14.0


$ ng update @angular/core@14 @angular/cli@14
--> This did not work.

$ ng --version

     _                      _                 ____ _     ___
    / \   _ __   __ _ _   _| | __ _ _ __     / ___| |   |_ _|
   / △ \ | '_ \ / _` | | | | |/ _` | '__|   | |   | |    | |
  / ___ \| | | | (_| | |_| | | (_| | |      | |___| |___ | |
 /_/   \_\_| |_|\__, |\__,_|_|\__,_|_|       \____|_____|___|
                |___/
    

Angular CLI: 13.3.3
Node: 16.13.1
Package Manager: npm 8.1.2
OS: darwin x64

Angular: 
... 

Package                      Version
------------------------------------------------------
@angular-devkit/architect    0.1303.3 (cli-only)
@angular-devkit/core         13.3.3 (cli-only)
@angular-devkit/schematics   13.3.3 (cli-only)
@schematics/angular          13.3.3 (cli-only)
    
rkremers@BKWI_C02ZX41RMD6R:Angular$ npm --version
8.1.2
rkremers@BKWI_C02ZX41RMD6R:Angular$ node --version
v16.13.1

- https://www.itsolutionstuff.com/post/how-to-upgrade-from-angular-13-to-angular-14-version-exampleexample.html
$ npm uninstall -g @angular/cli
$ npm cache clean --force
$ npm cache verify
$ npm install -g @angular/cli
$ ng version

$ ng version

     _                      _                 ____ _     ___
    / \   _ __   __ _ _   _| | __ _ _ __     / ___| |   |_ _|
   / △ \ | '_ \ / _` | | | | |/ _` | '__|   | |   | |    | |
  / ___ \| | | | (_| | |_| | | (_| | |      | |___| |___ | |
 /_/   \_\_| |_|\__, |\__,_|_|\__,_|_|       \____|_____|___|
                |___/
    

Angular CLI: 14.0.0
Node: 16.13.1
Package Manager: npm 8.1.2 
OS: darwin x64

Angular: 
... 

Package                      Version
------------------------------------------------------
@angular-devkit/architect    0.1400.0 (cli-only)
@angular-devkit/core         14.0.0 (cli-only)
@angular-devkit/schematics   14.0.0 (cli-only)
@schematics/angular          14.0.0 (cli-only)

https://angular.io/guide/update-to-latest-version
- TypeScript versions older than 4.6.0 are no longer supported.

$ tsc -v
Version 4.5.4

https://www.delftstack.com/howto/typescript/update-typescript-latest-version-with-npm/
- Update to latest version of TypeScript.

$ tsc -v
Version 4.7.3

Note:
- Possibly it is necessary to use 'sudo' before the commands.

https://www.angularjswiki.com/angular/update-angular-cli-version-ng-update-to-latest-6-7-versions/

Navigate to your local Angular project folder and execute the below commands.

rm -rf node_modules
npm uninstall --save-dev angular-cli
npm install --save-dev @angular/cli@latest
npm install


=============================================================
Create a new project: standalone-components.


$ ng new standalone-components --routing --no-strict

Alternatively, explicitly adding routing:
$ ng new standalone-components --routing --defaults --no-strict


How to install:

$ cd /Users/rkremers/Development/workspaceJS/Angular/standalone-components
$ npm install --save bootstrap@3

This will download bootstrap locally. Not globally.

added 1 package, removed 1 package, and audited 1015 packages in 2s

90 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities

Will install in the node_modules folder.

Now make Angular aware of this styling package.
- angular.json file.

            "styles": [
              "node_modules/bootstrap/dist/css/bootstrap.min.css", !! bootstrap.min.css has been added here.
              "src/styles.css"
            ],

Template Driven: Add FormsModule to app.module.ts
Reactive Forms Driven: Add ReactiveFormsModule to app.module.ts

$ ng serve --port 4205

Running at:
http://localhost:4205/ 

=============================================================

Stand-alone components will allow you to get rid of NgModule and all it's configuration.

Stand-alone components do not need to be declared in the module.

Building stand-alone components will be the topic of this Section.


347. Bu8lding a First Standalone Component.

  Standalone components are built like a normal component.
  The idea behind standalone components is that they don't need a module anymore.
  After this a property is added to the decorator.

  standalone-components/src/app/
    welcome/
      details/
        details.component.ts

  @Component({
    standalone: true,
    selector: 'app-details',
    templateUrl: './details.component.html',
    styleUrls: ['./details.component.css'],
  })

  Now:
  - This component can be used in other components without declaring it, though you still need to make Angular aware of it.
  - The component should no longer be declared in app.module.ts.
    - So here DetailsComponent is removed.
  - In welcome.component.html now an unknown element is present: <app-details>
    - This does not do anything (although IntelliJ indicates an error).
  - Now you have to go to the component that is to use the standalone component.

  standalone-components/src/app/welcome/welcome.component.ts

  @Component({
    imports: [DetailsComponent], // import of the standalone component.
    selector: 'app-welcome',
    templateUrl: './welcome.component.html'
  })

  - This can only be used if the other component is also a standalone commponent.

  For the moment the import is commented out and the application is in error.

  - Alternative way:
    - Combine the standalone component with @NgModule.
    - Go to the module where the standalone component is to be used, in this case app.module.ts: class AppModule.
      - Here add the standalone component to imports instead of declarations.
      - In IntelliJ at least the component DetailsComponent show the following error:
        - Class DetailsComponent is not an Angular module.
    - In details.component.html appHighlight does not work.

  What is the idea of a standalone component if we still have to import it into the module and need to indicate that a component is a standalone component?
  - Importing into a module, etc. is only necessary if there is a mix of standalone and non-standalone components.

  For now either:
  - import in a module component or
  - import into another component.

  DetailsComponent is a standalone component and therefore decoupled from @NgModule.
  - It is not aware of other items that may be available in that module.
    - So it does not know about the SharedModule. It is however the SharedModule that implements the appHighlight directive HighlightDirective.

  Two possible solutions:
  - Change HighlightDirective into a standalone directive or
  - Import SharedModule into the standalone component DetailsComponent.

  @Component({
    standalone: true,
    imports: [SharedModule],
    selector: 'app-details',
    templateUrl: './details.component.html',
    styleUrls: ['./details.component.css'],
  })
  export class DetailsComponent

  Now the highlight styling is back again in details.component.html.
  As a side effect, since the SharedModule is only used in DetailsComponent, the SharedModule can be removed from AppModule.


348. Standalone Directives & Connecting Building Blocks.

  Migrating everything to standalone.

  @Directive({
    standalone: true,
    selector: '[appHighlight]',
  })
  export class HighlightDirective {

  Now it must not be declared anymore in any declaration in any @NgModule.
  Therefore in this app we can get rid of standalone-components/src/app/shared/shared.module.ts because we do not need it anymore.

  Now in DetailsComponent import the HighlightDirective itself.
  You must standalone components import directly into the other components where they are to be used or import them into the modules where they are to be used.


349. Migrating Another Component.

  Migrate the WelcomeComponent.

  @Component({
    standalone: true,
    imports: [DetailsComponent],
    selector: 'app-welcome',
    templateUrl: './welcome.component.html'
  })
  export class WelcomeComponent {}

  In AppModule it is no longer necessary to specify the DetailsComponent because it is now directly imported in the only component where it is used: the WelcomeComponent.
  Other components do not use the DetailsComponent. If that were the case it would remain an import to the AppModule.

  The WelcomeComponent must now not be declared anymore in AppModule because it is now standalone.
  In AppModule instead add it to imports.

  The welcome.module.ts is no longer necessary and is removed.

350. A Standalone Root Component.

If the app.component.ts also becomes standalone it will allow us to get rid of the entire app.module.ts.

standalone-components/src/
  main.ts
  app/
    app.component.ts


However: AppComponent is a root component. It is not enough to define it as a standalone component.
Also the bootstrapping component in main.ts needs to be adapted.
Now instead of bootstrappinga module:

main.ts:
  import { enableProdMode } from '@angular/core';
  import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';

  import { AppModule } from './app/app.module';
  import { environment } from './environments/environment';

  if (environment.production) {
    enableProdMode();
  }

  platformBrowserDynamic().bootstrapModule(AppModule)
    .catch(err => console.error(err));


We want to bootstrap a component. We don't have a module anymore, just components.

Now:

main.ts:
  import { enableProdMode } from '@angular/core';
  import { environment } from './environments/environment';
  import {bootstrapApplication} from "@angular/platform-browser";
  import {AppComponent} from "./app/app.component";

  if (environment.production) {
    enableProdMode();
  }

  bootstrapApplication(AppComponent); //!!!!! Instead of platformBrowserDynamic().bootstrapModule(AppModule)

We can get rid of app.module.ts now.
- BrowserModule is made available by default by using bootstrapApplication() in main.ts.

Largest advantage of using stand-alone components that we can get rid of Modules thereby simplifying the code.


351. Services & Standalone Components.

standalone-components/src/app/
  main.ts
  shared/
    analytics.service.ts
  welcome/
    details/
      details.component.ts

Services can be used by, making it available as single service:
- injection

    @Injectable({ providedIn: 'root' })   // The recommended way.

- Add the service to the providers array of a module.


Alternative:

details.component.ts


@Component({
  standalone: true,
  imports: [HighlightDirective],
  selector: 'app-details',
  templateUrl: './details.component.html',
  styleUrls: ['./details.component.css'],
  providers: [AnalyticsService]             // providing the service instead of choosing the 2 above mentioned options.
})

Be aware that in this way every component gets it's own instance of the service.

Previously if you did not want to use @Injectable({ providedIn: 'root' }) the service was added to the providers array in NgModule.
Usually in AppModule.

Now no modules exist anymore.
The service can be declared in main.ts though:

bootstrapApplication(
  AppComponent,
  {
    providers: [AnalyticsService]
  });


However: 
- The best way to provide a service is still using @Injectable({ providedIn: 'root' })


352. Routing with Standalone Components.

Resources:
- 03-starting-with-routing.zip

Added some new components:
- app-routing.module.ts
- about
- dashboard

standalone-components/src/app/
  dashboard/
    dashboard-routing.module.ts

@NgModule({
  imports: [RouterModule.forChild(routes)], // Enables Lazy Loading.
  exports: [RouterModule],
})

app-routing.module.ts:

    path: 'dashboard',
    // Enables Lazy Loading.
    loadChildren: () =>
      import('./dashboard/dashboard-routing.module').then(
        (mod) => mod.DashboardRoutingModule
      ),
  },

Currently the functionality in app-routing.module.ts and dashboard-routing.module.ts is not working because we don't have app.module.ts / AppModule.
This would until now have wired up the parts of the application.

Now in app.component.html is used:

  <router-outlet></router-outlet>

Instead of originally:

  <app-welcome></app-welcome>

All this will fail now.

<router-outlet> will not work anymore because app.component.ts is now a standalone component and does not know what to do with the <router-outlet>.


<router-outlet> and <li><a routerLink="/">Home</a></li> are unknown to Angular if the router-module is not available

We have to import the RouterModule in app.component.ts. This was previously imported in AppModule / app.module.ts but that does not exist anymore.
Now <router-outlet> and <li><a routerLink="/">Home</a></li> are known elements.

app.component.ts:

  @Component({
    standalone: true,
    imports: [WelcomeComponent, RouterModule],
    selector: 'app-root',
    templateUrl: './app.component.html',
    styleUrls: ['./app.component.css'],
  })
  export class AppComponent {}


The app is not aware of the routes yet that are define in app-routing.module.ts and dashboard-routing.module.ts. 
We have to add our routing modules in main.ts.

The routing modules are not a service but RouterModule.forRoot(routes) acts as such.
We have to import a helper function in main.ts.
- importProvidersFrom

main.ts:

import {enableProdMode, importProvidersFrom} from '@angular/core';

bootstrapApplication(
  AppComponent, {
    providers: [
      /**
       * The following makes the standalone root-component aware of the routes in the application.
       */
      importProvidersFrom(AppRoutingModule)
    ]
  }
);

The functionality is lazy-loaded.
When looking at Developer Tool | Network and reload it is visible that the code for 'Dasboard' is only loaded when clicked on 'Dashboard'.


353. Lazy Loading.

Now migrating the AboutCommponent to standalone.

about.component.ts:

  import { Component } from '@angular/core';

  @Component({
    standalone: true,
    imports: [], // import here other standalone components. For this component not the case.
    templateUrl: './about.component.html'
  })
  export class AboutComponent {}


app-routing.module.ts:

  const routes: Route[] = [
    {
      path: '',
      component: WelcomeComponent,
    },
    {
      path: 'about',
      component: AboutComponent,
    },
    {
      path: 'dashboard',
      loadChildren: () =>
        import('./dashboard/dashboard-routing.module').then(
          (mod) => mod.DashboardRoutingModule
        ),
    },
  ];

  @NgModule({
    imports: [RouterModule.forRoot(routes)],
    exports: [RouterModule],
  })
  export class AppRoutingModule {}

The functionality above works but is not lazy-loaded. Instead it is present in the main bundle.

New setup:

  {
    path: 'about',
    // component: AboutComponent,
    /**
     * New, Angular 14 syntax that only works with standalone components.
     * With this implementation the about compoonent is now lazy-loaded too.
     * Now you can load individual components lazily without having to wrap them into a routing module
     * like the dashboard-routing module which uses RouterModule.forChild(routes).
     *
     * In the old situation, even if you want to lazily load only one component, you have to set up a routing.module.ts
     * in the module. That is now no longer necessary.
     */
    loadComponent: () =>
      import('./about/about.component').then((mod) => mod.AboutComponent),
  },

today.component.ts:

  @Component({
    standalone: true,
    templateUrl: './today.component.html',
  })
export class TodayComponent {}

dashboard.component.ts

  @Component({
    standalone: true,
    templateUrl: './dashboard.component.html',
  })
  export class DashboardComponent {}

Remove dashboard.module.ts.
Remove dashboard-routing.module.ts.

New file:
standalone-components/src/app/
  dashboard/
    routes.ts

  /**
   * Here we load when we navigate to the dashboard. Not when the application starts.
   * The content below is a Route definition.
   * This has to be called in app-routing.module.ts.
   */
  export const DASHBOARD_ROUTES: Route[] = [
    {
      path: '',
      component: DashboardComponent
    },
    {
      path: 'today',
      component: TodayComponent,
      // Option: lazy loading of a component.
      loadComponent: () =>
        import('./today/today.component').then((mod) => mod.TodayComponent),
    }
  ];

app-routing.module.ts

  {
    path: 'dashboard',
    loadChildren: () =>
      import('./dashboard/routes').then(
        (mod) => mod.DASHBOARD_ROUTES
      ),
  },


354. Summary.

$ node --version
v16.13.1
$ npm --version
8.1.2
$ ng version

     _                      _                 ____ _     ___
    / \   _ __   __ _ _   _| | __ _ _ __     / ___| |   |_ _|
   / △ \ | '_ \ / _` | | | | |/ _` | '__|   | |   | |    | |
  / ___ \| | | | (_| | |_| | | (_| | |      | |___| |___ | |
 /_/   \_\_| |_|\__, |\__,_|_|\__,_|_|       \____|_____|___|
                |___/
    

Angular CLI: 14.0.0
Node: 16.13.1
Package Manager: npm 8.1.2 
OS: darwin x64

Angular: undefined
... 

Package                      Version
------------------------------------------------------
@angular-devkit/architect    0.1400.0 (cli-only)
@angular-devkit/core         14.0.0 (cli-only)
@angular-devkit/schematics   14.0.0 (cli-only)
@schematics/angular          14.0.0 (cli-only)


===================================================================================================
2022-06-06:

Section: 26. Bonus: Angular Universal.

400. Module Introduction.

Resources:
- ng-universal-01-start.zip

Also:
- https://angular.io/guide/universal

Is using the store.

Angular Universal allows you to pre-render the application on the server.


401. Angular Universal & ModuleMapLoader.

  A quick note: 
  In the next lecture, I mention that it's important to add ModuleMapLoader to your app.server.ts file - if you're using Angular 9, this is NOT required anymore!

Note from me:
- This is out of date.


402. Adding Angular Universal.

This needs to be added to the project.

I have copied the content of shopping-app-redux to a new app shopping-app-universal (which is based on Angular 14).

The purpose of the project is to do the following:
$ ng add @nguniversal/express-engine --clientProject

Create a new project:
$ ng new shopping-app-universal --routing --defaults --no-strict

In the new project do the following:
- Copy src/app and src/environments

$ npm install --save bootstrap@3
$ npm install --save rxjs-compat
$ npm install --save @ngrx/router-store --force
$ npm install --save @ngrx/effects @ngrx/store rxjs --legacy-peer-deps
$ npm i -D @ngrx/store-devtools --legacy-peer-deps

Replace the app and environments folder from my project in Section 25: Bonus: Working with NgRx in our Project.

Now make Angular aware of this styling package.
- angular.json file.

            "styles": [
              "node_modules/bootstrap/dist/css/bootstrap.min.css",
              "src/styles.css"
            ],

$ ng add @nguniversal/express-engine --clientProject


In angular.json is pressent:

{
  "$schema": "./node_modules/@angular/cli/lib/config/schema.json",
  "version": 1,
  "newProjectRoot": "projects",
  "projects": {
    "shopping-app-universal": {
..

}

Now use:

$ ng add @nguniversal/express-engine --clientProject shopping-app-universal

THE COMMAND ABOVE IS OUT OF DATE (FOR ANGULAR 14).

Note:
- In the newer versions of Angular you just run:
  $ ng add @nguniversal/express-engine

This is correctly installed.

package.json:
..
    "@nguniversal/express-engine": "^14.0.0",
..


$ npm install --save @nguniversal/module-map-ngfactory-loader --force
Note:
- The '--force' has been added by me.

Now:
app.server.module.ts:

import { ModuleMapLoaderModule} from '@nguniversal/module-map-ngfactory-loader';

@NgModule({
  imports: [
    AppModule,
    ServerModule,
    ModuleMapLoaderModule
  ],
  bootstrap: [AppComponent],
})
export class AppServerModule {}

Important:
- The project code is first rendered and executed on the server. Not in the browser.
  So the first page / load is rendered on the server. Only after that first page has been rendered on the server and returned to the user the normal application starts
  to run on the browser.
  It means that certain browser-only api's are not available. In our case localStorage. This is a browser only api.

In order to fix this go to:
- app.components.ts:

  ngOnInit(): void {
    this.store.dispatch( new AuthActions.AutoLogin());
    this.loggingService.printlog('Hello from AppComponent ngOnInit');
  }

Don't run this when rendering on a server.

In package.json is now present:

  "name": "shopping-app-universal",
  "version": "0.0.0",
  "scripts": {
    "ng": "ng",
    "start": "ng serve",
    "build": "ng build",
    "watch": "ng build --watch --configuration development",
    "test": "ng test",
    "dev:ssr": "ng run shopping-app-universal:serve-ssr",
    "serve:ssr": "node dist/shopping-app-universal/server/main.js",
    "build:ssr": "ng build && ng run shopping-app-universal:server",
    "prerender": "ng run shopping-app-universal:prerender"
  },

Now run in a terminal:
$ npm run build:ssr


Error: node_modules/@nguniversal/module-map-ngfactory-loader/src/module-map-ngfactory-loader.d.ts:8:10 - error TS2305: Module '"@angular/core"' has no exported member 'NgModuleFactoryLoader'.

8 import { NgModuleFactoryLoader, InjectionToken, NgModuleFactory, Compiler } from '@angular/core';
           ~~~~~~~~~~~~~~~~~~~~~

I have filed a question at the course.

If the above described functionality would have functioned:

$ npm run serve:ssr


$ npm uninstall @nguniversal/module-map-ngfactory-loader

$ npm run serve:ssr

View source:

view-source:http://localhost:4203/auth

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>ShoppingAppUniversal</title>
  <base href="/">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
<link rel="stylesheet" href="styles.css"></head>
<body>
  <app-root></app-root>
<script src="runtime.js" type="module"></script><script src="polyfills.js" type="module"></script><script src="styles.js" defer></script><script src="vendor.js" type="module"></script><script src="main.js" type="module"></script></body>
</html>


http://localhost:4000/auth

view-source:http://localhost:4000/auth

<!DOCTYPE html><html lang="en"><head>
  <meta charset="utf-8">
  <title>ShoppingAppUniversal</title>
  <base href="/">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
<style>html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}@media print{*,:after,:before{color:#000!important;text-shadow:none!important;background:0 0!important;box-shadow:none!important}}*{box-sizing:border-box}:after,:before{box-sizing:border-box}html{font-size:10px;-webkit-tap-highlight-color:rgba(0,0,0,0)}body{font-family:Helvetica Neue,Helvetica,Arial,sans-serif;font-size:14px;line-height:1.42857143;color:#333;background-color:#fff}</style><style>html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}nav{display:block}a{background-color:transparent}a:active,a:hover{outline:0}button,input{color:inherit;font:inherit;margin:0}button{overflow:visible}button{text-transform:none}button{-webkit-appearance:button;cursor:pointer}button[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}input{line-height:normal}@media print{*,:after,:before{color:#000!important;text-shadow:none!important;background:0 0!important;box-shadow:none!important}a,a:visited{text-decoration:underline}a[href]:after{content:" (" attr(href) ")"}a[href^="#"]:after{content:""}.navbar{display:none}}*{box-sizing:border-box}:after,:before{box-sizing:border-box}html{font-size:10px;-webkit-tap-highlight-color:rgba(0,0,0,0)}body{font-family:Helvetica Neue,Helvetica,Arial,sans-serif;font-size:14px;line-height:1.42857143;color:#333;background-color:#fff}button,input{font-family:inherit;font-size:inherit;line-height:inherit}a{color:#337ab7;text-decoration:none}a:focus,a:hover{color:#23527c;text-decoration:underline}a:focus{outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}ul{margin-top:0;margin-bottom:10px}.container{padding-right:15px;padding-left:15px;margin-right:auto;margin-left:auto}@media (min-width:768px){.container{width:750px}}@media (min-width:992px){.container{width:970px}}@media (min-width:1200px){.container{width:1170px}}.container-fluid{padding-right:15px;padding-left:15px;margin-right:auto;margin-left:auto}.row{margin-right:-15px;margin-left:-15px}.col-md-12,.col-md-6,.col-xs-12{position:relative;min-height:1px;padding-right:15px;padding-left:15px}.col-xs-12{float:left}.col-xs-12{width:100%}@media (min-width:992px){.col-md-12,.col-md-6{float:left}.col-md-12{width:100%}.col-md-6{width:50%}.col-md-offset-3{margin-left:25%}}label{display:inline-block;max-width:100%;margin-bottom:5px;font-weight:700}.form-control{display:block;width:100%;height:34px;padding:6px 12px;font-size:14px;line-height:1.42857143;color:#555;background-color:#fff;background-image:none;border:1px solid #ccc;border-radius:4px;box-shadow:inset 0 1px 1px #00000013;transition:border-color ease-in-out .15s,box-shadow ease-in-out .15s}.form-control:focus{border-color:#66afe9;outline:0;box-shadow:inset 0 1px 1px #00000013,0 0 8px #66afe999}.form-control::-moz-placeholder{color:#999;opacity:1}.form-control:-ms-input-placeholder{color:#999}.form-control::-webkit-input-placeholder{color:#999}.form-control::-ms-expand{background-color:transparent;border:0}.form-group{margin-bottom:15px}.btn{display:inline-block;margin-bottom:0;font-weight:400;text-align:center;white-space:nowrap;vertical-align:middle;touch-action:manipulation;cursor:pointer;background-image:none;border:1px solid transparent;padding:6px 12px;font-size:14px;line-height:1.42857143;border-radius:4px;-webkit-user-select:none;user-select:none}.btn:active:focus,.btn:focus{outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}.btn:focus,.btn:hover{color:#333;text-decoration:none}.btn:active{background-image:none;outline:0;box-shadow:inset 0 3px 5px #00000020}.btn[disabled]{cursor:not-allowed;filter:alpha(opacity=65);opacity:.65;box-shadow:none}.btn-primary{color:#fff;background-color:#337ab7;border-color:#2e6da4}.btn-primary:focus{color:#fff;background-color:#286090;border-color:#122b40}.btn-primary:hover{color:#fff;background-color:#286090;border-color:#204d74}.btn-primary:active{color:#fff;background-color:#286090;background-image:none;border-color:#204d74}.btn-primary:active:focus,.btn-primary:active:hover{color:#fff;background-color:#204d74;border-color:#122b40}.btn-primary[disabled]:focus,.btn-primary[disabled]:hover{background-color:#337ab7;border-color:#2e6da4}.nav{padding-left:0;margin-bottom:0;list-style:none}.nav>li{position:relative;display:block}.nav>li>a{position:relative;display:block;padding:10px 15px}.nav>li>a:focus,.nav>li>a:hover{text-decoration:none;background-color:#eee}.navbar{position:relative;min-height:50px;margin-bottom:20px;border:1px solid transparent}@media (min-width:768px){.navbar{border-radius:4px}}@media (min-width:768px){.navbar-header{float:left}}.navbar-collapse{padding-right:15px;padding-left:15px;overflow-x:visible;border-top:1px solid transparent;box-shadow:inset 0 1px #ffffff1a;-webkit-overflow-scrolling:touch}@media (min-width:768px){.navbar-collapse{width:auto;border-top:0;box-shadow:none}}.container-fluid>.navbar-collapse,.container-fluid>.navbar-header{margin-right:-15px;margin-left:-15px}@media (min-width:768px){.container-fluid>.navbar-collapse,.container-fluid>.navbar-header{margin-right:0;margin-left:0}}.navbar-brand{float:left;height:50px;padding:15px;font-size:18px;line-height:20px}.navbar-brand:focus,.navbar-brand:hover{text-decoration:none}@media (min-width:768px){.navbar>.container-fluid .navbar-brand{margin-left:-15px}}.navbar-nav{margin:7.5px -15px}.navbar-nav>li>a{padding-top:10px;padding-bottom:10px;line-height:20px}@media (min-width:768px){.navbar-nav{float:left;margin:0}.navbar-nav>li{float:left}.navbar-nav>li>a{padding-top:15px;padding-bottom:15px}}@media (min-width:768px){.navbar-right{float:right!important;margin-right:-15px}}.navbar-default{background-color:#f8f8f8;border-color:#e7e7e7}.navbar-default .navbar-brand{color:#777}.navbar-default .navbar-brand:focus,.navbar-default .navbar-brand:hover{color:#5e5e5e;background-color:transparent}.navbar-default .navbar-nav>li>a{color:#777}.navbar-default .navbar-nav>li>a:focus,.navbar-default .navbar-nav>li>a:hover{color:#333;background-color:transparent}.navbar-default .navbar-nav>.active>a,.navbar-default .navbar-nav>.active>a:focus,.navbar-default .navbar-nav>.active>a:hover{color:#555;background-color:#e7e7e7}.navbar-default .navbar-collapse{border-color:#e7e7e7}.container-fluid:after,.container-fluid:before,.container:after,.container:before,.nav:after,.nav:before,.navbar-collapse:after,.navbar-collapse:before,.navbar-header:after,.navbar-header:before,.navbar:after,.navbar:before,.row:after,.row:before{display:table;content:" "}.container-fluid:after,.container:after,.nav:after,.navbar-collapse:after,.navbar-header:after,.navbar:after,.row:after{clear:both}</style><link rel="stylesheet" href="styles.7d7a0d681033cb26.css" media="print" onload="this.media='all'"><noscript><link rel="stylesheet" href="styles.7d7a0d681033cb26.css"></noscript></head>
<body>
  <app-root _nghost-sc50="" ng-version="14.0.1"><app-header _ngcontent-sc50=""><nav class="navbar navbar-default"><div class="container-fluid"><div class="navbar-header"><a href="#" class="navbar-brand">Recipe Book</a></div><div class="navbar-collapse"><ul class="nav navbar-nav"><!----><li routerlinkactive="active" class="active"><a routerlink="/auth" href="/auth">Authenticate</a></li><!----><li routerlinkactive="active"><a routerlink="/shopping-list" href="/shopping-list">Shopping List</a></li></ul><ul class="nav navbar-nav navbar-right"><!----><!----></ul></div></div></nav></app-header><div _ngcontent-sc50="" class="container"><div _ngcontent-sc50="" class="row"><div _ngcontent-sc50="" class="col-md-12"><router-outlet _ngcontent-sc50=""></router-outlet><app-auth _nghost-sc60=""><div _ngcontent-sc60="" class="row"><div _ngcontent-sc60="" class="col-xs-12 col-md-6 col-md-offset-3"><!----><!----><form _ngcontent-sc60="" novalidate="" class="ng-untouched ng-pristine ng-invalid"><div _ngcontent-sc60="" class="form-group"><label _ngcontent-sc60="" for="email">E-mail</label><input _ngcontent-sc60="" type="email" id="email" ngmodel="" name="email" required="" email="" class="form-control ng-untouched ng-pristine ng-invalid" value=""></div><div _ngcontent-sc60="" class="form-group"><label _ngcontent-sc60="" for="password">Password</label><input _ngcontent-sc60="" type="password" id="password" ngmodel="" name="password" required="" minlength="6" class="form-control ng-untouched ng-pristine ng-invalid" value=""></div><div _ngcontent-sc60=""><button _ngcontent-sc60="" type="submit" class="btn btn-primary" disabled=""> Login </button> | <button _ngcontent-sc60="" type="button" class="btn btn-primary"> Sign Up </button></div></form><!----></div></div></app-auth><!----></div></div></div></app-root>
<script src="runtime.91239a5b977fddd2.js" type="module"></script><script src="polyfills.6d8b4e13fc563d56.js" type="module"></script><script src="main.204d831744fe418c.js" type="module"></script>

</body></html>


Okay: now it works.
Now search-engines will see our page as they should see it.


403. Adding Angular Universal with NestJS.

Resources:
- https://academind.com/tutorials/nestjs-introduction
- ng-universal-03-nestjs.zip

NestJS - A Thorough Introduction

NestJS is a bit like Angular - just for Node.js. 
In this tutorial, I walk you through its core building blocks by building an API with you.

NestJS is a bit like Angular but it builds up on Node.JS. So on the server side.
It is TypeScript based.

One way of Angular Universal rendering is as follows (after the necessary installation of libraries):
$ npm run serve:ssr

Another way of rendering @nguniversal is the use of NestJS.

$ ng add @nestjs/ng-universal

  $ ng add @nestjs/ng-universal --force           
  ℹ Using package manager: npm
  ⚠ Unable to find compatible package. Using 'latest' tag.
  ⚠ Package has unmet peer dependencies. Adding the package may not succeed.

  The package @nestjs/ng-universal@6.0.0 will be installed and executed.
  Would you like to proceed? Yes
  npm ERR! code ERESOLVE
  npm ERR! ERESOLVE unable to resolve dependency tree
  npm ERR! 
  npm ERR! While resolving: shopping-app-universal@0.0.0
  npm ERR! Found: @angular/common@14.0.1
  npm ERR! node_modules/@angular/common
  npm ERR!   @angular/common@"^14.0.0" from the root project
  npm ERR! 
  npm ERR! Could not resolve dependency:
  npm ERR! peer @angular/common@"^12.0.0 || ^13.0.0" from @nestjs/ng-universal@6.0.0
  npm ERR! node_modules/@nestjs/ng-universal
  npm ERR!   @nestjs/ng-universal@"6.0.0" from the root project
  npm ERR! 
  npm ERR! Fix the upstream dependency conflict, or retry
  npm ERR! this command with --force, or --legacy-peer-deps
  npm ERR! to accept an incorrect (and potentially broken) dependency resolution.
  npm ERR! 
  npm ERR! See /Users/rkremers/.npm/eresolve-report.txt for a full report.

  npm ERR! A complete log of this run can be found in:
  npm ERR!     /Users/rkremers/.npm/_logs/2022-06-11T20_07_53_781Z-debug.log
  ✖ Packages installation failed, see above.


Currently there is an inssue adding this library to the latest ng version (13, 14).
See: https://github.com/nestjs/ng-universal/issues/755

You can also skip this lecture (which is not about the Angular core features, but just an excursion with a third party package). The following sections don't rely on this.

Jost

404. Deploying Universal Apps.

Deployed will be:
shopping-app-universal
  /dist
  /src/package.json

Deploying Universal Apps
As mentioned in the previous lectures, you can't deploy an Angular Universal app to a static host (i.e. Firebase Hosting, AWS S3 etc will NOT work).

The reason for this is, that you're using Node.js to pre-render pages on the server and those Hosts don't support Node.js.

Hence you need a host that does - for example AWS ElasticBeanstalk or Heroku.

To these hosts, you need to upload your dist/ folder along with the package.json file. 
On the web server, you then have to ensure that npm install is executed, followed by npm serve:ssr.

That's it - your app is now up and running on a web server!

Here's an example how you could host Universal apps via Firebase Cloud Functions (NOT Firebase Hosting): 
-  https://www.udemy.com/the-complete-guide-to-angular-2/learn/lecture/15267340#questions/7482486


405. Important: Remaining Lectures.

The following lessons are out of date but interesting to show the process that would be automated by adding them to e.g. Heroku as discussed in Lesson 404.

406. Module Introduction

407. Getting Started with Angular Universal.

408. Working on the App Module.

409. Adding a Server-Side Build Workflow.

410. Angular Universal Gotchas.

  You typically use Angular Universal to pre-render Angular pages on the server. 
  Once the app then runs on the client, it's a normal SPA again.

  Server-side rendering (SSR) can make sense because of SEO considerations (crawler should see what your users see) or because you want to deliver a finished page to your users (rather than creating the page in the browser).

  But that also has one important implication: 
  - You MUST NOT use any browser-only APIs like document.querySelector()  in your Angular code! 

  Simply because it will execute on the server and there, such APIs are not available.

  That's why, in this course, I recommended to use Angular features only: 
  - These features are safe to use because Angular will check if a certain API can be used before it uses it.



===================================================================================================
2022-06-12:

Section: 28. Adding Offline Capabilities with Service Workers.

426. Module Introduction.

Resource:
- ng-pwa-01-start.zip
- https://angular.io/guide/service-worker-intro

Purpose of this section:
- Turn an online-only application into an offline-only application.

Developer Tool | Application | Service Workers:
- click 'Offline'.
  - This will simulate that there is no internet connection.


427. Adding Service Worker.

What are Service Workers?

Normally:
- Loaded JS: runs on one single thread, attached to individual HTML pages.

- A Service Worker runs on an additional thread, decoupled from HTML pages.
  - Manages all pages of a given scope (e.g. all pages of a domain).
  - Can cache incoming messages / data. This will allow the app to continue even if offline.

$ ng add @angular/pwa.

$ ng build --prod
- This will create a build that is ready for production.
  - This will be available in the /dist folter (and don't forget /src/package.json).

Now a web server is necessary to run the application:
- e.g.:
  $ ng serve --prod
  - Here you will not see the service-worker in action.

Solution:
- Install a light-weight node.js server.
  $ npm install --global http-server <enter>
- Run the http-server:
  $ http-server

$ cd dist/angular-pwa <enter>
$ http-server -p 8081 <enter>

--> http://localhost:8081
  --> the app should be present.

Reload the website once to ensure that the service-worker can do it's work.
Go to Developer Tool | Application | Service Workers
It should now be visible that ngsw-worker.js is running.
Ensure that the Developer Tool | Application | Storage is cleared entirely
If at Developer Tool | Application | Service Workers we click Offline again the application will keep working.

We will see everything that is hard-coded in the app still works. The dynamic content will be missing (for the moment).

So if we:
- change something in the code
- rebuild ($ ng build --prod)
- cd dist/angular-pwa 
- http://localhost:8081

The change should be visible.
If necessary reload.

If I go fully offline, by switching off wifi, de page will mostly be white (except for the last update). 
That needs to be improved by adapting the service-worker settings in the app (came with the module installation).

428. Caching Assets for Offline Use.

429. Caching Dynamic Assets & URL's.

430. Further Links & Resources.

Official Angular Service Worker Docs: https://angular.io/guide/service-worker-intro
Academind Resources on PWAs: https://academind.com/learn/progressive-web-apps

===================================================================================================
2022-06-12:

Section: 29. A Basic intoduction to Unit Testing in Angular Apps.

431. About this Section.

  This Section only provides an Introduction to Unit Testing an Angular 2+ App.

  It's NOT a detailed Guide about that neither is it a detailed Introduction to Unit Testing in general. Check out the "Further Resources" (last Lecture in this Module) to dive deeper into these topics.

432. Introduction.

Resources:
- testing-final.zip
- https://angular.io/guide/testing

433. Why Unit Tests?

- Guard against Breaking Changes
- Analyze Code Behavior (Expected and Unexpected)
- Reveal Design Mistakes.


434. Analyzing the Testing Setup (as created by the CLI).


Description of app.component.spec.ts.

  /* tslint:disable:no-unused-variable */

  import { TestBed, async } from '@angular/core/testing'; // Notice the import of test functionality.
  import { AppComponent } from './app.component';

  describe('App: CompleteGuideFinalWebpack', () => {
    beforeEach(() => {
      TestBed.configureTestingModule({
        declarations: [
          AppComponent
        ],
      });
    });

    it('should create the app', 
      async(() => {
        let fixture = TestBed.createComponent(AppComponent);
        let app = fixture.debugElement.componentInstance;
        expect(app).toBeTruthy();
      })
    );

    it(`should have as title 'app works!'`, async(() => {
      let fixture = TestBed.createComponent(AppComponent);
      let app = fixture.debugElement.componentInstance;
      expect(app.title).toEqual('app works!');
    }));

    it('should render title in a h1 tag', async(() => {
      let fixture = TestBed.createComponent(AppComponent);
      fixture.detectChanges();
      let compiled = fixture.debugElement.nativeElement;
      expect(compiled.querySelector('h1').textContent).toContain('app works!');
    }));
  });

435. Running Tests (with the CLI).
436. Adding a Component and some fitting Tests.
437. Testing Dependencies: Components and Services.
438. Simulating Async Tasks.
439. Using "fakeAsync" and "tick".


  ## Running unit tests

  Run `ng test` to execute the unit tests via [Karma](https://karma-runner.github.io).

436. Adding a Component and some fitting Tests.

data.service.ts:
  /**
  * This is an asynchronous service.
  **/
  export class DataService {
    getDetails() {
      const resultPromise = new Promise((resolve, reject) => {
        setTimeout(() => {
          resolve('Data');
        }, 1500);
      });
      return resultPromise;
    }
  }


Create a new component user:
$ ng create component user <enter>

user.component:
- html:

  <div *ngIf="isLoggedIn">
    <h1>User logged in</h1>
    <p>User is: {{ user.name }}</p>
  </div>
  <div *ngIf="!isLoggedIn">
    <h1>User not logged in</h1>
    <p>Please log in first</p>
  </div>

- ts:

  import { Component, OnInit } from '@angular/core';

  import { UserService } from "./user.service";
  import { DataService } from "../shared/data.service";

  @Component({
    selector: 'app-user',
    templateUrl: './user.component.html',
    styleUrls: ['./user.component.css'],
    providers: [UserService, DataService]
  })
  export class UserComponent implements OnInit {
    user: {name: string};
    isLoggedIn = false;
    data: string;

    constructor(
      private userService: UserService, 
      private dataService: DataService
    ) { }

    ngOnInit() {
      this.user = this.userService.user;
      this.dataService.getDetails().then((data: string) => this.data = data);
    }

  }

-service.ts:
  /**
  * This is a synchronous service.
  **/
  export class UserService {
    user = {
      name: 'Max'
    };
  }


- spec.ts:

  /* tslint:disable:no-unused-variable */

  import { TestBed, async, fakeAsync, tick } from '@angular/core/testing';
  import { UserComponent } from './user.component';
  import { UserService } from "./user.service";
  import { DataService } from "../shared/data.service";

  describe('Component: User', () => {
    beforeEach(() => {
      TestBed.configureTestingModule({
        declarations: [UserComponent]
      });
    });

    // 436. Adding a Component and some fitting Tests.
    // This test only check whether the application actually starts up.
    it('should create the app', () => {
      let fixture = TestBed.createComponent(UserComponent);
      let app = fixture.debugElement.componentInstance;
      expect(app).toBeTruthy();
    });

    /**
    * 436. Adding a Component and some fitting Tests.
    * fixture.detectChanges(); needs to be executed, i.e. present because we need to update the properties accordingly.
    * This happens automatically in the browser but not in the unit test.
    * Here is tested whether the user.name provided by the user.service.ts actually arrives in the user.component.ts.
    *
    **/
    it('should use the user name from the service', () => {
      let fixture = TestBed.createComponent(UserComponent);
      let app = fixture.debugElement.componentInstance;
      let userService = fixture.debugElement.injector.get(UserService);
      fixture.detectChanges();
      expect(userService.user.name).toEqual(app.user.name);
    });

    // 437. Testing Dependencies: Components and Services.
    it('should display the user name if user is logged in', () => {
      let fixture = TestBed.createComponent(UserComponent);
      let app = fixture.debugElement.componentInstance;
      app.isLoggedIn = true;
      fixture.detectChanges();
      let compiled = fixture.debugElement.nativeElement;
      expect(compiled.querySelector('p').textContent).toContain(app.user.name);
    });

    /**
    * 437. Testing Dependencies: Components and Services.
    * Here 'app.isLoggedIn = true;' is not present. 
    * Therefore implicitly 'app.isLoggedIn = false;'.
    *
    **/
    it('shouldn\'t display the user name if user is not logged in', () => {
      let fixture = TestBed.createComponent(UserComponent);
      let app = fixture.debugElement.componentInstance;
      fixture.detectChanges();
      let compiled = fixture.debugElement.nativeElement;
      expect(compiled.querySelector('p').textContent).not.toContain(app.user.name);
    });

    /**
    * 438. Simulating Async Tasks.
    * 'spyOn' is provided by the testing functionality. It is not an Angular core functionality.
    *
    * Apparently the return of the 'Data' is expected to be undefined.
    **/
    it('shouldn\'t fetch data successfully if not called asynchronously', () => {
      let fixture = TestBed.createComponent(UserComponent);
      let app = fixture.debugElement.componentInstance;
      let dataService = fixture.debugElement.injector.get(DataService);
      let spy = spyOn(dataService, 'getDetails')
        .and.returnValue(Promise.resolve('Data'));
      fixture.detectChanges();
      expect(app.data).toBe(undefined);
    });

    /**
    * 438. Simulating Async Tasks.
    * Now the 'async()' functionality is used to fake an asynchronous task.
    * In order to test this successfully the 'fixture.whenStable()' has to be added.
    * 
    **/
    it('should fetch data successfully if called asynchronously', async(() => {
      let fixture = TestBed.createComponent(UserComponent);
      let app = fixture.debugElement.componentInstance;
      let dataService = fixture.debugElement.injector.get(DataService);
      let spy = spyOn(dataService, 'getDetails')
        .and.returnValue(Promise.resolve('Data'));
      fixture.detectChanges();

      fixture.whenStable().then(() => {
        expect(app.data).toBe('Data');
      });

    }));

    /**
    * 439. Using "fakeAsync" and "tick".
    * Actually we know that the promise will be synchronous.
    * Notice that we did not wait 1.5 seconds here.
    * If we know that we can use 'fakeAsync()' ane 'tick()' instead of 'async()' and 'fixture.whenStable()'.
    * 'tick()' means: finish all asynchronous tasks now.
    * Reason we can do this: 'Promise.resolve('Data')' means we will retrieve the data immediately.
    * 
    **/
    it('should fetch data successfully if called asynchronously', fakeAsync(() => {
      let fixture = TestBed.createComponent(UserComponent);
      let app = fixture.debugElement.componentInstance;
      let dataService = fixture.debugElement.injector.get(DataService);
      let spy = spyOn(dataService, 'getDetails')
        .and.returnValue(Promise.resolve('Data'));
      fixture.detectChanges();
      tick();
      expect(app.data).toBe('Data');

    }));
  });


440. Isolated vs Non-Isolated Tests.

Setup of the app:

UserComponent
  --> UserService
ReversePipe

UserComponent and UserService are connected because UserService is injected into UserComponent.
ReversePipe is not connected.

reverse.pipe
- ts:

  import { Pipe } from "@angular/core";

  @Pipe({
    name: 'reverse'
  })
  export class ReversePipe {
    transform(value: string) {
      return value.split("").reverse().join("");
    }
  }

- spec.ts:

  /* tslint:disable:no-unused-variable */

  import { ReversePipe } from "./reverse.pipe";
  describe('Pipe: ReversePipe', () => {
    it('should reverse the inputs', () => {
      let reversePipe = new ReversePipe();
      expect(reversePipe.transform('hello')).toEqual('olleh');
    });

  });

Class ReversePipe is a utility class containing a method reversing a string.
For this no specific Angular test functionality is necessary.

There is a lot more in this field. Unit testing merits it's own course.

441. Further Resources & Where to Go Next.

  This Module only provides a brief and basic Introduction to Angular Unit Tests and the Angular Testing Suite. This Course isn't focused on Testing.

  If you want to dive deeper, the official Docs actually are a great place to start. There you'll also find a Non-CLI Setup!

  Official Docs: https://angular.io/guide/testing

  I can also recommend the following Article: https://semaphoreci.com/community/tutorials/testing-components-in-angular-2-with-jasmine

  For more Information on how to run Tests with the CLI have a look at their official Docs:

  => Unit Tests: https://github.com/angular/angular-cli/wiki/test

  => E2E Tests: https://github.com/angular/angular-cli/wiki/e2e

See:
- https://angular.io/guide/testing


===================================================================================================
2022-06-12:

Section: 30. Angular as a Platform & Closer Look at the CLI.

442. Module Introduction.

443. A Closer Look at "ng new".

$ ng new --help

Also check:
- https://angular.io/api?type=directive
  - https://angular.io/cli

Create a new application (very very basic):
$ ng new angular-config

$HOME/Development/workspaceJS/Angular/angular-config/src/app/app.component.ts

444.IDE & Project Setup

445. Understanding the Config Files.

- package-lock.json is created when 'npm install' is executed.
- tsconfig.json configures the TypeScript compiler.
  - e.g. here is defined:
    - "strict": true
    - "angularCompilerOptions"
      - Is picked up by the Angular compiler after the TS compiler has finished.
  - Note that in the normal course applications the config is quite different from the standard setup.
- tsconfig.spec.json
  - TypeScript config for testing.
- tslint.json
  - Checks the code quality.
  - Not present in Angular 14.


Also look at:
- https://angular.io/guide/angular-compiler-options


446. Important CLI Commands.

$ ng --help
ng <command>

Commands:
  ng analytics                   Configures the gathering of Angular CLI usage metrics. See https://angular.io/cli/usage-analytics-gathering
  ng cache                       Configure persistent disk cache and retrieve cache statistics.
  ng completion                  Set up Angular CLI autocompletion for your terminal.
  ng config [json-path] [value]  Retrieves or sets Angular configuration values in the angular.json file for the workspace.
  ng doc <keyword>               Opens the official Angular documentation (angular.io) in a browser, and searches for a given keyword.                                                                                                                                                             [aliases: d]
  ng new [name]                  Creates a new Angular workspace.                                                                                                                                                                                                                                  [aliases: n]
  ng version                     Outputs Angular CLI version.                                                                                                                                                                                                                                      [aliases: v]

Options:
  --help  Shows a help message for this command in the console.    

- https://angular.io/cli

For the other options you have to be in the application (root) in order to view the detailed possibilities.
e.g.:
- ng serve --help

I'll have to https://angular.io/cli in order to get an overview.

$ ng lint
- https://angular.io/cli/lint

Doesn't seem to work as intended.

If I change the selector in:


@Component({
  selector: 'root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title = 'angular-config';
}

ng lint does not provide an overview of errors.

$ ng build --prod
- This option is now not possible anymore: does not work.
- See also https://angular.io/cli/build
- Apparently 'ng build' suffices now.

You should use now:
$ ng build --configuration production
$ ng build --configuration development
Or other configs defined in angular.json under "configurations".

447. The "angular.json" File - A Closer Look.

- Used by the CLI when executing commands.

    "angular-config": {
      "projectType": "application", // Could also be: "library"
      "schematics": {
        "@schematics/angular:application": {
          "strict": true
        }
      },

Directory /assets can be used to store items like images, etc.
When building this content would be added to the /dist folder.

            "scripts": []
            - Here specific JS script, e.g. regarding google-maps, can be added. Stored elsewhere.

"configurations":
- Here specifics for different environments can be defined.
  - development
  - production
  - but if necessary also e.g. test, acceptance.


448. Angular Schematics.

Blueprints that can be picked up by certain Ng commands.
- ng generate
  - Generate new building block, e.g. components
- ng add
  - Add libraries & capabilities to a project
- ng update
  - Update projects & libraries

You / third-party libraries can add custom schematics.

- https://angular.io/guide/schematics
  A schematic is a template-based code generator that supports complex logic. 
  It is a set of instructions for transforming a software project by generating or modifying code. 
  Schematics are packaged into collections and installed with npm.


449. The "ng add" command.

Resource:
- https://material.angular.io/guide/getting-started

Example:
$ ng add @angular/material

450. Using Custom "ng generate" Schematics.

$ ng generate @angular/material:nav         
? What should be the name of the component? main-nav
CREATE src/app/main-nav/main-nav.component.css (193 bytes)
CREATE src/app/main-nav/main-nav.component.html (937 bytes)
CREATE src/app/main-nav/main-nav.component.spec.ts (1270 bytes)
CREATE src/app/main-nav/main-nav.component.ts (597 bytes)
UPDATE src/app/app.module.ts (980 bytes)


450. Smooth Updating of Projects with "ng update".

$ ng update
--> all packages in the app will be checked for an update.

Found 25 dependencies.
    We analyzed your package.json, there are some packages to update:
    
      Name                               Version                  Command to update
     --------------------------------------------------------------------------------
      @angular-eslint/schematics         1.0.0 -> 13.5.0          ng update @angular-eslint/schematics
    
    There might be additional packages which don't provide 'ng update' capabilities that are outdated.
    You can update the additional packages by running the update command of your package manager.
rkremers@BKWI_C02ZX41RMD6R:~/Development/workspaceJS/Angular/angular-config (master *+)$ ng update @angular-eslint/schematics --force

Run the updates
Afterwards run 'npm install'

452. Simplified Deployment with "ng deploy".

Describes mostly the setup and connection to firebase (has been done in this course).

453. Understanding "Differential Loading".

File .browserslistrc

Image result for angular differential loading
In a nutshell, differential loading means to send newer, flashier code to newer browsers and stable legacy code to legacy browsers. 
This generally translates into two things: modern syntax and polyfills.


454. Managing Multiple Projects in One Folder.

455. Angular Libraries - An Introduction.

Concerns the creation of custom libraries.
It is possibl to create (open source) libraries. In that case a subscription to 'npm' is necessary.

456. Wrap Up.


===================================================================================================
2022-06-13:

Section: 31. Angular Changes & New Features.

457. A First Look At Angular Elements.

===================================================================================================
2022-06-13:

Section: 32. Course Roundup.


Bonus: More Content!
I got a lot of other high-quality & bestselling courses you might be interested in: https://academind.com/learn/our-courses/

I'd love to welcome you on board of any of these courses! :-)

Also don't forget to subscribe to my newsletter on https://academind.com/ to receive the latest updates and exclusive offers!

And in case you didn't know: On the same page as well as on my YouTube channel I got loads of additional tutorials.

Last but not least - I tweet on @maxedapps and on @academind_real, would love to see you there!


===================================================================================================
2022-06-13:

Section: 33. Bonus: TypeScript Introduction (for Angular 2 Usage).

460. Module Introduction.

461. What & Why?

TypeScript:
- Adds static typing to JavaScript.

/Users/rkremers/Development/workspaceJS/TypeScriptTutorial
$ ls -l
total 120
-rw-r--r--  1 rkremers  staff    256 Jun 14 08:21 angular_course.html
-rw-r--r--  1 rkremers  staff  10735 Jun 16  2021 cheatsheet.js
-rw-r--r--  1 rkremers  staff    141 Jun 14 08:31 no-typescript.js
-rw-r--r--  1 rkremers  staff    139 Jun 14 08:23 no-typescript.ts
-rw-r--r--  1 rkremers  staff    187 Jun 16  2021 tstut.html
-rw-r--r--  1 rkremers  staff  13375 Jun 17  2021 tstut.js
-rw-r--r--  1 rkremers  staff  14330 Jan  4 10:51 tstut.ts

# Compile the ts file automatically if a change is detected. This will create a no-typescript.js file which will be called in angular_course.html.
$ tsc no-typescript.ts --watch --target ES6

462. Installing & Using TypeScript.

463. Base Types & Primitives.

var vs let vs const:

- var declarations:
  - are globally scoped or function scoped while let and const are block scoped.
  - can be updated and re-declared within its scope;
  - acan be declared without being initialized.
- let variables 
  - can be updated but not re-declared; 
  - can be declared without being initialized.
- const variables 
  - can neither be updated nor re-declared.
  - must be initialized during declaration.

Implementation:
$ pwd
/Users/rkremers/Development/workspaceJS/TypeScriptTutorial
$ ls -l
total 136
-rw-r--r--  1 rkremers  staff    256 Jun 14 08:21 angular_course.html
-rw-r--r--  1 rkremers  staff  10735 Jun 16  2021 cheatsheet.js
-rw-r--r--  1 rkremers  staff   5267 Jun 14 22:41 no-typescript.js
-rw-r--r--  1 rkremers  staff   5968 Jun 14 22:41 no-typescript.ts
-rw-r--r--  1 rkremers  staff    187 Jun 16  2021 tstut.html
-rw-r--r--  1 rkremers  staff  13375 Jun 17  2021 tstut.js
-rw-r--r--  1 rkremers  staff  14330 Jan  4 10:51 tstut.ts


For this Section is used:
angular_course.html
no-typescript.ts
--> Resulting from the tsc compiler action:
  - no-typescript.js

In general in an Angular project is present:
- tsconfig.json:

/* To learn more about this file see: https://angular.io/config/tsconfig. */
{
  "compileOnSave": false,
  "compilerOptions": {
    "baseUrl": "./",
    "outDir": "./dist/out-tsc",
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "noImplicitOverride": true,
    "noPropertyAccessFromIndexSignature": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "sourceMap": true,
    "declaration": false,
    "downlevelIteration": true,
    "experimentalDecorators": true,
    "moduleResolution": "node",
    "importHelpers": true,
    "target": "es2020",
    "module": "es2020",
    "lib": [
      "es2020",
      "dom"
    ]
  },
  "angularCompilerOptions": {
    "enableI18nLegacyMessageIdFormat": false,
    "strictInjectionParameters": true,
    "strictInputAccessModifiers": true,
    "strictTemplates": true
  }
}

473. Module Resources:

typescript-intro-01-finished.zip.

Angular - The Complete Guide (2022 Edition)

Certificate no: UC-f45fdeOf-d9d6-4ae6-8b5d-fd938b4d268d
Certificate url: http://ude.my/UC-f45fdeOf-d9d6-4ae6-8b5d-fd938b4d268d

The firebase database that has been used:
https://console.firebase.google.com/project/ng-course-recipe-book-375da/overview
https://console.firebase.google.com/project/ng-course-recipe-book-375da/database/ng-course-recipe-book-375da-default-rtdb/rules



---------------------------------------------------------------------------------------------------
https://github.com/getarrays


---------------------------------------------------------------------------------------------------
2022-08-25:

- Traversy Media: Angular Crash Course
  - https://www.youtube.com/watch?v=3dHNOWTI7H8&list=PL2JJ4C58058JJPHOsReebVX2SrDVdZoRv&index=2
  - Code:
    - https://github.com/bradtraversy/angular-crash-2021

Angular CLI:
- Standard tooling for Angular development:
  $ npm install -g @angular/cli
- Command line interface for creating Angular apps
  $ ng new my-app
- Dev server and easy production build
- Commands to generate components, services, etc.

- https://angular.io/guide/setup-local
   cd my-app
   ng serve --open # opens your browser to http://localhost:4200/

Continue here: 8:58.


$ npm -v
8.1.2

$ ng version

     _                      _                 ____ _     ___
    / \   _ __   __ _ _   _| | __ _ _ __     / ___| |   |_ _|
   / △ \ | '_ \ / _` | | | | |/ _` | '__|   | |   | |    | |
  / ___ \| | | | (_| | |_| | | (_| | |      | |___| |___ | |
 /_/   \_\_| |_|\__, |\__,_|_|\__,_|_|       \____|_____|___|
                |___/
    

Angular CLI: 14.0.0
Node: 16.13.1
Package Manager: npm 8.1.2 
OS: darwin x64

Angular: 
... 

Package                      Version
------------------------------------------------------
@angular-devkit/architect    0.1400.0 (cli-only)
@angular-devkit/core         14.0.0 (cli-only)
@angular-devkit/schematics   14.0.0 (cli-only)
@schematics/angular          14.0.0 (cli-only)

/Users/rkremers/Development/workspaceJS/traversyMedia/angular-crash/

$ ng new angular-crash --no-strict

- Choose standard CSS

$ cd angular-crash/

Start IntelliJ and open the project.
Continue there in the terminal window.

$ng serve

View: http://localhost:4200/ 

/Users/rkremers/Development/workspaceJS/traversyMedia/angular-crash/src/styles.css
- Filled with content from https://github.com/bradtraversy/angular-crash-2021

After this insert the web page shows a different style.

New terminal in IntelliJ.

$ ng generate component components/header

$ ng generate component components/button

Study:
- Directives
  - ngStyle


Continue here: 30:56.

$ ng generate component components/tasks

$ ng generate component components/task-item


https://github.com/FortAwesome/angular-fontawesome
ng add @fortawesome/angular-fontawesome@<version>

Continue here: 41:54.

traversyMedia/angular-crash/package-lock.json
Added:

        "@fortawesome/angular-fontawesome": "^0.11.1",
        "@fortawesome/fontawesome-svg-core": "^6.1.1",
        "@fortawesome/free-brands-svg-icons": "^6.1.1",
        "@fortawesome/free-regular-svg-icons": "^6.1.1",
        "@fortawesome/free-solid-svg-icons": "^6.1.1",

app-module.ts:
import { FontAwesomeModule } from '@fortawesome/angular-fontawesome';

Using fontawesome:
- https://fontawesome.com/start
- https://github.com/FortAwesome/angular-fontawesome

$ ng generate service services/task

https://github.com/typicode/json-server
- Intended as a local server to work with.

Install JSON Server

$ npm install json-server # So only local; not global.

Go to package.json:
"json-server": "^0.17.0",


  "scripts": {
    "ng": "ng",
    "start": "ng serve",
    "build": "ng build",
    "watch": "ng build --watch --configuration development",
    "test": "ng test",
    "server": "json-server --watch db.json --port 5000" # !!!! custom added.
  },

Create db.json in the root:
- Fill it with the content from angular-crash/src/app/mock-tasks.ts (which is in TypeScript!)

{
  "tasks": [
    {
      "id": 1,
      "text": "Doctors Appointment",
      "day": "May 5th at 2:30pm",
      "reminder": true
    },
    {
      "id": 2,
      "text": "Meeting at School",
      "day": "May 6th at 2:30pm",
      "reminder": true
    },
    {
      "id": 3,
      "text": "Food Shopping",
      "day": "May 7th at 12:30pm",
      "reminder": false
    }
  ]
}


Now it is possible to run the json-server:

$ npm run server

  > angular-crash@0.0.0 server
  > json-server --watch db.json --port 5000


    \{^_^}/ hi!

    Loading db.json
    Done

    Resources
    http://localhost:5000/tasks

    Home
    http://localhost:5000

Example:
- Browser: http://localhost:5000/tasks/1

{
  "id": 1,
  "text": "Doctors Appointment",
  "day": "May 5th at 2:30pm",
  "reminder": true
}

Now there is a (fake) backend.

app.module.ts
import {HttpClientModule} from '@angular/common/http';

  imports: [
    BrowserModule,
    FontAwesomeModule,
    HttpClientModule # !!!!
  ],


task.service.ts:
import {HttpClient, HttpHeaders} from '@angular/common/http';

export class TaskService {
  private apiUrl = 'http://localhost:5000/tasks';

  constructor(private http:HttpClient) { }

  getTasks(): Observable<Task[]> {
    // const tasks = of(TASKS);
    // return tasks;
    return this.http.get<Task[]>(this.apiUrl);
  }
}

--> We are iteracting now with the backend.

Continue here: 1:13:39

Study: Directive ngClass

$ ng generate component components/add-task

app.module.ts:
Add FormsModule to be used in add-task component.

Cpntinue here: 1:37:35.

Study:
https://ncjamieson.com/understanding-subjects/

The connecting of observers to an observable is what subjects are all about. 
They’re able to do it because subjects themselves are both observers and observables.
Subjects are primarily for multicasting.

Alternative types:
- AsyncSubject    : is equivalent to composing the observable using a Subject and the 'last' operator
- BehaviorSubject : is equivalent to composing the observable using a Subject and the 'startWith' operator
- ReplaySubject

https://angular.io/guide/observables
Observables provide support for passing messages between parts of your application. 

The observer pattern is a software design pattern in which an object, called the subject, maintains a list of its dependents, called observers, and notifies them automatically of state changes.

Observables are declarative —that is, you define a function for publishing values, but it is not executed until a consumer subscribes to it. The subscribed consumer then receives notifications until the function completes, or until they unsubscribe.

$ ng generate service services/ui

$ ng generate component components/about

$ ng generate component components/footer

Quick setup — if you’ve done this kind of thing before
or  
https://github.com/robkremers/angular-crash.git
Get started by creating a new file or uploading an existing file. We recommend every repository include a README, LICENSE, and .gitignore.

…or create a new repository on the command line
echo "# angular-crash" >> README.md
git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin https://github.com/robkremers/angular-crash.git
git push -u origin main
…or push an existing repository from the command line
git remote add origin https://github.com/robkremers/angular-crash.git
git branch -M main
git push -u origin main


===================================================================================================
2022-09-08:

Angular: Getting Started with Standalone Components in Angular
- https://www.youtube.com/watch?v=x5PZwb4XurU&list=PL2JJ4C58058JJPHOsReebVX2SrDVdZoRv&index=2

Standalone components are self-contained and manage their template depdencies.
This makes ngModule optional for many practical development tasks.
The focus shifts from ng modules to components.

Benefits:
- Frictionless component creation.
- Simplified learning journey.
- Lazy-loading for made easy.

$ ng new standalone-components --inline-style --inline-template --routing --no-strict
- Add routing
- css styling


===================================================================================================
2022-09-08:

- References:
  - https://jasmine.github.io/pages/docs_home.html
  - https://github.com/jasmine/jasmine
  - https://angular.io/api/common/http/testing

Genka: Angular Unit Test Tutorial - Crash Course for Angular & Jasmine
- https://www.youtube.com/watch?v=ibatZSCgXLY
- https://github.com/tamani-coding/angular-testing-examples

If you put an 'x' before a test function:
- describe() --> xdescribe()
or before the 'it' method:
- it() --> xit()
The test will be ignored.

If you put an 'f' before a test function or an 'it' method the testing will focus on these tests.
That means: only these tests will be executed.

Check:
- httpMock

(00:00) - Intro
(02:37) - Setup Example Project
(03:48) - What are Isolated Unit Tests
(04:09) - Configure Testbed/Testingmodule
(05:14) - Using HttpClientTestingModule to Mock Http Calls
(07:57) - Component Test with Spy
(10:25) - Testing Asynchronous Components Synchronously
(12:46) - Outro



Mockg

Example API: https://randomuser.me/api/

Example of mocking:

gebruikers-administratie-frontend-angular/src/app/app.component.spec.ts

  // Mock the httpClient used by the HelloWorldApiService the AppComponent depends upon
  let httpClientSpy: jasmine.SpyObj<HttpClient>;

Also: 
Check https://github.com/tamani-coding/angular-testing-examples, part of the  YT tutorial.
- Example of mocking.

const userServiceMock = jasmine.SpyObj<UserService>('getUser');


 beforeEach(async () => {

    httpClientSpy = jasmine.createSpyObj('HttpClient', ['get']);

It is necesssary to:
- Create an application-model, e.g. in Word or in another tool.
- Create an overview of tests (not up to the last detail).

Todo:
- Check in the reference:
  - jasmine.createSpyObj()
  - jasmine.createSpy()
  * https://scriptverse.academy/tutorials/jasmine-createspy-createspyobj.html
  - jasmine.SpyObj()


UserComponent -> UserService -> External API

Tests:

UserComponent -> UserService Spy

                  UserService -> External API HTTP Mock

https://angular.io/api/common/http/testing

For the test of UserService:
- https://randomuser.me/api/ is mocked.

For the test of UserComponent.

Continue here: 8:03


https://www.digitalocean.com/community/tutorials/testing-angular-with-jasmine-and-karma-part-1


$ ng test --help
Your global Angular CLI version (14.0.0) is greater than your local version (13.2.6). The local Angular CLI version is used.

To disable this warning use "ng config -g cli.warnings.versionMismatch false".
Runs unit tests in a project.
usage: ng test <project> [options]

arguments:
  project
    The name of the project to build. Can be an application or a library.

options:
  --browsers 
    Override which browsers tests are run against.
  --code-coverage 
    Output a code coverage report.
  --code-coverage-exclude 
    Globs to exclude from code coverage.
  --configuration (-c)
    One or more named builder configurations as a comma-separated list as specified in the "configurations" section of angular.json.
    The builder uses the named configurations to run the given target.
    For more information, see https://angular.io/guide/workspace-config#alternate-build-configurations.
    Setting this explicitly overrides the "--prod" flag.
  --help 
    Shows a help message for this command in the console.
  --include 
    Globs of files to include, relative to workspace or project root. 
    There are 2 special cases:
     - when a path to directory is provided, all spec files ending ".spec.@(ts|tsx)" will be included
     - when a path to a file is provided, and a matching spec file exists it will be included instead.
  --inline-style-language 
    The stylesheet language to use for the application's inline component styles.
  --karma-config 
    The name of the Karma configuration file.
  --main 
    The name of the main entry-point file.
  --poll 
    Enable and define the file watching poll time period in milliseconds.
  --polyfills 
    The name of the polyfills file.
  --preserve-symlinks 
    Do not use the real path when resolving modules. If unset then will default to `true` if NodeJS option --preserve-symlinks is set.
  --prod 
    Shorthand for "--configuration=production".
    Set the build configuration to the production target.
    By default, the production target is set up in the workspace configuration such that all builds make use of bundling, limited tree-shaking, and also limited dead code elimination.
  --progress 
    Log progress to the console while building.
  --reporters 
    Karma reporters to use. Directly passed to the karma runner.
  --source-map 
    Output source maps for scripts and styles. For more information, see https://angular.io/guide/workspace-config#source-map-configuration.
  --ts-config 
    The name of the TypeScript configuration file.
  --watch 
    Run build when files change.
  --web-worker-ts-config 
    TypeScript configuration for Web Worker modules.


https://angular-university.io/lesson/angular-testing-understanding-jasmine-done

https://codecraft.tv/courses/angular/unit-testing/asynchronous/
- Understand the issues faced when testing async code in Jasmine.
- Know how to use the Jasmine done() function to handle async code.
- Know how to use the alternative Angular only solutions for testing async code.
- https://github.com/codecraft-tv/angular-course/blob/current/13.unit-testing/7.asynchronous/code/app/login.component.spec.ts

import { TestBed } from '@angular/core/testing';
import { ComponentFixture, TestBed } from '@angular/core/testing';

Jasmin vs the Angular way:

- Jasmine:
  - Using the 'done()' function.

    it('Button label via jasmine.done', (done) => {
        fixture.detectChanges();
        expect(el.nativeElement.textContent.trim()).toBe('Login');

        // Make the authService return a promise that resolves to true
        let spy = spyOn(authService, 'isAuthenticated').and.returnValue(Promise.resolve(true));
        // We trigger the component to check the authService again
        component.ngOnInit();

        // We now want to call a function when the Promise returned from authService.isAuthenticated() is resolved
        spy.calls.mostRecent().returnValue.then(() => {
            // The needsChanged boolean has been updated on the Component so to update the template we trigger change detection
            fixture.detectChanges();
            // Now the label is Logout
            expect(el.nativeElement.textContent.trim()).toBe('Logout');
            // We tell jasmine we are done with this test spec
            done();
        });
    });

--> in it() a function is defined with input: 'done'.
  --> Later when everything has been executed we call 'done()' in order to indicate this.

Disadvantage:
- We need an understanding of the AuthService, in this case 'isAuthenticated' in order to handle this properly.
  This is less desirable.

    - https://angular.io/guide/testing
    - https://codecraft.tv/courses/angular/unit-testing/overview/
      - https://codecraft.tv/courses/angular/unit-testing/jasmine-and-karma/
      - https://codecraft.tv/courses/angular/unit-testing/asynchronous/
      - Jawache: EP 13.7 - Angular / Unit Testing / Asynchronous Code
        - https://www.youtube.com/watch?v=V50kMQ5QhgA
        - https://github.com/codecraft-tv/angular-course/tree/current/13.unit-testing/7.asynchronous
      - https://www.digitalocean.com/community/tutorials/testing-angular-with-jasmine-and-karma-part-1


A TestBed acts as a dummy Angular module.
Using it we can configure it with a set of providers. Exactly as would be done with a normal module.  
e.g. a service would now be declared.




